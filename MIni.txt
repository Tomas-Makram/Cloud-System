#ifndef MINI_HSFS_H
#define MINI_HSFS_H

#include "VirtualDisk.h"
#include <vector>
#include <string>
#include <map>
#include <ctime>
#include <mutex>
#include <memory>
#include <algorithm>
#include <unordered_map>
#include <iostream>
#include <sstream>
#include <unordered_set>
#include <stdexcept>
#include <cstring>
#include <list>
#include <deque>

class MiniHSFS {


public:

    struct SuperblockInfo {
        char magic[8];                   //8bytes
        uint32_t version;               // 4 bytes
        uint32_t systemSize;           // 4 bytes
        uint32_t blockSize;           // 4 bytes
        size_t inodeSize;            // 4 bytes
        uint64_t totalBlocks;       // 8 bytes
        uint64_t freeBlocks;       // 8 bytes
        size_t totalInodes;       // 4 bytes
        size_t freeInodes;       // 4 bytes
        time_t creationTime;    // 8 bytes (Usually)
        time_t lastMountTime;  // 8 bytes
        time_t lastWriteTime; // 8 bytes
        uint32_t state;      // 4 bytes
    };

    // Inode structure
    //struct Inode {
    //    uint64_t size = 0;                      // 8 bytes
    //    int blocksUsed = 0;                    // 4 bytes
    //    int firstBlock = -1;                  // 4 bytes
    //    bool isDirectory = false;            // 1 byte 
    //    bool isUsed = false;                // 1 byte
    //    time_t creationTime = 0;           // 8 bytes
    //    time_t modificationTime = 0;      // 8 bytes
    //    bool isDirty = false;            // 1 byte  ( Has it been modified? )
    //    int accessCount = 0;            // 4 bytes
    //    time_t lastAccessed = 0;       //8 bytes Last used time
    //    bool isLoaded = false;        // 1 byte
    //    std::map<std::string, int> entries; //Not Constant 12*n

    //    size_t calculateSerializedSize() const;

    //};

    struct Inode {
        size_t size = 0;
        int blocksUsed = 0;
        int firstBlock = -1;
        bool isDirectory = false;
        bool isUsed = false;
        bool isDirty = false;
        time_t creationTime = 0;
        time_t modificationTime = 0;
        time_t lastAccessed = 0;
        std::unordered_map<std::string, int> entries; // For directories

        // دالة لاحتساب الحجم الفعلي للعقدة
        size_t actualSize() const {
            size_t baseSize = sizeof(size) + sizeof(blocksUsed) + sizeof(firstBlock) +
                sizeof(isDirectory) + sizeof(isUsed) +
                sizeof(creationTime) + sizeof(modificationTime) +
                sizeof(lastAccessed) + sizeof(isDirty);

            if (isDirectory) {
                baseSize += sizeof(size_t); // لحجم الـ unordered_map
                for (const auto& entry : entries) {
                    baseSize += entry.first.size() + sizeof(int);
                }
            }
            return baseSize;
        }
    };

    int btreeOrder;

    struct BTreeNode {
        bool isLeaf;
        int keyCount;
        int* keys;
        union {
            int* children;
            int* values;
        };
        int nextLeaf;
        int accessCount;
        bool isDirty;
        int order; //We need to store btreeOrder in each node

        //Basic constructor
        BTreeNode(int btree_order, bool leaf = true)
            : isLeaf(leaf), keyCount(0), nextLeaf(-1),
            accessCount(0), isDirty(false), order(btree_order)
        {
            keys = new int[btree_order - 1];
            if (isLeaf)
                values = new int[btree_order - 1]();
            else
                children = new int[btree_order]();
            std::fill(keys, keys + btree_order - 1, -1);
        }

        //Default constructor(to bypass C2512 errors)
        BTreeNode() : isLeaf(true), keyCount(0), nextLeaf(-1),
            accessCount(0), isDirty(false), order(4)
        {
            keys = new int[order - 1];
            values = new int[order - 1]();
            std::fill(keys, keys + order - 1, -1);
        }

        ~BTreeNode() {
            delete[] keys;
            if (isLeaf)
                delete[] values;
            else
                delete[] children;
        }

        BTreeNode(const BTreeNode& other)
            : isLeaf(other.isLeaf), keyCount(other.keyCount),
            nextLeaf(other.nextLeaf), accessCount(other.accessCount),
            isDirty(other.isDirty), order(other.order)
        {
            keys = new int[order - 1];
            std::copy(other.keys, other.keys + order - 1, keys);
            if (isLeaf) {
                values = new int[order - 1];
                std::copy(other.values, other.values + order - 1, values);
            }
            else {
                children = new int[order];
                std::copy(other.children, other.children + order, children);
            }
        }

        BTreeNode& operator=(const BTreeNode& other) {
            if (this == &other) return *this;
            isLeaf = other.isLeaf;
            keyCount = other.keyCount;
            nextLeaf = other.nextLeaf;
            accessCount = other.accessCount;
            isDirty = other.isDirty;
            order = other.order;

            delete[] keys;
            keys = new int[order - 1];
            std::copy(other.keys, other.keys + order - 1, keys);

            if (isLeaf) {
                delete[] values;
                values = new int[order - 1];
                std::copy(other.values, other.values + order - 1, values);
            }
            else {
                delete[] children;
                children = new int[order];
                std::copy(other.children, other.children + order, children);
            }

            return *this;
        }
    };

    // Constants

    std::vector<Inode> inodeTable;
    std::map<int, BTreeNode> btreeCache;
    // B-tree node structure
    BTreeNode rootNode;
    std::recursive_mutex fsMutex;
    bool mounted = false;
    bool initialized = false;
    const int superBlockIndex = 0;
    int superBlockBlocks;
    size_t inodeCount;
    size_t inodeBlocks;
    int btreeBlocks;
    int btreeStartIndex;
    int dataStartIndex;
    time_t lastTimeWrite = -1;
    std::list<int> btreeLruList;
    std::unordered_map<int, std::list<int>::iterator> btreeLruMap;

    std::list<int> inodeLruList;
    std::unordered_map<int, std::list<int>::iterator> inodeLruMap;

    int btreeLoadCounter = 0;
    int inodeLoadCounter = 0;
    int rootNodeIndex = 0;



    const int maxFileNameLength = 255;
    const int maxPathLength = 4096;
    size_t inodeSize;
    size_t inodePercentage;
    size_t btreePercentage;

    //----------------------------------------------//
    
    bool autoDefrag = true;   // إعادة التنظيم التلقائية

    // دوال إدارة العقد الديناميكية
    int AllocateInode(bool isDirectory = false);
    int InitializeInode(int index, bool isDirectory);
    void FreeInode(int inodeIndex);
    void DefragmentInodes();
    size_t GetAvailableInodes();
    bool CanCreateMoreInodes();
    void ExpandInodeArea(size_t additionalSize);
    void AutoDefragmentInodes();

    // متغيرات العقد الديناميكية
    std::vector<int> freeInodesList;
    bool dynamicInodes;
    size_t nextInodeIndex;
    size_t maxPossibleInodes;

    // دوال مساعدة للعقد الديناميكية
    void ExtendInodeTable(size_t additionalInodes = 0);
    void CompactInodeTable();
    void RebuildFreeInodesList();
    size_t CalculateMaxPossibleInodes();

    // في قسم private أضف:
    std::vector<bool> inodeBitmap; // لتتبع العقد المستخدمة/الحرة
    size_t nextFreeInode = 1;      // لتسريع البحث عن عقدة حرة
    size_t inodeAreaSize = 0;      // الحجم الحالي لمساحة العقد

    // أضف هذه الدوال:
    void ExtendInodeArea(size_t additionalInodes = 0);
    void UpdateSuperblockForDynamicInodes();
    bool CanAllocateInodes(size_t count);
    void RebuildInodeBitmap();
    void FreeBlock(uint32_t blockIndex);
    bool AllocateContiguousRegion(uint32_t start, size_t count);
    std::vector<std::tuple<int, uint32_t, uint32_t>> CollectFileExtents();
    void MoveInodeExtent(int inodeIndex, uint32_t srcStart, uint32_t dstStart, uint32_t count);
    bool DefragmentDataAreaToFreePrefix(size_t neededBlocks);
    bool ExpandInodeAreaInPlace(size_t addInodes);
    size_t BlocksForInodes(size_t inodeCount);
    uint32_t dataStartBlock = 0; // بداية منطقة البيانات
    size_t freeBlocks = 0;       // عدد البلوكات الحرة
    bool ReserveContiguousBlocksAtDataStart(size_t count);
    void ResetInode(int idx, bool isDir);
    bool TryExtendInodeTable();
    bool DefragmentAndExtendInodes(size_t extraInodes);
    void UpdateFileBlocks(int inodeIndex, const std::vector<int>& newBlocks);
    int FindFreeBlockFrom(size_t startBlock);

    std::vector<int> GetFileBlocks(int inodeIndex);
    size_t SerializeInode(const Inode& inode, char* buffer, size_t bufferSize);
    size_t DeserializeInode(Inode& inode, const char* buffer, size_t bufferSize);
    //----------------------------------------------//

    std::atomic<bool> autoSyncRunning = false;
    std::thread autoSyncThread;

    //Config currentConfig;
    std::condition_variable auto_sync_cv;
    std::mutex auto_sync_mutex;


    MiniHSFS(const std::string& path, uint32_t sizeMB, uint32_t blockSize);
    ~MiniHSFS();
    VirtualDisk& Disk();

    bool IsBTreeBlockFree(int index);


    void calculatePercentage(double inodePercentage = 0.015, double btreePercentage = 0.01);
    size_t calculateInodeCount();
    size_t calculateInodeBlocks();
    size_t calculateBTreeBlocks();
    size_t calculateBTreeOrder();
    size_t CountFreeInodes();
    size_t getAvailableMemory();

    // Filesystem operations
    void Initialize();
    void Mount(size_t inodePercentage = 0, size_t btreePercentage = 0, size_t inodeSize = 512);
    void Unmount();
    bool IsMounted() { return mounted; }

    // File operations
    int FindFile(const std::string& path);
    bool FreeFileBlocks(Inode& inode);

    // Directory operations
    void MarkBlockUsed(int blockIndex);

    void MarkBlocksUsed(const VirtualDisk::Extent& extent);


    int PathToInode(const std::vector<std::string>& path);
    std::vector<std::string> SplitPath(const std::string& path)const;
    void ValidatePath(const std::string& path);
    void UpdateInodeTimestamps(int inodeIndex, bool modify = true);

    // Utility functions
    void PrintBTreeStructure();
    void PrintSuperblockInfo();

    // B-tree operations
    bool BTreeInsert(int nodeIndex, int key, int value);
    bool BTreeDelete(int nodeIndex, int key);

    int FindFreeBlock();

    VirtualDisk::Extent AllocateContiguousBlocks(int blocksNeeded);
    void SynchronizeDisk();
    void FreeLRUBTreeNode();

    int GetInodeIndex(const Inode& inode) const;
    //size_t Tooo(size_t plaintext);

private:
    VirtualDisk disk;
    
    std::vector<int> freeBTreeBlocksCache;

    // Private members    
    BTreeNode LoadBTreeNode(int nodeIndex);
    void SaveBTreeNode(int nodeIndex, const BTreeNode& node);
    int AllocateBTreeNode();
//    bool IsBTreeBlockEmpty(int index);
    void FreeBTreeNode(int nodeIndex);
    std::pair<bool, int> BTreeFind(int nodeIndex, int key);
    void BTreeSplitChild(int parentIndex, int childIndex, int index);
    bool BTreeMergeChildren(int nodeIndex, int index);
    bool BTreeInsertNonFull(int nodeIndex, int key, int value);
    int BTreeGetSuccessor(int nodeIndex);
    int BTreeGetPredecessor(int nodeIndex);
    bool BTreeDeleteFromNonLeaf(int nodeIndex, int index);
    bool BTreeDeleteFromLeaf(int nodeIndex, int index);
    void BTreeBorrowFromRight(int nodeIndex, int index);
    void BTreeBorrowFromLeft(int nodeIndex, int index);
    void BTreeFill(int nodeIndex, int index);

    // Private methods
    void InitializeSuperblock();
    void InitializeInodeTable();
    void InitializeBTree();

    void LoadInodeTable();
    void SaveInodeTable();

    void LoadBTree();
    void SaveBTree();

    SuperblockInfo LoadSuperblock();
    void SaveSuperblock(const SuperblockInfo& info);

    // B-tree operations
    bool IsBlockUsed(int blockIndex);

    // Helper functions
    void ValidateInode(int inodeIndex, bool checkDirectory = false);

    // Serialization
    //void SerializeInode(const Inode& inode, char* buffer, size_t bufferSize);
    //void DeserializeInode(Inode& inode, const char* buffer, size_t bufferSize);
    void SerializeBTreeNode(const BTreeNode& node, char* buffer);
    void DeserializeBTreeNode(BTreeNode& node, const char* buffer);


    void DefragmentFileBlocks(int inodeIndex);
    void RebuildFreeBlockList();
    void DefragmentDisk();


    void SaveInodeToDisk(int inodeIndex);
    void TouchBTreeNode(int index);
};

#endif // MINI_HSFS_H
----------------------------------------------------------//

#include "MiniHSFS.h"

///////////////////////////////Start System

MiniHSFS::MiniHSFS(const std::string& path, uint32_t sizeMB, uint32_t blockSize)
    :disk(std::max<int>(1, static_cast<int>(std::ceil((double)sizeof(SuperblockInfo) / blockSize))), blockSize),
    mounted(false),
    initialized(false),
    autoSyncRunning(false), btreeBlocks(0), btreeStartIndex(0), dataStartIndex(0), inodeBlocks(0)
    , inodeCount(0), dynamicInodes(true), nextInodeIndex(1) {

    // Format the virtual disk
    disk.Initialize(path, sizeMB);

    btreeOrder = static_cast<int>(calculateBTreeOrder());

    // Root Formatting
    rootNode = BTreeNode(btreeOrder, true);

    dataStartBlock = inodeBlocks; // بعد بلوكات الـ inodes مباشرة
    freeBlocks = disk.freeBlocksCount() - inodeBlocks;
}

VirtualDisk& MiniHSFS::Disk()
{
    return disk;
}

MiniHSFS::~MiniHSFS()
{
    Unmount();
}

void MiniHSFS::Initialize() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    if (initialized) {
        throw std::runtime_error("Filesystem already initialized");
    }

    if (!disk.ensureOpen()) {
        throw std::runtime_error("Virtual disk not open");
    }
    superBlockBlocks = std::max<int>(1, static_cast<int>(std::ceil((double)sizeof(SuperblockInfo) / disk.blockSize)));
    inodeCount = calculateInodeCount();
    inodeBlocks = calculateInodeBlocks();
    btreeBlocks = static_cast<int>(calculateBTreeBlocks());
    btreeStartIndex = static_cast<int>(inodeBlocks) + disk.getSystemBlocks() + superBlockBlocks;
    dataStartIndex = btreeStartIndex + btreeBlocks;

    try {
        if (disk.IsNew()) {
            InitializeSuperblock();

            InitializeBTree();
            disk.allocateBlocks(static_cast<uint32_t>(btreeBlocks ? btreeBlocks : 1));

            InitializeInodeTable();
            disk.allocateBlocks(static_cast<uint32_t>(inodeBlocks ? inodeBlocks : 1));

            //Create root directory
            inodeTable[0].isUsed = true;
            inodeTable[0].isDirectory = true;
            inodeTable[0].creationTime = time(nullptr);
            inodeTable[0].modificationTime = inodeTable[0].creationTime;

            SaveInodeTable();
            SaveBTree();
        }
        initialized = true;
    }
    catch (...) {
        //FlushDirtyInodes();
        SaveBTree();
        std::cerr << "!!Memory pressure during initialization. Flushing all caches.\n";

        btreeCache.clear();
        btreeLruMap.clear();
        btreeLruList.clear();
        inodeTable.clear();
        inodeLruMap.clear();
        inodeLruList.clear();
        throw;
    }
}

void MiniHSFS::Mount(size_t inodePercentage, size_t btreePercentage, size_t inodeSize) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    this->inodeSize = inodeSize;

    if (inodePercentage != 0 && btreePercentage != 0)
        calculatePercentage(inodePercentage, btreePercentage);
    else if (inodePercentage != 0 && btreePercentage == 0)
        calculatePercentage(inodePercentage = inodePercentage);
    else if (inodePercentage == 0 && btreePercentage != 0)
        calculatePercentage(btreePercentage = btreePercentage);
    else
        calculatePercentage();

    if (mounted) {
        throw std::runtime_error("Filesystem already mounted");
    }

    if (!initialized) {
        Initialize();
    }
    try {
        LoadInodeTable();
        LoadBTree();
        //// Verify root directory
        if (!inodeTable[0].isUsed || !inodeTable[0].isDirectory) {
            throw std::runtime_error("Root directory corruption detected");
        }

        mounted = true;
    }
    catch (const std::exception& e) {
        // Clean up if mount fails
        inodeTable.clear();
        inodeTable.resize(inodeCount);
        rootNode = BTreeNode(true);
        std::cout << e.what() << std::endl;
        throw e;
    }
}

//---------------------------------------------------------//

void MiniHSFS::InitializeInodeTable() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    // حساب عدد الـ Inodes المبدئي
    inodeCount = calculateInodeCount();
    maxPossibleInodes = CalculateMaxPossibleInodes();

    inodeTable.clear();
    inodeTable.resize(inodeCount);
    inodeBitmap.resize(inodeCount, false);

    // تهيئة العقدة الجذرية
    inodeTable[0].isUsed = true;
    inodeTable[0].isDirectory = true;
    inodeTable[0].creationTime = time(nullptr);
    inodeTable[0].modificationTime = inodeTable[0].creationTime;
    inodeBitmap[0] = true;

    // بناء قائمة العقد الحرة
    RebuildFreeInodesList();
}

// تخصيص عقدة جديدة
int MiniHSFS::AllocateInode(bool isDirectory) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    if (!freeInodesList.empty()) {
        int idx = static_cast<int>(freeInodesList.front());
        freeInodesList.erase(freeInodesList.begin()); // بدل pop_front
        return InitializeInode(idx, isDirectory);
    }

    for (size_t i = 1; i < inodeTable.size(); ++i) {
        if (!inodeTable[i].isUsed) {
            return InitializeInode(static_cast<int>(i), isDirectory);
        }
    }

    if (!ExpandInodeAreaInPlace(1)) {
        //throw std::runtime_error("Insufficient space for new inode");
        if (!DefragmentAndExtendInodes(1)) {
            throw std::runtime_error("Insufficient space for new inode even after defrag");
        }
    }

    int newIdx = static_cast<int>(inodeTable.size() - 1);
    return InitializeInode(newIdx, isDirectory);
}

// تحرير عقدة
void MiniHSFS::FreeInode(int index) {
    if (index <= 0 || index >= inodeTable.size()) return; // inode 0 للجذر

    // تحرير البلوكات
    if (!inodeTable[index].isDirectory) {
        FreeFileBlocks(inodeTable[index]);
    }
    else {
        inodeTable[index].entries.clear();
    }

    // تصفير بيانات inode
    inodeTable[index].isUsed = false;
    inodeTable[index].isDirectory = false;
    inodeTable[index].size = 0;
    inodeTable[index].blocksUsed = 0;
    inodeTable[index].firstBlock = -1;
    inodeTable[index].creationTime = 0;
    inodeTable[index].modificationTime = 0;
    inodeTable[index].lastAccessed = 0;
    inodeTable[index].isDirty = false;

    inodeBitmap[index] = false;
    RebuildFreeInodesList();

    UpdateSuperblockForDynamicInodes();
    SaveInodeTable();
}

// توسيع مساحة العقد
void MiniHSFS::ExpandInodeArea(size_t additionalSize) {
    size_t newTotalSize = inodeAreaSize + additionalSize;
    size_t newBlocksNeeded = (newTotalSize + disk.blockSize - 1) / disk.blockSize - inodeBlocks;

    if (newBlocksNeeded > 0) {
        // تخصيص كتل جديدة على القرص
        VirtualDisk::Extent extent(
            disk.getSystemBlocks() + superBlockBlocks + inodeBlocks,
            newBlocksNeeded
        );
        disk.allocateBlocks(extent.blockCount);

        // تهيئة الكتل الجديدة
        std::vector<char> zeroBlock(disk.blockSize, 0);
        for (size_t i = 0; i < newBlocksNeeded; ++i) {
            disk.writeData(zeroBlock,
                VirtualDisk::Extent(extent.startBlock + i, 1),
                "", true
            );
        }

        inodeBlocks += newBlocksNeeded;
        inodeAreaSize = inodeBlocks * disk.blockSize;
    }

    // إذا كانت المساحة المطلوبة أقل من المساحة المتاحة
    inodeAreaSize = (std::max)(inodeAreaSize, newTotalSize);

    // إعادة التنظيم التلقائي إذا كان مفعلاً
    if (autoDefrag && inodeTable.size() > 100) {
        AutoDefragmentInodes();
    }
}

// تمديد جدول العقد
//void MiniHSFS::ExtendInodeTable(size_t additionalInodes) {
//    std::lock_guard<std::recursive_mutex> lock(fsMutex);
//
//    size_t oldSize = inodeTable.size();
//    size_t newSize = oldSize + additionalInodes;
//
//    if (newSize > maxPossibleInodes) {
//        throw std::runtime_error("Cannot extend inode table beyond maximum limit");
//    }
//
//    inodeTable.resize(newSize);
//    inodeBitmap.resize(newSize, false);
//    inodeCount = newSize;
//
//    // تحديث عدد البلوكات
//    size_t requiredBlocks = (inodeCount * inodeSize + disk.blockSize - 1) / disk.blockSize;
//    if (requiredBlocks > inodeBlocks) {
//        disk.allocateBlocks(requiredBlocks - inodeBlocks);
//        inodeBlocks = requiredBlocks;
//    }
//
//    inodeAreaSize = inodeBlocks * disk.blockSize;
//    RebuildFreeInodesList();
//    UpdateSuperblockForDynamicInodes();
//    SaveInodeTable();
//}

void MiniHSFS::ExtendInodeTable(size_t additionalInodes) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    size_t oldSize = inodeTable.size();
    size_t newSize = oldSize + additionalInodes;

    if (newSize > maxPossibleInodes) {
        throw std::runtime_error("Cannot extend inode table beyond maximum limit");
    }

    // احتساب البلوكات المطلوبة
    size_t requiredBlocks = (newSize * inodeSize + disk.blockSize - 1) / disk.blockSize;

    // إذا كانت البلوكات الحالية غير كافية
    if (requiredBlocks > inodeBlocks) {
        // احجز مساحة إضافية على القرص
        size_t blocksToAdd = requiredBlocks - inodeBlocks;
        VirtualDisk::Extent extent(disk.getSystemBlocks() + superBlockBlocks + inodeBlocks, blocksToAdd);
        disk.allocateBlocks(extent.blockCount);

        // اكتب صفر في البلوكات الجديدة
        std::vector<char> zeroBlock(disk.blockSize, 0);
        for (size_t i = 0; i < blocksToAdd; ++i) {
            disk.writeData(zeroBlock,
                VirtualDisk::Extent(extent.startBlock + i, 1),
                "", true);
        }

        inodeBlocks = requiredBlocks;
    }

    // توسيع الهياكل في الذاكرة
    inodeTable.resize(newSize);
    inodeBitmap.resize(newSize, false);
    inodeCount = newSize;

    // تحديث السوبربلوك
    UpdateSuperblockForDynamicInodes();

    // إعادة بناء قائمة العقد الحرة
    RebuildFreeInodesList();

    // حفظ التغييرات
    SaveInodeTable();
}


// إعادة تنظيم العقد التلقائية
void MiniHSFS::AutoDefragmentInodes() {
    std::vector<Inode> compacted;
    compacted.reserve(inodeTable.size());

    // 1. نقل العقد المستخدمة فقط
    for (auto& inode : inodeTable) {
        if (inode.isUsed) {
            compacted.push_back(std::move(inode));
        }
    }

    // 2. حساب المساحة الجديدة المطلوبة
    size_t newSize = 0;
    for (const auto& inode : compacted) {
        newSize += inode.actualSize();
    }

    // 3. احتساب المساحة الإضافية (20% كهامش)
    size_t newTotalSize = newSize + newSize / 5;

    // 4. إذا كانت المساحة الجديدة أقل، نحرر الكتل الزائدة
    if (newTotalSize < inodeAreaSize) {
        size_t savedBlocks = (inodeAreaSize - newTotalSize) / disk.blockSize;
        if (savedBlocks > 0) {
            VirtualDisk::Extent extent(
                disk.getSystemBlocks() + superBlockBlocks + inodeBlocks - savedBlocks,
                savedBlocks
            );
            disk.freeBlocks(extent);
            inodeBlocks -= savedBlocks;
            inodeAreaSize = inodeBlocks * disk.blockSize;
        }
    }

    // 5. استبدال الجدول القديم بالجديد
    inodeTable = std::move(compacted);
    SaveInodeTable();
}

// إعادة بناء قائمة العقد الحرة
void MiniHSFS::RebuildFreeInodesList() {
    freeInodesList.clear();

    for (size_t i = 1; i < inodeTable.size(); ++i) {
        if (!inodeTable[i].isUsed) {
            freeInodesList.push_back(i);
        }
    }

    // تحديث مؤشر العقدة الحرة التالية
    nextFreeInode = freeInodesList.empty() ? inodeTable.size() : freeInodesList.front();
}

// حساب أقصى عدد ممكن من العقد
size_t MiniHSFS::CalculateMaxPossibleInodes() {
    size_t totalSpace = disk.totalBlocks() * disk.blockSize;
    size_t reservedSpace = superBlockBlocks * disk.blockSize +
        btreeBlocks * disk.blockSize +
        disk.getSystemBlocks() * disk.blockSize;
    size_t availableSpace = totalSpace - reservedSpace;

    // نخصص 20% من المساحة المتبقية للعقد
    return (availableSpace / 5) / inodeSize;
}

// تهيئة العقدة
int MiniHSFS::InitializeInode(int index, bool isDirectory) {
    inodeTable[index] = Inode(); // reset كامل

    inodeTable[index].isUsed = true;
    inodeTable[index].isDirectory = isDirectory;
    inodeTable[index].size = 0;
    inodeTable[index].blocksUsed = 0;
    inodeTable[index].firstBlock = -1;   // مهم جدًا
    inodeTable[index].entries.clear();

    time_t now = time(nullptr);
    inodeTable[index].creationTime = now;
    inodeTable[index].modificationTime = now;
    inodeTable[index].lastAccessed = now;
    inodeTable[index].isDirty = true;

    // لو عندك بت ماب للـ inodes
    if (inodeBitmap.size() == inodeTable.size())
        inodeBitmap[index] = true;

    return index;
}

// تمديد مساحة العقد
void MiniHSFS::ExtendInodeArea(size_t additionalInodes) {
    size_t oldSize = inodeTable.size();
    size_t newSize = oldSize + (additionalInodes > 0 ? additionalInodes :
        std::max<size_t>(32, oldSize / 2)); // زيادة ذكية

    if (newSize > maxPossibleInodes) {
        throw std::runtime_error("Inode limit reached");
    }

    // تخصيص مساحة على القرص أولاً
    size_t requiredBlocks = (newSize * inodeSize + disk.blockSize - 1) / disk.blockSize;
    if (requiredBlocks > inodeBlocks) {
        VirtualDisk::Extent extent(
            disk.getSystemBlocks() + superBlockBlocks + inodeBlocks,
            requiredBlocks - inodeBlocks
        );
        disk.allocateBlocks(extent.blockCount);

        // تهيئة الكتل الجديدة
        std::vector<char> zeroBlock(disk.blockSize, 0);
        for (size_t i = inodeBlocks; i < requiredBlocks; ++i) {
            disk.writeData(zeroBlock,
                VirtualDisk::Extent(
                    disk.getSystemBlocks() + superBlockBlocks + i,
                    1
                ),
                "",
                true
            );
        }
        inodeBlocks = requiredBlocks;
    }

    // توسيع الهياكل في الذاكرة
    inodeTable.resize(newSize);
    inodeBitmap.resize(newSize, false);

    // تحديث السوبربلوك
    UpdateSuperblockForDynamicInodes();
}

// تحديث السوبربلوك
void MiniHSFS::UpdateSuperblockForDynamicInodes() {
    SuperblockInfo info = LoadSuperblock();
    info.inodeSize = inodeSize;
    info.totalInodes = inodeCount;
    info.freeInodes = CountFreeInodes();
    info.lastWriteTime = time(nullptr);
    SaveSuperblock(info);
}

// عد العقد الحرة
size_t MiniHSFS::CountFreeInodes() {
    size_t count = 0;
    for (const auto& inode : inodeTable) {
        if (!inode.isUsed) {
            count++;
        }
    }
    return count;
    //return std::count(inodeBitmap.begin(), inodeBitmap.end(), false);
}

// ضغط جدول العقد
void MiniHSFS::CompactInodeTable() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    // 1. جمع العقد المستخدمة
    std::vector<Inode> usedInodes;
    std::vector<bool> usedBitmap;

    for (size_t i = 0; i < inodeTable.size(); ++i) {
        if (inodeBitmap[i]) {
            usedInodes.push_back(std::move(inodeTable[i]));
            usedBitmap.push_back(true);
        }
    }

    // 2. إعادة إنشاء الجدول مع هامش 25%
    size_t newSize = usedInodes.size() + (usedInodes.size() / 4);
    newSize = (std::max)(newSize, static_cast<size_t>(32)); // الحد الأدنى

    inodeTable.clear();
    inodeTable.resize(newSize);
    inodeBitmap.assign(newSize, false);

    // 3. إعادة تعبئة العقد المستخدمة
    for (size_t i = 0; i < usedInodes.size(); ++i) {
        inodeTable[i] = std::move(usedInodes[i]);
        inodeBitmap[i] = true;
    }

    // 4. تحديث مؤشر العقد الحرة
    nextFreeInode = usedInodes.empty() ? 0 : usedInodes.size();

    // 5. حفظ التغييرات
    SaveInodeTable();
    UpdateSuperblockForDynamicInodes();
}

// إلغاء تجزئة العقد
void MiniHSFS::DefragmentInodes() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    // 1. جمع جميع العقد المستخدمة
    std::vector<std::pair<int, Inode>> usedInodes;
    for (size_t i = 1; i < inodeTable.size(); ++i) {
        if (inodeTable[i].isUsed) {
            usedInodes.emplace_back(i, inodeTable[i]);
        }
    }

    // 2. إعادة إنشاء جدول العقد
    size_t newSize = (std::max)(inodeTable.size(), usedInodes.size() + 32); // هامش 32 عقدة
    std::vector<Inode> newTable(newSize);
    std::vector<bool> newBitmap(newSize, false);

    // 3. نسخ العقدة الجذرية
    newTable[0] = inodeTable[0];
    newBitmap[0] = true;

    // 4. إعادة تعبئة العقد المستخدمة
    for (size_t newIndex = 1; newIndex <= usedInodes.size(); ++newIndex) {
        newTable[newIndex] = usedInodes[newIndex - 1].second;
        newBitmap[newIndex] = true;

        // تحديث الإشارات في المجلدات
        if (newTable[newIndex].isDirectory) {
            for (auto& entry : newTable[newIndex].entries) {
                // لا نحتاج لتحديث القيم لأننا نعيد تعبئة كل العقد
            }
        }
    }

    // 5. استبدال الجداول القديمة بالجديدة
    inodeTable = std::move(newTable);
    inodeBitmap = std::move(newBitmap);
    inodeCount = inodeTable.size();

    // 6. إعادة بناء قائمة العقد الحرة
    RebuildFreeInodesList();

    // 7. حفظ التغييرات
    SaveInodeTable();
    UpdateSuperblockForDynamicInodes();
}

// الحصول على عدد العقد الحرة
size_t MiniHSFS::GetAvailableInodes() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    return freeInodesList.size() + (maxPossibleInodes - inodeCount);
}

// التحقق من إمكانية إنشاء المزيد من العقد
bool MiniHSFS::CanCreateMoreInodes() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    return !freeInodesList.empty() || (dynamicInodes && inodeCount < maxPossibleInodes);
}

// التحقق من وجود مساحة كافية
bool MiniHSFS::CanAllocateInodes(size_t count) {
    size_t freeSpace = disk.freeBlocksCount() * disk.blockSize;
    size_t requiredSpace = count * inodeSize;
    return freeSpace >= requiredSpace;
}

// إعادة بناء خريطة العقد
void MiniHSFS::RebuildInodeBitmap() {
    inodeBitmap.clear();
    inodeBitmap.resize(inodeTable.size());
    for (size_t i = 0; i < inodeTable.size(); ++i) {
        inodeBitmap[i] = inodeTable[i].isUsed;
    }
    nextFreeInode = 0;
}

//void MiniHSFS::LoadInodeTable() {
//    std::lock_guard<std::recursive_mutex> lock(fsMutex);
//
//    InitializeInodeTable(); // تجهّز الحجم/العدادات الأساسية
//
//    std::vector<char> inode_data(inodeBlocks * disk.blockSize, 0);
//
//    // اقرأ كل كتل جدول الـinodes
//    for (size_t block = 0; block < inodeBlocks; ++block) {
//        auto data = disk.readData(
//            VirtualDisk::Extent(disk.getSystemBlocks() + static_cast<uint32_t>(superBlockBlocks) + static_cast<uint32_t>(block), 1)
//        );
//        std::copy(data.begin(), data.end(), inode_data.begin() + block * disk.blockSize);
//    }
//
//    // فكّ كل inode من موضعه الثابت
//    size_t maxInodesByArea = (inodeBlocks * disk.blockSize) / inodeSize;
//    size_t toLoad = (std::min)(inodeTable.size(), maxInodesByArea);
//
//    for (size_t i = 0; i < toLoad; ++i) {
//        size_t off = i * inodeSize;
//        if (off + inodeSize > inode_data.size())
//            throw std::runtime_error("LoadInodeTable: truncated inode area");
//
//        DeserializeInode(inodeTable[i], inode_data.data() + off, inodeSize);
//    }
//
//    // تأكيد صلاحية الجذر
//    if (!inodeTable[0].isUsed || !inodeTable[0].isDirectory) {
//        throw std::runtime_error("Root inode is missing or corrupted");
//    }
//
//    // أعد بناء bitmap / قائمة الحرة بعد التحميل
//    RebuildInodeBitmap();  // إن كانت مستخدمة
//    RebuildFreeInodesList();
//}
//
//void MiniHSFS::SaveInodeTable() {
//    std::lock_guard<std::recursive_mutex> lock(fsMutex);
//
//    // مساحة جدول الـinodes بالكامل
//    std::vector<char> inode_data(inodeBlocks * disk.blockSize, 0);
//
//    // كل inode عند offset ثابت i * inodeSize
//    for (size_t i = 0; i < inodeTable.size(); ++i) {
//        size_t off = i * inodeSize;
//        if (off + inodeSize > inode_data.size())
//            throw std::runtime_error("SaveInodeTable: inode area too small");
//        if (SerializeInode(inodeTable[i], inode_data.data() + off, inodeSize) == 0)
//            throw std::runtime_error("SaveInodeTable: serialize failed");
//    }
//
//    // اكتب الكتل فعليًا
//    for (size_t block = 0; block < inodeBlocks; ++block) {
//        std::vector<char> block_data(
//            inode_data.begin() + block * disk.blockSize,
//            inode_data.begin() + (block + 1) * disk.blockSize
//        );
//        disk.writeData(
//            block_data,
//            VirtualDisk::Extent(disk.getSystemBlocks() + static_cast<uint32_t>(superBlockBlocks) + static_cast<uint32_t>(block), 1),
//            "",
//            true
//        );
//    }
//}
//
//size_t MiniHSFS::SerializeInode(const Inode& inode, char* buffer, size_t bufferSize) {
//
//    if (bufferSize < inodeSize) return 0;            // يجب أن يساوي inodeSize
//    std::memset(buffer, 0, bufferSize);              // صفّر المساحة كلها
//
//    size_t offset = 0;
//    auto put = [&](const void* src, size_t sz) {
//        if (offset + sz > bufferSize) throw std::runtime_error("SerializeInode: overflow");
//        std::memcpy(buffer + offset, src, sz);
//        offset += sz;
//        };
//
//    // رأس ثابت
//    put(&inode.size, sizeof(inode.size));
//    put(&inode.blocksUsed, sizeof(inode.blocksUsed));
//    put(&inode.firstBlock, sizeof(inode.firstBlock));
//    put(&inode.isDirectory, sizeof(inode.isDirectory));
//    put(&inode.isUsed, sizeof(inode.isUsed));
//    put(&inode.creationTime, sizeof(inode.creationTime));
//    put(&inode.modificationTime, sizeof(inode.modificationTime));
//    put(&inode.lastAccessed, sizeof(inode.lastAccessed));
//    put(&inode.isDirty, sizeof(inode.isDirty));
//
//    // عدد الإدخالات (سنحسب كم فعليًا كتبنا)
//    // نكتب عدد فعلي لاحقًا بعد الحجز، لذلك نحتفظ بمكانه:
//    uint32_t entryCount = 0;
//    size_t entryCountPos = offset;
//    uint32_t zero = 0;
//    put(&zero, sizeof(zero)); // placeholder
//
//    // مساحة باقية لإدخالات الدليل
//    if (inode.isDirectory) {
//        for (const auto& kv : inode.entries) {
//            const std::string& name = kv.first;
//            int inodeNum = kv.second;
//            uint16_t len = static_cast<uint16_t>(name.size());
//
//            // كل إدخال: len(2) + name + inodeNum(4)
//            size_t need = sizeof(len) + len + sizeof(inodeNum);
//            if (offset + need > bufferSize) break; // لا مساحة إضافية
//
//            put(&len, sizeof(len));
//            if (len) { put(name.data(), len); }
//            put(&inodeNum, sizeof(inodeNum));
//            entryCount++;
//        }
//        // اكتب entryCount في مكانه
//        std::memcpy(buffer + entryCountPos, &entryCount, sizeof(entryCount));
//    }
//
//    // نضمن أننا لم نتخطَّ bufferSize
//    return inodeSize;
//}
//
//size_t MiniHSFS::DeserializeInode(Inode& inode, const char* buffer, size_t bufferSize) {
//
//    if (bufferSize < inodeSize) return 0;
//
//    size_t offset = 0;
//    auto get = [&](void* dst, size_t sz) {
//        if (offset + sz > bufferSize) throw std::runtime_error("DeserializeInode: underflow");
//        std::memcpy(dst, buffer + offset, sz);
//        offset += sz;
//        };
//
//    // الرأس الثابت
//    get(&inode.size, sizeof(inode.size));
//    get(&inode.blocksUsed, sizeof(inode.blocksUsed));
//    get(&inode.firstBlock, sizeof(inode.firstBlock));
//    get(&inode.isDirectory, sizeof(inode.isDirectory));
//    get(&inode.isUsed, sizeof(inode.isUsed));
//    get(&inode.creationTime, sizeof(inode.creationTime));
//    get(&inode.modificationTime, sizeof(inode.modificationTime));
//    get(&inode.lastAccessed, sizeof(inode.lastAccessed));
//    get(&inode.isDirty, sizeof(inode.isDirty));
//
//    uint32_t entryCount = 0;
//    get(&entryCount, sizeof(entryCount));
//
//    inode.entries.clear();
//
//    if (inode.isDirectory) {
//        for (uint32_t i = 0; i < entryCount; ++i) {
//            if (offset + sizeof(uint16_t) > bufferSize) break;
//            uint16_t len = 0;
//            get(&len, sizeof(len));
//
//            if (offset + len + sizeof(int) > bufferSize) break;
//            std::string name(len, '\0');
//            if (len) {
//                std::memcpy(&name[0], buffer + offset, len);
//                offset += len;
//            }
//            int inodeNum = -1;
//            get(&inodeNum, sizeof(inodeNum));
//
//            inode.entries[std::move(name)] = inodeNum;
//        }
//    }
//
//    // تجاهل أي padding متبقّي… القراءة ثابتة
//    return inodeSize;
//}

//void MiniHSFS::LoadInodeTable() {
//    std::lock_guard<std::recursive_mutex> lock(fsMutex);
//
//    // احصل على عدد inodes الممكن تخزينها في المساحة الحالية (حسب inodeBlocks)
//    size_t maxInodesByArea = (inodeBlocks * disk.blockSize) / inodeSize;
//    if (maxInodesByArea == 0) throw std::runtime_error("Inode area size is zero");
//
//    // اضبط حجم جدول الـ inodes في الذاكرة ليتطابق مع المساحة الفعلية على القرص
//    inodeTable.clear();
//    inodeTable.resize(maxInodesByArea);
//    inodeBitmap.clear();
//    inodeBitmap.resize(maxInodesByArea, false);
//
//    // اقرأ كل كتل جدول الـinodes إلى buffer واحد كبير
//    std::vector<char> inode_data(inodeBlocks * disk.blockSize, 0);
//    for (size_t block = 0; block < inodeBlocks; ++block) {
//        // حساب بلوك النظام + سوبر بلوك + offset لجدول الـ inodes
//        uint32_t absBlock = static_cast<uint32_t>(disk.getSystemBlocks() + static_cast<uint32_t>(superBlockBlocks) + static_cast<uint32_t>(block));
//        auto data = disk.readData(VirtualDisk::Extent(absBlock, 1));
//        if (data.size() != disk.blockSize) {
//            // إذا كانت الدالة تعيد أحجام مختلفة، نتعامل بهدوء ولكن نملأ ما استرددناه
//            std::copy(data.begin(), data.end(), inode_data.begin() + block * disk.blockSize);
//        }
//        else {
//            std::copy(data.begin(), data.end(), inode_data.begin() + block * disk.blockSize);
//        }
//    }
//
//    // فكّ كل inode من موضعه الثابت
//    size_t toLoad = maxInodesByArea;
//    for (size_t i = 0; i < toLoad; ++i) {
//        size_t off = i * inodeSize;
//        if (off + inodeSize > inode_data.size()) {
//            throw std::runtime_error("LoadInodeTable: truncated inode area");
//        }
//        DeserializeInode(inodeTable[i], inode_data.data() + off, inodeSize);
//    }
//
//    // تحقق من وجود الجذر وصحته
//    if (inodeTable.size() == 0 || !inodeTable[0].isUsed || !inodeTable[0].isDirectory) {
//        throw std::runtime_error("Root inode is missing or corrupted");
//    }
//
//    // أعِد بناء البت ماب وقائمة الـ free inodes في الذاكرة
//    RebuildInodeBitmap();
//    RebuildFreeInodesList();
//}

//void MiniHSFS::SaveInodeTable() {
//    std::lock_guard<std::recursive_mutex> lock(fsMutex);
//
//    // تأكد أن المساحة التي سنكتب إليها مساوية لعدد بلوكات الـ inode
//    size_t areaBytes = inodeBlocks * disk.blockSize;
//    if (areaBytes == 0) throw std::runtime_error("SaveInodeTable: inode area is zero");
//
//    // اضبط buffer ليحتوي كامل منطقة جدول الـ inodes
//    std::vector<char> inode_data(areaBytes, 0);
//
//    // اكتب كل inode عند الإزاحة الثابتة i * inodeSize
//    size_t maxInodesByArea = areaBytes / inodeSize;
//    if (inodeTable.size() > maxInodesByArea) {
//        // إذا الذاكرة تحتوي على أكثر من ما تسمح به المساحة، نرفع استثناء
//        throw std::runtime_error("SaveInodeTable: inodeTable larger than allocated inode area");
//    }
//
//    for (size_t i = 0; i < inodeTable.size(); ++i) {
//        size_t off = i * inodeSize;
//        if (off + inodeSize > inode_data.size())
//            throw std::runtime_error("SaveInodeTable: inode area too small");
//
//        if (SerializeInode(inodeTable[i], inode_data.data() + off, inodeSize) == 0)
//            throw std::runtime_error("SaveInodeTable: serialize failed for inode " + std::to_string(i));
//    }
//
//    // اكتب الكتل فعليًا بلوك بلوك
//    for (size_t block = 0; block < inodeBlocks; ++block) {
//        size_t startOff = block * disk.blockSize;
//        std::vector<char> block_data(inode_data.begin() + startOff, inode_data.begin() + startOff + disk.blockSize);
//
//        uint32_t absBlock = static_cast<uint32_t>(disk.getSystemBlocks() + static_cast<uint32_t>(superBlockBlocks) + static_cast<uint32_t>(block));
//        disk.writeData(block_data, VirtualDisk::Extent(absBlock, 1), "", true);
//    }
//}

//void MiniHSFS::LoadInodeTable() {
//    std::lock_guard<std::recursive_mutex> lock(fsMutex);
//
//    // 1. احسب الحد الأدنى للعقد المطلوبة (يمكن تغيير 50 لأي قيمة تريدها)
//    const size_t minRequiredInodes = 35;
//
//    // 2. احسب عدد البلوكات المطلوبة بناءً على minRequiredInodes
//    size_t requiredBlocks = (minRequiredInodes * inodeSize + disk.blockSize - 1) / disk.blockSize;
//
//    // 3. إذا كانت البلوكات الحالية غير كافية، قم بتوسيعها
//    if (requiredBlocks > inodeBlocks) {
//        size_t additionalBlocks = requiredBlocks - inodeBlocks;
//        VirtualDisk::Extent extent(disk.getSystemBlocks() + superBlockBlocks + inodeBlocks, additionalBlocks);
//
//        // احجز البلوكات الإضافية
//        disk.allocateBlocks(extent.blockCount);
//
//        // اكتب صفر في البلوكات الجديدة
//        std::vector<char> zeroBlock(disk.blockSize, 0);
//        for (size_t i = 0; i < additionalBlocks; ++i) {
//            disk.writeData(zeroBlock,
//                VirtualDisk::Extent(extent.startBlock + i, 1),
//                "",
//                true);
//        }
//
//        inodeBlocks = requiredBlocks;
//    }
//
//    // 4. احسب العدد الفعلي للعقد التي يمكن قراءتها
//    size_t maxInodes = (inodeBlocks * disk.blockSize) / inodeSize;
//
//    // 5. تهيئة الجدول في الذاكرة بالحجم المطلوب (50 أو أكثر)
//    inodeTable.clear();
//    inodeTable.resize((std::max)(maxInodes, minRequiredInodes));
//    inodeBitmap.resize(inodeTable.size(), false);
//
//    // 6. قراءة البيانات من القرص
//    std::vector<char> inode_data(inodeBlocks * disk.blockSize);
//    for (size_t block = 0; block < inodeBlocks; ++block) {
//        auto data = disk.readData(
//            VirtualDisk::Extent(
//                disk.getSystemBlocks() + superBlockBlocks + block,
//                1
//            )
//        );
//        std::copy(data.begin(), data.end(),
//            inode_data.begin() + block * disk.blockSize);
//    }
//
//    // 7. تحميل كل العقد المتاحة
//    for (size_t i = 0; i < maxInodes; ++i) {
//        size_t offset = i * inodeSize;
//        DeserializeInode(inodeTable[i], inode_data.data() + offset, inodeSize);
//    }
//
//    // 8. التحقق من العقدة الجذرية
//    if (!inodeTable[0].isUsed || !inodeTable[0].isDirectory) {
//        throw std::runtime_error("Root inode is corrupted");
//    }
//
//    // 9. تحديث الهياكل المساعدة
//    RebuildInodeBitmap();
//    RebuildFreeInodesList();
//
//    // 10. تحديث السوبر بلوك ليعكس التغييرات
//    UpdateSuperblockForDynamicInodes();
//}
//
//void MiniHSFS::SaveInodeTable() {
//    std::lock_guard<std::recursive_mutex> lock(fsMutex);
//
//    // 1. احسب عدد البلوكات المطلوبة بناءً على العقد الحالية
//    size_t requiredBlocks = (inodeTable.size() * inodeSize + disk.blockSize - 1) / disk.blockSize;
//
//    // 2. إذا كانت البلوكات الحالية غير كافية، قم بتوسيعها
//    if (requiredBlocks > inodeBlocks) {
//        size_t additionalBlocks = requiredBlocks - inodeBlocks;
//        VirtualDisk::Extent extent(disk.getSystemBlocks() + superBlockBlocks + inodeBlocks, additionalBlocks);
//
//        // احجز البلوكات الإضافية
//        disk.allocateBlocks(extent.blockCount);
//
//        // اكتب صفر في البلوكات الجديدة
//        std::vector<char> zeroBlock(disk.blockSize, 0);
//        for (size_t i = 0; i < additionalBlocks; ++i) {
//            disk.writeData(zeroBlock,
//                VirtualDisk::Extent(extent.startBlock + i, 1),
//                "",
//                true);
//        }
//
//        inodeBlocks = requiredBlocks;
//    }
//
//    // 3. احفظ جميع العقد (حتى غير المستخدمة)
//    std::vector<char> inode_data(inodeBlocks * disk.blockSize, 0);
//    for (size_t i = 0; i < inodeTable.size(); ++i) {
//        size_t offset = i * inodeSize;
//        SerializeInode(inodeTable[i], inode_data.data() + offset, inodeSize);
//    }
//
//    // 4. اكتب البيانات إلى القرص
//    for (size_t block = 0; block < inodeBlocks; ++block) {
//        std::vector<char> block_data(
//            inode_data.begin() + block * disk.blockSize,
//            inode_data.begin() + (block + 1) * disk.blockSize
//        );
//        disk.writeData(block_data,
//            VirtualDisk::Extent(disk.getSystemBlocks() + superBlockBlocks + block, 1),
//            "",
//            true
//        );
//    }
//
//    // 5. تحديث السوبر بلوك
//    UpdateSuperblockForDynamicInodes();
//}
//
//// يعبّي buffer (الذي طوله = inodeSize) بمحتوى الـ inode بصيغة ثابتة
//size_t MiniHSFS::SerializeInode(const Inode& inode, char* buffer, size_t bufferSize) {
//    if (bufferSize < inodeSize) return 0;
//    std::memset(buffer, 0, bufferSize);
//
//    size_t offset = 0;
//    auto put = [&](const void* src, size_t sz) {
//        if (offset + sz > bufferSize) throw std::runtime_error("SerializeInode: overflow");
//        std::memcpy(buffer + offset, src, sz);
//        offset += sz;
//        };
//
//    // رأس ثابت
//    put(&inode.size, sizeof(inode.size));
//    put(&inode.blocksUsed, sizeof(inode.blocksUsed));
//    put(&inode.firstBlock, sizeof(inode.firstBlock));
//    put(&inode.isDirectory, sizeof(inode.isDirectory));
//    put(&inode.isUsed, sizeof(inode.isUsed));
//    put(&inode.creationTime, sizeof(inode.creationTime));
//    put(&inode.modificationTime, sizeof(inode.modificationTime));
//    put(&inode.lastAccessed, sizeof(inode.lastAccessed));
//    put(&inode.isDirty, sizeof(inode.isDirty));
//
//    // احجز مكانًا لعدد الإدخالات (entryCount) ثم املأ الإدخالات إن كان الدليل
//    uint32_t entryCount = 0;
//    size_t entryCountPos = offset;
//    uint32_t zero = 0;
//    put(&zero, sizeof(zero)); // placeholder
//
//    if (inode.isDirectory) {
//        for (const auto& kv : inode.entries) {
//            const std::string& name = kv.first;
//            int inodeNum = kv.second;
//            uint16_t len = static_cast<uint16_t>(name.size());
//
//            // كل إدخال: len(2) + name + inodeNum(4)
//            size_t need = sizeof(len) + len + sizeof(inodeNum);
//            if (offset + need > bufferSize) break; // لا مساحة إضافية
//
//            put(&len, sizeof(len));
//            if (len) { put(name.data(), len); }
//            put(&inodeNum, sizeof(inodeNum));
//            entryCount++;
//        }
//        // اكتب عدد الإدخالات في المكان المحجوز
//        std::memcpy(buffer + entryCountPos, &entryCount, sizeof(entryCount));
//    }
//
//    // نُعيد طول السجل (ثابت = inodeSize)
//    return inodeSize;
//}
//
//// يفك من buffer إلى هيكل inode
//size_t MiniHSFS::DeserializeInode(Inode& inode, const char* buffer, size_t bufferSize) {
//    if (bufferSize < inodeSize) return 0;
//
//    size_t offset = 0;
//    auto get = [&](void* dst, size_t sz) {
//        if (offset + sz > bufferSize) throw std::runtime_error("DeserializeInode: underflow");
//        std::memcpy(dst, buffer + offset, sz);
//        offset += sz;
//        };
//
//    // الرأس الثابت
//    get(&inode.size, sizeof(inode.size));
//    get(&inode.blocksUsed, sizeof(inode.blocksUsed));
//    get(&inode.firstBlock, sizeof(inode.firstBlock));
//    get(&inode.isDirectory, sizeof(inode.isDirectory));
//    get(&inode.isUsed, sizeof(inode.isUsed));
//    get(&inode.creationTime, sizeof(inode.creationTime));
//    get(&inode.modificationTime, sizeof(inode.modificationTime));
//    get(&inode.lastAccessed, sizeof(inode.lastAccessed));
//    get(&inode.isDirty, sizeof(inode.isDirty));
//
//    uint32_t entryCount = 0;
//    get(&entryCount, sizeof(entryCount));
//
//    inode.entries.clear();
//
//    if (inode.isDirectory) {
//        for (uint32_t i = 0; i < entryCount; ++i) {
//            if (offset + sizeof(uint16_t) > bufferSize) break;
//            uint16_t len = 0;
//            get(&len, sizeof(len));
//
//            if (offset + len + sizeof(int) > bufferSize) break;
//            std::string name(len, '\0');
//            if (len) {
//                std::memcpy(&name[0], buffer + offset, len);
//                offset += len;
//            }
//            int inodeNum = -1;
//            get(&inodeNum, sizeof(inodeNum));
//
//            inode.entries[std::move(name)] = inodeNum;
//        }
//    }
//
//    return inodeSize;
//}

void MiniHSFS::LoadInodeTable() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    // حساب عدد العقد المتاحة
    size_t maxPossibleInodes = 34;//(inodeBlocks * disk.blockSize) / inodeSize;

    // تهيئة الجدول
    inodeTable.clear();
    inodeTable.resize(maxPossibleInodes);
    inodeBitmap.resize(maxPossibleInodes, false);

    // قراءة البيانات
    std::vector<char> inode_data(inodeBlocks * disk.blockSize);
    for (size_t block = 0; block < inodeBlocks; ++block) {
        auto data = disk.readData(
            VirtualDisk::Extent(
                disk.getSystemBlocks() + superBlockBlocks + block,
                1
            )
        );
        std::copy(data.begin(), data.end(),
            inode_data.begin() + block * disk.blockSize);
    }

    // تحميل العقد
    for (size_t i = 0; i < maxPossibleInodes; ++i) {
        size_t offset = i * inodeSize;
        DeserializeInode(inodeTable[i], inode_data.data() + offset, inodeSize);
    }

    // التحقق من الجذر
    if (!inodeTable[0].isUsed || !inodeTable[0].isDirectory) {
        throw std::runtime_error("Root inode corrupted");
    }

    // تحديث الهياكل المساعدة
    RebuildInodeBitmap();
    RebuildFreeInodesList();
}

void MiniHSFS::SaveInodeTable() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    // احتساب المساحة المطلوبة
    size_t requiredSpace = inodeTable.size() * inodeSize;
    size_t availableSpace = inodeBlocks * disk.blockSize;

    // توسيع المساحة إذا لزم الأمر
    if (requiredSpace > availableSpace) {
        size_t additionalBlocks = (requiredSpace - availableSpace + disk.blockSize - 1) / disk.blockSize;
        VirtualDisk::Extent extent(disk.getSystemBlocks() + superBlockBlocks + inodeBlocks, additionalBlocks);

        disk.allocateBlocks(extent.blockCount);

        // تهيئة البلوكات الجديدة
        std::vector<char> zeroBlock(disk.blockSize, 0);
        for (size_t i = 0; i < additionalBlocks; ++i) {
            disk.writeData(zeroBlock,
                VirtualDisk::Extent(extent.startBlock + i, 1),
                "",
                true);
        }

        inodeBlocks += additionalBlocks;
    }

    // تسجيل جميع العقد
    std::vector<char> inode_data(inodeBlocks * disk.blockSize, 0);
    for (size_t i = 0; i < inodeTable.size(); ++i) {
        size_t offset = i * inodeSize;
        SerializeInode(inodeTable[i], inode_data.data() + offset, inodeSize);
    }

    // الكتابة إلى القرص
    for (size_t block = 0; block < inodeBlocks; ++block) {
        size_t start = block * disk.blockSize;
        size_t end = (block + 1) * disk.blockSize;
        end = (std::min)(end, inode_data.size());

        std::vector<char> block_data(inode_data.begin() + start, inode_data.begin() + end);
        disk.writeData(block_data,
            VirtualDisk::Extent(disk.getSystemBlocks() + superBlockBlocks + block, 1),
            "",
            true);
    }
}

size_t MiniHSFS::SerializeInode(const Inode& inode, char* buffer, size_t bufferSize) {
    if (bufferSize < inodeSize) return 0;

    size_t offset = 0;
    auto write = [&](const void* data, size_t size) {
        if (offset + size > bufferSize) return false;
        memcpy(buffer + offset, data, size);
        offset += size;
        return true;
        };

    // كتابة البيانات الأساسية
    if (!write(&inode.size, sizeof(inode.size))) return 0;
    if (!write(&inode.blocksUsed, sizeof(inode.blocksUsed))) return 0;
    if (!write(&inode.firstBlock, sizeof(inode.firstBlock))) return 0;

    // كتابة نوع العقدة (هام جداً)
    bool isDir = inode.isDirectory;
    if (!write(&isDir, sizeof(isDir))) return 0;

    if (!write(&inode.isUsed, sizeof(inode.isUsed))) return 0;
    if (!write(&inode.creationTime, sizeof(inode.creationTime))) return 0;
    if (!write(&inode.modificationTime, sizeof(inode.modificationTime))) return 0;
    if (!write(&inode.lastAccessed, sizeof(inode.lastAccessed))) return 0;

    // إذا كانت مجلد، حفظ المحتويات
    if (inode.isDirectory) {
        uint32_t entryCount = inode.entries.size();
        if (!write(&entryCount, sizeof(entryCount))) return 0;

        for (const auto& entry : inode.entries) {
            uint16_t nameLen = entry.first.size();
            if (!write(&nameLen, sizeof(nameLen))) return 0;
            if (!write(entry.first.c_str(), nameLen)) return 0;
            if (!write(&entry.second, sizeof(entry.second))) return 0;
        }
    }

    return inodeSize;
}

size_t MiniHSFS::DeserializeInode(Inode& inode, const char* buffer, size_t bufferSize) {
    if (bufferSize < inodeSize) return 0;

    size_t offset = 0;
    auto read = [&](void* dest, size_t size) {
        if (offset + size > bufferSize) return false;
        memcpy(dest, buffer + offset, size);
        offset += size;
        return true;
        };

    // قراءة البيانات الأساسية
    if (!read(&inode.size, sizeof(inode.size))) return 0;
    if (!read(&inode.blocksUsed, sizeof(inode.blocksUsed))) return 0;
    if (!read(&inode.firstBlock, sizeof(inode.firstBlock))) return 0;

    // قراءة نوع العقدة
    bool isDir;
    if (!read(&isDir, sizeof(isDir))) return 0;
    inode.isDirectory = isDir;

    if (!read(&inode.isUsed, sizeof(inode.isUsed))) return 0;
    if (!read(&inode.creationTime, sizeof(inode.creationTime))) return 0;
    if (!read(&inode.modificationTime, sizeof(inode.modificationTime))) return 0;
    if (!read(&inode.lastAccessed, sizeof(inode.lastAccessed))) return 0;

    // إذا كانت مجلد، تحميل المحتويات
    inode.entries.clear();
    if (inode.isDirectory) {
        uint32_t entryCount;
        if (!read(&entryCount, sizeof(entryCount))) return 0;

        for (uint32_t i = 0; i < entryCount; i++) {
            uint16_t nameLen;
            if (!read(&nameLen, sizeof(nameLen))) return 0;

            std::string name;
            name.resize(nameLen);
            if (!read(&name[0], nameLen)) return 0;

            int inodeNum;
            if (!read(&inodeNum, sizeof(inodeNum))) return 0;

            inode.entries[name] = inodeNum;
        }
    }

    return inodeSize;
}

void MiniHSFS::SaveInodeToDisk(int inodeIndex) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    // تحقق أساسي للـ index
    if (inodeIndex < 0 || static_cast<size_t>(inodeIndex) >= inodeTable.size()) {
        throw std::out_of_range("SaveInodeToDisk: invalid inode index " + std::to_string(inodeIndex));
    }

    // احصل على تمثيل الـ inode في بافر
    std::vector<char> buf(inodeSize, 0);
    if (SerializeInode(inodeTable[inodeIndex], buf.data(), inodeSize) == 0) {
        throw std::runtime_error("SaveInodeToDisk: serialize failed for inode " + std::to_string(inodeIndex));
    }

    // absolute byte offset داخل منطقة الـ inodes (ابتداءً من بداية منطقة الـ inodes على القرص)
    size_t absByte = static_cast<size_t>(inodeIndex) * inodeSize;

    // بلوك البداية و الإزاحة داخل البلوك
    size_t startBlock = absByte / disk.blockSize;
    size_t offsetInBlock = absByte % disk.blockSize;

    // عدد البلوكات المطلوبة لحفظ هذا الـ inode (قد يتجاوز بلوك واحد)
    size_t bytesToWrite = offsetInBlock + inodeSize;
    size_t blocksNeeded = (bytesToWrite + disk.blockSize - 1) / disk.blockSize;

    // تأكد أن هذه البلوكات ضمن منطقة جدول الـ inodes المخصّصة
    if (startBlock + blocksNeeded > static_cast<size_t>(inodeBlocks)) {
        throw std::runtime_error("SaveInodeToDisk: inode would overflow inode area (startBlock="
            + std::to_string(startBlock) + ", blocksNeeded=" + std::to_string(blocksNeeded)
            + ", inodeBlocks=" + std::to_string(inodeBlocks) + ")");
    }

    // نكتب بلوك بلوك، كل بلوك نقرؤه كاملاً (أو نملأه صفراً إذا لم ترجع readData الحجم الكامل)
    size_t remaining = inodeSize;
    size_t srcOffset = 0;

    for (size_t k = 0; k < blocksNeeded; ++k) {
        uint32_t relBlock = static_cast<uint32_t>(startBlock + k);
        uint32_t absBlock = static_cast<uint32_t>(disk.getSystemBlocks() + static_cast<uint32_t>(superBlockBlocks) + relBlock);

        // تحقق من أن absBlock ضمن قرصنا
        if (absBlock >= disk.totalBlocks()) {
            throw std::runtime_error("SaveInodeToDisk: absBlock out of range: " + std::to_string(absBlock));
        }

        // اقرأ البلوك الحالي من القرص
        auto blockDataVec = disk.readData(VirtualDisk::Extent(absBlock, 1));
        // إذا readData أعاد حجم مختلف، ضعه داخل buffer بحجم disk.blockSize
        std::vector<char> blockBuf(disk.blockSize, 0);
        if (!blockDataVec.empty()) {
            size_t copySz = (std::min)(blockDataVec.size(), blockBuf.size());
            std::memcpy(blockBuf.data(), blockDataVec.data(), copySz);
        }

        // حساب موقع النسخ داخل هذا البلوك
        size_t destOffset = (k == 0) ? offsetInBlock : 0;
        size_t canCopy = (std::min)(disk.blockSize - destOffset, remaining);

        // safety check
        if (destOffset + canCopy > blockBuf.size()) {
            throw std::runtime_error("SaveInodeToDisk: block buffer overflow calculation");
        }

        // انقل الجزء من buf إلى blockBuf
        std::memcpy(blockBuf.data() + destOffset, buf.data() + srcOffset, canCopy);

        // كتابة البلوك المعدّل إلى القرص
        disk.writeData(blockBuf, VirtualDisk::Extent(absBlock, 1), "", true);

        // تقدّم المؤشرات
        remaining -= canCopy;
        srcOffset += canCopy;
    }

    if (remaining != 0) {
        // يجب ألا يبقى شيء للكتابة
        throw std::runtime_error("SaveInodeToDisk: incomplete write, remaining bytes = " + std::to_string(remaining));
    }

    // علم أنّ الـ inode أصبح غير متسخّ (تمت كتابته)
    inodeTable[inodeIndex].isDirty = false;
}

// تحرير بلوك واحد
void MiniHSFS::FreeBlock(uint32_t blockIndex) {
    std::vector<char> zero(disk.blockSize, 0);
    disk.writeData(zero, VirtualDisk::Extent(blockIndex, 1), "", true);
    try {
        BTreeInsert(rootNodeIndex, static_cast<int>(blockIndex), 0);
    }
    catch (...) {}
    if (freeBlocks < disk.totalBlocks()) ++freeBlocks;
}

// حجز منطقة متجاورة من البلوكات
bool MiniHSFS::AllocateContiguousRegion(uint32_t start, size_t count) {
    if (start + count > disk.totalBlocks()) return false;

    for (size_t i = 0; i < count; ++i) {
        auto cur = static_cast<uint32_t>(start + i);
        auto data = disk.readData(VirtualDisk::Extent(cur, 1));
        bool allZero = std::all_of(data.begin(), data.end(), [](char c) { return c == 0; });
        if (!allZero) return false;
    }

    for (size_t i = 0; i < count; ++i) {
        uint32_t cur = static_cast<uint32_t>(start + i);
        std::vector<char> zero(disk.blockSize, 0);
        disk.writeData(zero, VirtualDisk::Extent(cur, 1), "", true);
        try { BTreeInsert(rootNodeIndex, static_cast<int>(cur), 1); }
        catch (...) {}
    }

    if (freeBlocks >= count) freeBlocks -= count;
    else freeBlocks = 0;
    return true;
}

std::vector<std::tuple<int, uint32_t, uint32_t>> MiniHSFS::CollectFileExtents() {
    std::vector<std::tuple<int, uint32_t, uint32_t>> out;
    for (size_t i = 1; i < inodeTable.size(); ++i) {
        if (inodeTable[i].isUsed && !inodeTable[i].isDirectory && inodeTable[i].blocksUsed > 0) {
            out.emplace_back(static_cast<int>(i),
                static_cast<uint32_t>(inodeTable[i].firstBlock),
                static_cast<uint32_t>(inodeTable[i].blocksUsed));
        }
    }
    std::sort(out.begin(), out.end(), [](auto& a, auto& b) {
        return std::get<1>(a) < std::get<1>(b);
        });
    return out;
}

void MiniHSFS::MoveInodeExtent(int inodeIndex, uint32_t srcStart, uint32_t dstStart, uint32_t count) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    if (dstStart > srcStart) {
        for (int k = static_cast<int>(count) - 1; k >= 0; --k) {
            uint32_t s = srcStart + k;
            uint32_t d = dstStart + k;
            auto data = disk.readData(VirtualDisk::Extent(s, 1));
            disk.writeData(data, VirtualDisk::Extent(d, 1), "", true);
            try { BTreeInsert(rootNodeIndex, static_cast<int>(d), 1); }
            catch (...) {}
        }
    }
    else {
        for (uint32_t k = 0; k < count; ++k) {
            uint32_t s = srcStart + k;
            uint32_t d = dstStart + k;
            auto data = disk.readData(VirtualDisk::Extent(s, 1));
            disk.writeData(data, VirtualDisk::Extent(d, 1), "", true);
            try { BTreeInsert(rootNodeIndex, static_cast<int>(d), 1); }
            catch (...) {}
        }
    }

    for (uint32_t k = 0; k < count; ++k) {
        uint32_t s = srcStart + k;
        try { BTreeInsert(rootNodeIndex, static_cast<int>(s), 0); }
        catch (...) {}
        std::vector<char> zero(disk.blockSize, 0);
        disk.writeData(zero, VirtualDisk::Extent(s, 1), "", true);
    }

    inodeTable[inodeIndex].firstBlock = static_cast<int>(dstStart);
    inodeTable[inodeIndex].isDirty = true;
    SaveInodeToDisk(inodeIndex);
}

bool MiniHSFS::DefragmentDataAreaToFreePrefix(size_t neededBlocks) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    if (neededBlocks == 0) return true;

    uint32_t dataStart = dataStartIndex;
    uint32_t total = static_cast<uint32_t>(disk.totalBlocks());
    uint32_t dataBlocks = total > dataStart ? total - dataStart : 0;
    if (dataBlocks <= neededBlocks) return false;

    auto extents = CollectFileExtents();
    if (extents.empty()) {
        return AllocateContiguousRegion(dataStart, neededBlocks);
    }

    uint32_t writePtr = dataStart + dataBlocks;
    std::vector<std::tuple<int, uint32_t, uint32_t>> extCopy = extents;
    std::sort(extCopy.begin(), extCopy.end(), [](auto& a, auto& b) {
        return std::get<1>(a) > std::get<1>(b);
        });

    try {
        for (auto& t : extCopy) {
            int inodeIdx = std::get<0>(t);
            uint32_t srcStart = std::get<1>(t);
            uint32_t cnt = std::get<2>(t);
            if (cnt == 0) continue;

            uint32_t dstStart = writePtr - cnt;
            if (dstStart < dataStart) return false;
            if (dstStart != srcStart) {
                MoveInodeExtent(inodeIdx, srcStart, dstStart, cnt);
            }
            writePtr = dstStart;
        }

        uint32_t freedBlocksAtStart = writePtr - dataStart;
        if (freedBlocksAtStart >= neededBlocks) {
            return AllocateContiguousRegion(dataStart, neededBlocks);
        }
        else {
            return false;
        }
    }
    catch (...) {
        return false;
    }
}

bool MiniHSFS::ExpandInodeAreaInPlace(size_t addInodes) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    if (addInodes == 0) return true;

    // حساب العدّ القديم والجديد للـ inodes والبلوكات المطلوبة
    size_t oldInodeCount = inodeTable.size();
    size_t newInodeCount = oldInodeCount + addInodes;

    // لا نتجاوز الحد الأقصى الممكن
    size_t maxInodes = CalculateMaxPossibleInodes();
    if (newInodeCount > maxInodes) {
        // لا يمكن التوسيع أكثر من الحد الأقصى
        return false;
    }

    // حساب عدد البلوكات المطلوبة لمخزون الـ inodes الجديد
    size_t oldBlocksNeed = BlocksForInodes(oldInodeCount);
    size_t newBlocksNeed = BlocksForInodes(newInodeCount);

    // إذا البلوكات الحالية تكفي في الذاكرة/القرص، فقط نوسّع الهياكل
    if (newBlocksNeed <= inodeBlocks) {
        try {
            inodeTable.resize(newInodeCount);
            inodeBitmap.resize(newInodeCount, false);
            inodeCount = newInodeCount;
            inodeAreaSize = inodeBlocks * disk.blockSize;
            RebuildFreeInodesList();
            UpdateSuperblockForDynamicInodes();     // حدِّث معلومات السوبر بلوك
            SaveInodeTable();                       // احفظ جدول الـ inodes المحدث
            return true;
        }
        catch (...) {
            return false;
        }
    }

    // نحتاج لبلوكات إضافية على القرص
    size_t blocksDelta = newBlocksNeed - inodeBlocks;

    // نَحاول حجز البلوكات المتجاورة عند بداية منطقة البيانات
    if (!ReserveContiguousBlocksAtDataStart(blocksDelta)) {
        // إذا لم نستطع الحجز نجرّب إلغاء التجزئة لنقل ملفات البيانات وفتح المجال
        if (!DefragmentDataAreaToFreePrefix(blocksDelta)) {
            return false;
        }
        // بعد defrag نحاول الحجز مرة أخرى
        if (!ReserveContiguousBlocksAtDataStart(blocksDelta)) {
            return false;
        }
    }

    // الآن تم حجز البلوكات، حدّث الحسابات الداخلية
    try {
        // زوّد inodeBlocks وحدث مؤشر بداية البيانات (dataStartIndex / dataStartBlock)
        inodeBlocks = static_cast<uint32_t>(newBlocksNeed);
        // dataStartIndex هو موضع بلوكات البيانات بعد جدول الـ inodes
        dataStartIndex = disk.getSystemBlocks() + superBlockBlocks + static_cast<uint32_t>(inodeBlocks) + static_cast<uint32_t>(btreeBlocks);
        // (لو في متغيّر dataStartBlock، حدّثه أيضاً)
        dataStartBlock = static_cast<uint32_t>(disk.getSystemBlocks() + superBlockBlocks + inodeBlocks + btreeBlocks);

        // وسّع هياكل الذاكرة
        inodeTable.resize(newInodeCount);
        inodeBitmap.resize(newInodeCount, false);

        inodeCount = newInodeCount;
        inodeAreaSize = inodeBlocks * disk.blockSize;

        // إعادة بناء قائمة الحُرّين
        RebuildFreeInodesList();

        // حدّث السوبر بلوك بالمعلومات الجديدة
        try {
            SuperblockInfo sb = LoadSuperblock();
            sb.inodeSize = inodeSize;
            sb.totalInodes = static_cast<uint32_t>(inodeCount);
            sb.freeInodes = static_cast<uint32_t>(CountFreeInodes());
            sb.systemSize = static_cast<uint32_t>(dataStartIndex); // أو القيمة المناسبة لديك
            sb.lastWriteTime = time(nullptr);
            SaveSuperblock(sb);
        }
        catch (...) {
            // لو فشل حفظ السوبر بلوك، نحاول على الأقل حفظ جدول الـ inodes ثم نرجع خطأ
        }

        // وأخيراً احفظ جدول الـ inodes فعلياً على القرص
        SaveInodeTable();

        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "ExpandInodeAreaInPlace exception: " << e.what() << std::endl;
        return false;
    }
}

size_t MiniHSFS::BlocksForInodes(size_t inodeCount) {
    size_t totalBytes = inodeCount * inodeSize;
    return (totalBytes + disk.blockSize - 1) / disk.blockSize; // تقريب لأعلى
}

bool MiniHSFS::ReserveContiguousBlocksAtDataStart(size_t count) {
    if (count == 0) return true;
    uint32_t start = dataStartBlock;
    uint32_t total = static_cast<uint32_t>(disk.totalBlocks());
    if (start + count > total) return false;

    // تحقق أن البلوكات فارغة
    for (size_t i = 0; i < count; ++i) {
        auto data = disk.readData(VirtualDisk::Extent(start + i, 1));
        bool allZero = std::all_of(data.begin(), data.end(), [](char c) { return c == 0; });
        if (!allZero) return false;
    }

    // حجز البلوكات
    for (size_t i = 0; i < count; ++i) {
        try { BTreeInsert(rootNodeIndex, static_cast<int>(start + i), 1); }
        catch (...) {}
    }
    if (freeBlocks >= count) freeBlocks -= count; else freeBlocks = 0;
    return true;
}

// تصفير inode جديد
void MiniHSFS::ResetInode(int idx, bool isDir) {
    Inode& node = inodeTable[idx];
    node.isUsed = true;
    node.isDirectory = isDir;
    node.size = 0;
    node.blocksUsed = 0;
    node.firstBlock = -1;
    node.entries.clear();
    node.creationTime = time(nullptr);
    node.modificationTime = node.creationTime;
}

// محاولة التوسعة مع إلغاء التجزئة إذا لزم الأمر
bool MiniHSFS::TryExtendInodeTable() {
    size_t requiredBytes = (inodeTable.size() + 1) * inodeSize;
    size_t haveBytes = inodeBlocks * disk.blockSize;
    if (requiredBytes > haveBytes) {
        if (!DefragmentAndExtendInodes(1)) // تنقل البيانات + توسع
            return false;
    }
    inodeTable.emplace_back();
    return true;
}

// إلغاء التجزئة + توسعة inodes
bool MiniHSFS::DefragmentAndExtendInodes(size_t extraInodes) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    if (extraInodes == 0) return true;

    // حفظ الحالة القديمة للـ rollback إذا لزم
    uint32_t old_inodeBlocks = inodeBlocks;
    uint32_t old_dataStartBlock = dataStartBlock;
    size_t old_inodeCount = inodeTable.size();
    size_t old_inodeAreaSize = inodeAreaSize;

    // حساب الحجم الجديد للـ inodes وكمية البلوكات اللازمة
    size_t newInodeCount = old_inodeCount + extraInodes;
    size_t oldBlocksNeed = BlocksForInodes(old_inodeCount);
    size_t newBlocksNeed = BlocksForInodes(newInodeCount);

    // إذا لم نحتاج لبلوكات إضافية فوسّع الجدول بالذاكرة فقط
    if (newBlocksNeed <= oldBlocksNeed) {
        try {
            inodeTable.resize(newInodeCount);
            inodeBitmap.resize(newInodeCount, false);
            inodeCount = newInodeCount;
            inodeAreaSize = oldBlocksNeed * disk.blockSize;
            RebuildFreeInodesList();
            UpdateSuperblockForDynamicInodes();
            SaveInodeTable();
            return true;
        }
        catch (...) {
            return false;
        }
    }

    size_t blocksDelta = newBlocksNeed - oldBlocksNeed;

    // حساب بداية منطقة البيانات (البلوك المطلق)
    // اعتماداً على ترتيب مناطقك في القرص: SystemBlocks | Superblock | inodeBlocks | btreeBlocks | dataBlocks
    uint32_t dataStartAbsolute = static_cast<uint32_t>(
        disk.getSystemBlocks() + static_cast<uint32_t>(superBlockBlocks) +
        static_cast<uint32_t>(inodeBlocks) + static_cast<uint32_t>(btreeBlocks)
        );

    // 1) حاول الحجز المباشر أولاً (لو البلوكات بالفعل صفر)
    if (ReserveContiguousBlocksAtDataStart(blocksDelta)) {
        // تم الحجز مباشرة — حدّث القيم واحفظ
        try {
            inodeBlocks = static_cast<uint32_t>(newBlocksNeed);
            dataStartBlock = static_cast<uint32_t>(disk.getSystemBlocks() + static_cast<uint32_t>(superBlockBlocks) + inodeBlocks + btreeBlocks);
            dataStartIndex = dataStartBlock;
            inodeTable.resize(newInodeCount);
            inodeBitmap.resize(newInodeCount, false);
            inodeCount = newInodeCount;
            inodeAreaSize = inodeBlocks * disk.blockSize;
            RebuildFreeInodesList();
            UpdateSuperblockForDynamicInodes();
            SaveInodeTable();
            SuperblockInfo sb = LoadSuperblock();
            sb.inodeSize = inodeSize;
            sb.totalInodes = static_cast<uint32_t>(inodeCount);
            sb.freeInodes = static_cast<uint32_t>(CountFreeInodes());
            sb.systemSize = static_cast<uint32_t>(dataStartIndex);
            sb.lastWriteTime = time(nullptr);
            SaveSuperblock(sb);
            return true;
        }
        catch (...) {
            // rollback الذاكري
            inodeBlocks = old_inodeBlocks;
            dataStartBlock = old_dataStartBlock;
            inodeTable.resize(old_inodeCount);
            inodeBitmap.resize(old_inodeCount);
            inodeCount = old_inodeCount;
            inodeAreaSize = old_inodeAreaSize;
            RebuildFreeInodesList();
            return false;
        }
    }

    // 2) نجرب defrag: نقل الامتدادات من بداية منطقة البيانات للأعلى (تنازلي)
    auto extents = CollectFileExtents();
    if (extents.empty()) {
        // إن لم توجد ملفات، نحاول أن نملأ البلوكات بصفر بأنفسنا ثم نحجزها
        std::vector<char> zeroBlock(disk.blockSize, 0);
        for (size_t i = 0; i < blocksDelta; ++i) {
            uint32_t blk = dataStartAbsolute + static_cast<uint32_t>(i);
            if (blk >= disk.totalBlocks()) {
                // خطأ - لا مساحة مطلقاً
                return false;
            }
            disk.writeData(zeroBlock, VirtualDisk::Extent(blk, 1), "", true);
        }
        // الآن نحاول الحجز
        if (!ReserveContiguousBlocksAtDataStart(blocksDelta)) {
            return false;
        }
        // كما في الأعلى: حدّث القيم وحفظ
        try {
            inodeBlocks = static_cast<uint32_t>(newBlocksNeed);
            dataStartBlock = static_cast<uint32_t>(disk.getSystemBlocks() + static_cast<uint32_t>(superBlockBlocks) + inodeBlocks + btreeBlocks);
            dataStartIndex = dataStartBlock;
            inodeTable.resize(newInodeCount);
            inodeBitmap.resize(newInodeCount, false);
            inodeCount = newInodeCount;
            inodeAreaSize = inodeBlocks * disk.blockSize;
            RebuildFreeInodesList();
            UpdateSuperblockForDynamicInodes();
            SaveInodeTable();
            SuperblockInfo sb = LoadSuperblock();
            sb.inodeSize = inodeSize;
            sb.totalInodes = static_cast<uint32_t>(inodeCount);
            sb.freeInodes = static_cast<uint32_t>(CountFreeInodes());
            sb.systemSize = static_cast<uint32_t>(dataStartIndex);
            sb.lastWriteTime = time(nullptr);
            SaveSuperblock(sb);
            return true;
        }
        catch (...) {
            // rollback
            inodeBlocks = old_inodeBlocks;
            dataStartBlock = old_dataStartBlock;
            inodeTable.resize(old_inodeCount);
            inodeBitmap.resize(old_inodeCount);
            inodeCount = old_inodeCount;
            inodeAreaSize = old_inodeAreaSize;
            RebuildFreeInodesList();
            return false;
        }
    }

    // ترتيب الامتدادات تنازلياً حسب موقعها (من نهاية نحو البداية) لتفادي الكتابة فوق نفسها
    std::vector<std::tuple<int, uint32_t, uint32_t>> extCopy = extents;
    std::sort(extCopy.begin(), extCopy.end(), [](auto& a, auto& b) {
        return std::get<1>(a) > std::get<1>(b);
        });

    // سجل الحركات للـ rollback إذا فشل شيء
    struct MoveRecord { int inodeIdx; uint32_t oldStart; uint32_t newStart; uint32_t cnt; };
    std::vector<MoveRecord> movesDone;

    try {
        // نكتب من نهاية منطقة البيانات لحد النهاية
        uint32_t total = static_cast<uint32_t>(disk.totalBlocks());
        uint32_t dataBlocks = (total > dataStartAbsolute) ? (total - dataStartAbsolute) : 0;
        if (dataBlocks <= blocksDelta) throw std::runtime_error("Not enough blocks available to relocate extents");

        uint32_t writePtr = dataStartAbsolute + dataBlocks; // نقطة الكتابة من النهاية

        for (auto& t : extCopy) {
            int inodeIdx = std::get<0>(t);
            uint32_t srcStart = std::get<1>(t);
            uint32_t cnt = std::get<2>(t);
            if (cnt == 0) continue;

            uint32_t dstStart = writePtr - cnt;
            if (dstStart < dataStartAbsolute) {
                throw std::runtime_error("Insufficient contiguous space during defrag");
            }

            if (dstStart != srcStart) {
                MoveInodeExtent(inodeIdx, srcStart, dstStart, cnt);
                movesDone.push_back({ inodeIdx, srcStart, dstStart, cnt });
            }
            writePtr = dstStart;
        }

        // الآن نتحقّق أن الجزء من dataStartAbsolute حتى dataStartAbsolute+blocksDelta-1 كله صفر
        std::vector<char> zeroBlock(disk.blockSize, 0);
        for (size_t i = 0; i < blocksDelta; ++i) {
            uint32_t blk = dataStartAbsolute + static_cast<uint32_t>(i);
            if (blk >= disk.totalBlocks()) throw std::runtime_error("Block index out of range while zeroing");
            // اكتب صفر صراحةً (MoveInodeExtent من المحتمل أن يكون صفرّ البلوكات القديمة، لكن نضمنه هنا)
            disk.writeData(zeroBlock, VirtualDisk::Extent(blk, 1), "", true);
        }

        // تأكد فعلي أن هناك كلّه صفر
        bool allZero = true;
        for (size_t i = 0; i < blocksDelta; ++i) {
            uint32_t blk = dataStartAbsolute + static_cast<uint32_t>(i);
            auto data = disk.readData(VirtualDisk::Extent(blk, 1));
            if (data.size() != disk.blockSize) {
                // قم بتعبئة ما نُعيده بصفر ثم نتحقق
                std::vector<char> padded(disk.blockSize, 0);
                std::memcpy(padded.data(), data.data(), (std::min)(data.size(), padded.size()));
                if (!std::all_of(padded.begin(), padded.end(), [](char c) { return c == 0; })) { allZero = false; break; }
            }
            else {
                if (!std::all_of(data.begin(), data.end(), [](char c) { return c == 0; })) { allZero = false; break; }
            }
        }
        if (!allZero) throw std::runtime_error("After defrag some blocks are still non-zero");

        // الآن حاول حجز البلوكات (ReserveContiguousBlocksAtDataStart يفترض أن dataStartBlock هو رقم البلوك المطلق)
        // حدّث dataStartBlock باعتبارها مطلقة
        dataStartBlock = dataStartAbsolute;
        if (!ReserveContiguousBlocksAtDataStart(blocksDelta)) {
            throw std::runtime_error("ReserveContiguousBlocksAtDataStart failed after zeroing");
        }

        // تم الحجز، حدّث المتغيرات الداخلية واحفظ
        inodeBlocks = static_cast<uint32_t>(newBlocksNeed);
        dataStartBlock = static_cast<uint32_t>(disk.getSystemBlocks() + static_cast<uint32_t>(superBlockBlocks) + inodeBlocks + btreeBlocks);
        dataStartIndex = dataStartBlock;
        inodeTable.resize(newInodeCount);
        inodeBitmap.resize(newInodeCount, false);
        inodeCount = newInodeCount;
        inodeAreaSize = inodeBlocks * disk.blockSize;
        RebuildFreeInodesList();
        UpdateSuperblockForDynamicInodes();

        SaveInodeTable();
        SuperblockInfo sb = LoadSuperblock();
        sb.inodeSize = inodeSize;
        sb.totalInodes = static_cast<uint32_t>(inodeCount);
        sb.freeInodes = static_cast<uint32_t>(CountFreeInodes());
        sb.systemSize = static_cast<uint32_t>(dataStartIndex);
        sb.lastWriteTime = time(nullptr);
        SaveSuperblock(sb);

        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "DefragmentAndExtendInodes exception: " << e.what() << std::endl;

        // rollback: حاول ارجاع الامتدادات التي نقلناها
        for (auto it = movesDone.rbegin(); it != movesDone.rend(); ++it) {
            try {
                MoveInodeExtent(it->inodeIdx, it->newStart, it->oldStart, it->cnt);
            }
            catch (...) {
                std::cerr << "Rollback move failed for inode " << it->inodeIdx << std::endl;
            }
        }

        // إعادة القيم القديمة في الذاكرة
        inodeBlocks = old_inodeBlocks;
        dataStartBlock = old_dataStartBlock;
        dataStartIndex = static_cast<uint32_t>(disk.getSystemBlocks() + static_cast<uint32_t>(superBlockBlocks) + old_inodeBlocks + btreeBlocks);
        inodeTable.resize(old_inodeCount);
        inodeBitmap.resize(old_inodeCount);
        inodeCount = old_inodeCount;
        inodeAreaSize = old_inodeAreaSize;
        RebuildFreeInodesList();

        return false;
    }
}

std::vector<int> MiniHSFS::GetFileBlocks(int inodeIndex) {
    std::vector<int> blocks;
    auto& inode = inodeTable[inodeIndex];
    if (inode.blocksUsed == 0 || inode.firstBlock < 0) return blocks;

    for (int b = 0; b < inode.blocksUsed; ++b) {
        blocks.push_back(inode.firstBlock + b);
    }
    return blocks;
}

void MiniHSFS::UpdateFileBlocks(int inodeIndex, const std::vector<int>& newBlocks) {
    auto& inode = inodeTable[inodeIndex];
    if (newBlocks.empty()) {
        inode.firstBlock = -1;
        inode.blocksUsed = 0;
        return;
    }
    inode.firstBlock = newBlocks[0];
    inode.blocksUsed = static_cast<int>(newBlocks.size());
}

int MiniHSFS::FindFreeBlockFrom(size_t startBlock) {
    for (size_t blk = startBlock; blk < disk.totalBlocks(); ++blk) {
        if (disk.getBitmap()[blk] == false) {
            return static_cast<int>(blk);
        }
    }
    return -1; // مفيش بلوك فاضي
}


//---------------------------------------------------------//

void MiniHSFS::Unmount() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    if (!mounted) {
        throw std::runtime_error("Filesystem not mounted");
    }

    try {
        MiniHSFS::SuperblockInfo info = MiniHSFS::LoadSuperblock();
        info.freeBlocks = disk.freeBlocksCount();
        info.lastMountTime = time(nullptr);
        int count = 0;
        for (int i = 1; i < inodeCount; i++) {
            if (!inodeTable[i].isUsed) {
                count++;
            }
        }
        info.lastWriteTime = (lastTimeWrite != -1) ? lastTimeWrite : info.lastWriteTime;
        info.systemSize = MiniHSFS::dataStartIndex;
        info.freeInodes = CountFreeInodes();
        autoSyncRunning = false;

        if (autoSyncThread.joinable()) {
            autoSyncThread.join();
        }
        SaveSuperblock(info);
        SaveInodeTable();
        SaveBTree();
        SynchronizeDisk();
        btreeCache.clear();
        inodeTable.clear();
        btreeLruList.clear();
        btreeLruMap.clear();
        inodeLruList.clear();
        inodeLruMap.clear();

        mounted = false;
    }
    catch (const std::exception& e) {
        throw std::runtime_error(std::string("Failed to unmount: ") + e.what());
    }

}

////////////////////////////Initialize System

void MiniHSFS::InitializeSuperblock() {
    SuperblockInfo info;
    std::memset(&info, 0, sizeof(info));

    const char* magicStr = "Tomas";
    std::memcpy(info.magic, magicStr, strlen(magicStr));

    info.version = 0x00010000;
    info.blockSize = disk.blockSize;
    info.inodeSize = inodeSize;
    info.systemSize = static_cast<uint32_t>(inodeBlocks) + btreeBlocks + superBlockBlocks + disk.getSystemBlocks();
    info.totalBlocks = disk.totalBlocks();
    info.freeBlocks = static_cast<uint32_t>(info.totalBlocks - (static_cast<uint32_t>(inodeBlocks) + btreeBlocks + superBlockBlocks + disk.getSystemBlocks()));
    info.totalInodes = inodeCount;
    info.freeInodes = inodeCount - 1;
    info.creationTime = time(nullptr);
    info.lastMountTime = info.creationTime;
    info.lastWriteTime = info.creationTime;
    info.state = 1;

    SaveSuperblock(info);
}

//void MiniHSFS::InitializeInodeTable() {
//    inodeTable.clear();
//    inodeTable.resize(inodeCount);
//}

void MiniHSFS::InitializeBTree() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    rootNodeIndex = AllocateBTreeNode();
    if (rootNodeIndex == -1) {
        throw std::runtime_error("Failed to allocate root B-tree node");
    }

    BTreeNode rootNode(btreeOrder, true);
    btreeCache[rootNodeIndex] = rootNode;

    int currentNode = rootNodeIndex;
    int block = dataStartIndex;

    while (block < disk.totalBlocks()) {
        BTreeNode* node = &btreeCache[currentNode];

        if (node->keyCount == btreeOrder - 1) {
            int newNode = AllocateBTreeNode();
            if (newNode == -1) {
                throw std::runtime_error("No free B-tree nodes available");
            }

            BTreeNode newLeaf(btreeOrder, true);
            newLeaf.nextLeaf = node->nextLeaf;
            node->nextLeaf = newNode;

            SaveBTreeNode(currentNode, *node);
            currentNode = newNode;
            btreeCache[currentNode] = newLeaf;
            continue;
        }

        node->keys[node->keyCount] = block;
        node->values[node->keyCount] = 0;
        node->keyCount++;
        block++;
    }

    SaveBTreeNode(currentNode, btreeCache[currentNode]);

    if (currentNode != rootNodeIndex) {
        SaveBTreeNode(rootNodeIndex, btreeCache[rootNodeIndex]);
    }
}

///////////////////////////////B-Tree Operations

bool MiniHSFS::IsBTreeBlockFree(int index) {
    try {
        auto data = disk.readData(VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + index), 1 });

        // Empty if all data is Zero
        return std::all_of(data.begin(), data.end(), [](char c) { return c == 0; });
    }
    catch (...) {
        std::cout << "Error XX : Can Not Find Free Blocks!" << std::endl;
        // if Faild empty also
        return true;
    }
}

int MiniHSFS::AllocateBTreeNode() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    for (int i = 0; i < btreeBlocks; ++i) {
        if (IsBTreeBlockFree(i) && !disk.IsNew()) {

            // initial Block by zero data
            std::vector<char> zeroBuffer(disk.blockSize, 0);
            disk.writeData(
                zeroBuffer,
                VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + i), 1 },
                "", true
            );
            return i;
        }
        else
        {
            std::vector<char> zeroBuffer(disk.blockSize, 0);
            disk.writeData(
                zeroBuffer,
                VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + i), 1 },
                "", true
            );
            return i;
        }
    }

    return -1; // Not Blocks Empty
}

void MiniHSFS::FreeBTreeNode(int nodeIndex) {
    if (nodeIndex < 0 || nodeIndex >= btreeBlocks) return;
    BTreeNode emptyNode(btreeOrder);
    SaveBTreeNode(nodeIndex, emptyNode);
    btreeCache.erase(nodeIndex);
    std::vector<char> emptyBlock(disk.blockSize, 0);
    disk.writeData(emptyBlock, VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + nodeIndex), 1 }, "", true);
}

std::pair<bool, int> MiniHSFS::BTreeFind(int nodeIndex, int key) {

    // Load the current node
    BTreeNode node = LoadBTreeNode(nodeIndex);

    // Constant to define the boundary between linear and binary search
    constexpr int binarySearchThreshold = 16;

    int pos = 0; //Initial position

    // Selecting a search algorithm based on node size
    if (node.keyCount > binarySearchThreshold) {
        // Improved binary search for large nodes
        int left = 0;
        int right = node.keyCount - 1;

        while (left <= right) {
            pos = left + (right - left) / 2;

            if (key == node.keys[pos]) {
                // We found the key
                return { true, node.isLeaf ? node.values[pos] : node.children[pos + 1] };
            }

            if (key < node.keys[pos]) {
                right = pos - 1;
            }
            else {
                left = pos + 1;
            }
        }
        pos = left; // The position where the key would have been inserted
    }
    else {
        // Improved linear search for small nodes
        while (pos < node.keyCount && key > node.keys[pos]) {
            ++pos;
        }

        // Check if we found the key
        if (pos < node.keyCount && key == node.keys[pos]) {
            return { true, node.isLeaf ? node.values[pos] : node.children[pos + 1] };
        }
    }

    // If we get here and don't find the key
    if (node.isLeaf) {
        return { false, -1 }; // Key not found
    }

    // Continue searching for the appropriate child node
    return BTreeFind(node.children[pos], key);
}

bool MiniHSFS::BTreeInsert(int nodeIndex, int key, int value) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    if (value < 0) throw std::invalid_argument("B-tree value cannot be negative");
    BTreeNode node = LoadBTreeNode(nodeIndex);

    if (node.keyCount == btreeOrder - 1) {
        if (nodeIndex == rootNodeIndex) {
            BTreeNode newRoot(btreeOrder, false);
            int newRootIndex = AllocateBTreeNode();
            if (newRootIndex == -1) throw std::runtime_error("Failed to allocate new root node");
            newRoot.children[0] = rootNodeIndex;
            rootNodeIndex = newRootIndex;
            btreeCache[newRootIndex] = newRoot;
        }
        BTreeSplitChild(rootNodeIndex, nodeIndex, 0);
        return BTreeInsertNonFull(rootNodeIndex, key, value);
    }
    return BTreeInsertNonFull(nodeIndex, key, value);
}

bool MiniHSFS::BTreeInsertNonFull(int nodeIndex, int key, int value) {
    BTreeNode node = LoadBTreeNode(nodeIndex);
    int i = node.keyCount - 1;

    // Check if the core exists -> Just set the value and return true
    for (int j = 0; j < node.keyCount; ++j) {
        if (node.keys[j] == key) {
            node.values[j] = value;
            SaveBTreeNode(nodeIndex, node);
            return true;
        }
    }

    if (node.isLeaf) {
        // Insert the key into the correct position ->
        while (i >= 0 && key < node.keys[i]) {
            node.keys[i + 1] = node.keys[i];
            node.values[i + 1] = node.values[i];
            i--;
        }

        node.keys[i + 1] = key;
        node.values[i + 1] = value;
        node.keyCount++;
        SaveBTreeNode(nodeIndex, node);
        return true;
    }
    else {
        // Going down to the right child ->
        while (i >= 0 && key < node.keys[i]) i--;
        i++;

        BTreeNode child = LoadBTreeNode(node.children[i]);

        if (child.keyCount == btreeOrder - 1) {
            BTreeSplitChild(nodeIndex, node.children[i], i);
            // After splitting, the input location may change
            if (key > node.keys[i]) i++;
        }

        return BTreeInsertNonFull(node.children[i], key, value);
    }
}

void MiniHSFS::BTreeSplitChild(int parentIndex, int childIndex, int index) {
    BTreeNode parent = LoadBTreeNode(parentIndex);
    BTreeNode child = LoadBTreeNode(childIndex);
    BTreeNode newNode(btreeOrder, child.isLeaf);

    int newNodeIndex = AllocateBTreeNode();
    if (newNodeIndex == -1) throw std::runtime_error("No space for new B-tree node");

    int t = (btreeOrder - 1) / 2;
    newNode.keyCount = t;
    for (int j = 0; j < t; j++) {
        newNode.keys[j] = child.keys[j + t + 1];
        if (child.isLeaf) newNode.values[j] = child.values[j + t + 1];
    }

    if (!child.isLeaf) {
        for (int j = 0; j <= t; j++) {
            newNode.children[j] = child.children[j + t + 1];
        }
    }
    else {
        newNode.nextLeaf = child.nextLeaf;
        child.nextLeaf = newNodeIndex;
    }

    child.keyCount = t;

    for (int j = parent.keyCount; j > index; j--) {
        parent.children[j + 1] = parent.children[j];
        parent.keys[j] = parent.keys[j - 1];
    }
    parent.children[index + 1] = newNodeIndex;
    parent.keys[index] = child.keys[t];
    parent.keyCount++;

    SaveBTreeNode(parentIndex, parent);
    SaveBTreeNode(childIndex, child);
    SaveBTreeNode(newNodeIndex, newNode);
}

bool MiniHSFS::BTreeDelete(int nodeIndex, int key) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);  // simultaneous protection

    try {
        BTreeNode node = LoadBTreeNode(nodeIndex);
        int idx = 0;

        // Find the key inside the node
        while (idx < node.keyCount && key > node.keys[idx]) {
            idx++;
        }

        // Case 1: The key is inside the current node
        if (idx < node.keyCount && node.keys[idx] == key) {
            bool success;
            if (node.isLeaf)
                success = BTreeDeleteFromLeaf(nodeIndex, idx);
            else
                success = BTreeDeleteFromNonLeaf(nodeIndex, idx);

            if (success) {
                node.isDirty = true;
                SaveBTreeNode(nodeIndex, node);
            }

            return success;
        }

        // Case 2: The key does not exist and this is a leaf node
        if (node.isLeaf) {
            return false;  // Key not found
        }

        // Case 3: The key is in one of the children
        bool atEnd = (idx == node.keyCount);
        int childIndex = node.children[atEnd ? idx - 1 : idx];

        // Download the target child
        BTreeNode child = LoadBTreeNode(childIndex);

        // If the child has fewer keys than the minimum, fill in
        if (child.keyCount < (btreeOrder / 2)) {
            BTreeFill(nodeIndex, idx); // May be combined or borrowed from neighbors

            // Reload node and child after modification
            node = LoadBTreeNode(nodeIndex);
            childIndex = node.children[atEnd ? idx - 1 : idx];
        }

        // Follow-up deletion within the child
        return BTreeDelete(childIndex, key);
    }
    catch (const std::exception& e) {
        std::cerr << "BTreeDelete Exception: " << e.what() << "\n";
        return false;
    }
}

bool MiniHSFS::BTreeMergeChildren(int parentIndex, int index) {
    try {
        BTreeNode parent = LoadBTreeNode(parentIndex);
        int leftIndex = parent.children[index];
        int rightIndex = parent.children[index + 1];

        BTreeNode left = LoadBTreeNode(leftIndex);
        BTreeNode right = LoadBTreeNode(rightIndex);

        // Add the parent key between the two nodes
        left.keys[left.keyCount] = parent.keys[index];
        if (left.isLeaf)
            left.values[left.keyCount] = right.values[0]; // Or keep it as designed
        left.keyCount++;

        // Copy the right child's keys
        for (int i = 0; i < right.keyCount; ++i) {
            left.keys[left.keyCount + i] = right.keys[i];
            if (left.isLeaf)
                left.values[left.keyCount + i] = right.values[i];
        }

        if (!left.isLeaf) {
            for (int i = 0; i <= right.keyCount; ++i)
                left.children[left.keyCount + i] = right.children[i];
        }
        else {
            // B+ Tree Support
            left.nextLeaf = right.nextLeaf;
        }

        left.keyCount += right.keyCount;

        // Transferring keys and children to the father
        for (int i = index + 1; i < parent.keyCount; ++i)
            parent.keys[i - 1] = parent.keys[i];
        for (int i = index + 2; i <= parent.keyCount; ++i)
            parent.children[i - 1] = parent.children[i];

        parent.keyCount--;

        SaveBTreeNode(leftIndex, left);
        SaveBTreeNode(parentIndex, parent);
        FreeBTreeNode(rightIndex);

        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "Merge failed: " << e.what() << "\n";
        return false;
    }
}

void MiniHSFS::BTreeFill(int nodeIndex, int index) {
    BTreeNode node = LoadBTreeNode(nodeIndex);
    if (index > 0 && LoadBTreeNode(node.children[index - 1]).keyCount >= btreeOrder / 2) {
        BTreeBorrowFromLeft(nodeIndex, index);
    }
    else if (index < node.keyCount && LoadBTreeNode(node.children[index + 1]).keyCount >= btreeOrder / 2) {
        BTreeBorrowFromRight(nodeIndex, index);
    }
    else {
        BTreeMergeChildren(nodeIndex, index == node.keyCount ? index - 1 : index);
    }
}

void MiniHSFS::BTreeBorrowFromLeft(int nodeIndex, int index) {
    BTreeNode parent = LoadBTreeNode(nodeIndex);
    BTreeNode child = LoadBTreeNode(parent.children[index]);
    BTreeNode left = LoadBTreeNode(parent.children[index - 1]);

    for (int i = child.keyCount - 1; i >= 0; i--) {
        child.keys[i + 1] = child.keys[i];
        if (child.isLeaf) child.values[i + 1] = child.values[i];
    }
    if (!child.isLeaf) {
        for (int i = child.keyCount; i >= 0; i--) child.children[i + 1] = child.children[i];
        child.children[0] = left.children[left.keyCount];
    }

    child.keys[0] = parent.keys[index - 1];
    if (child.isLeaf) child.values[0] = left.values[left.keyCount - 1];
    parent.keys[index - 1] = left.keys[left.keyCount - 1];

    child.keyCount++;
    left.keyCount--;

    SaveBTreeNode(nodeIndex, parent);
    SaveBTreeNode(parent.children[index], child);
    SaveBTreeNode(parent.children[index - 1], left);
}

void MiniHSFS::BTreeBorrowFromRight(int nodeIndex, int index) {
    BTreeNode parent = LoadBTreeNode(nodeIndex);
    BTreeNode child = LoadBTreeNode(parent.children[index]);
    BTreeNode right = LoadBTreeNode(parent.children[index + 1]);

    child.keys[child.keyCount] = parent.keys[index];
    if (child.isLeaf) child.values[child.keyCount] = right.values[0];
    if (!child.isLeaf) child.children[child.keyCount + 1] = right.children[0];

    parent.keys[index] = right.keys[0];

    for (int i = 1; i < right.keyCount; i++) {
        right.keys[i - 1] = right.keys[i];
        if (right.isLeaf) right.values[i - 1] = right.values[i];
    }
    if (!right.isLeaf) {
        for (int i = 1; i <= right.keyCount; i++) right.children[i - 1] = right.children[i];
    }

    child.keyCount++;
    right.keyCount--;

    SaveBTreeNode(nodeIndex, parent);
    SaveBTreeNode(parent.children[index], child);
    SaveBTreeNode(parent.children[index + 1], right);
}

bool MiniHSFS::BTreeDeleteFromLeaf(int nodeIndex, int index) {
    try {
        BTreeNode node = LoadBTreeNode(nodeIndex);

        if (index < 0 || index >= node.keyCount) {
            throw std::out_of_range("Invalid index in BTreeDeleteFromLeaf");
        }

        for (int i = index + 1; i < node.keyCount; ++i) {
            node.keys[i - 1] = node.keys[i];
            node.values[i - 1] = node.values[i];  // No need for isLeaf
        }

        node.keyCount--;
        node.isDirty = true;
        SaveBTreeNode(nodeIndex, node);

        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "Error in BTreeDeleteFromLeaf: " << e.what() << std::endl;
        return false;
    }
}

bool MiniHSFS::BTreeDeleteFromNonLeaf(int nodeIndex, int index) {
    try {
        BTreeNode node = LoadBTreeNode(nodeIndex);

        // Input validation
        if (index < 0 || index >= node.keyCount) {
            throw std::out_of_range("Invalid index in BTreeDeleteFromNonLeaf");
        }

        int key = node.keys[index];

        // Case 1: The left child has enough keys.
        BTreeNode leftChild = LoadBTreeNode(node.children[index]);
        if (leftChild.keyCount >= (btreeOrder + 1) / 2) {
            int predecessor = BTreeGetPredecessor(node.children[index]);
            node.keys[index] = predecessor;
            node.isDirty = true;
            SaveBTreeNode(nodeIndex, node);
            return BTreeDelete(node.children[index], predecessor);
        }

        // Case 2: The right child has enough keys.
        BTreeNode rightChild = LoadBTreeNode(node.children[index + 1]);
        if (rightChild.keyCount >= (btreeOrder + 1) / 2) {
            int successor = BTreeGetSuccessor(node.children[index + 1]);
            node.keys[index] = successor;
            node.isDirty = true;
            SaveBTreeNode(nodeIndex, node);
            return BTreeDelete(node.children[index + 1], successor);
        }

        // Case 3: Required Merger
        if (!BTreeMergeChildren(nodeIndex, index)) {
            throw std::runtime_error("Failed to merge children");
        }

        // Reload node after merge
        node = LoadBTreeNode(nodeIndex);
        return BTreeDelete(node.children[index], key);

    }
    catch (const std::exception& e) {
        std::cerr << "Error in BTreeDeleteFromNonLeaf: " << e.what() << std::endl;
        return false;
    }
}

int MiniHSFS::BTreeGetPredecessor(int nodeIndex) {
    BTreeNode node = LoadBTreeNode(nodeIndex);
    while (!node.isLeaf) node = LoadBTreeNode(node.children[node.keyCount]);
    return node.keys[node.keyCount - 1];
}

int MiniHSFS::BTreeGetSuccessor(int nodeIndex) {
    BTreeNode node = LoadBTreeNode(nodeIndex);
    while (!node.isLeaf) node = LoadBTreeNode(node.children[0]);
    return node.keys[0];
}

/////////////////////////////////Load and Save Tables

MiniHSFS::SuperblockInfo MiniHSFS::LoadSuperblock() {
    std::vector<char> data = disk.readData(
        VirtualDisk::Extent{ static_cast<uint32_t>(superBlockIndex), static_cast<uint32_t>(superBlockBlocks) });

    SuperblockInfo info;
    std::memcpy(&info, data.data(), sizeof(SuperblockInfo));

    return info;
}

void MiniHSFS::SaveSuperblock(const SuperblockInfo& info) {
    std::vector<char> data(superBlockBlocks * disk.blockSize, 0);

    std::memcpy(data.data(), &info, sizeof(SuperblockInfo));
    disk.writeData(data,
        VirtualDisk::Extent{ static_cast<uint32_t>(superBlockIndex), static_cast<uint32_t>(superBlockBlocks) }, "", false);

}

//void MiniHSFS::LoadInodeTable() {
//    std::lock_guard<std::recursive_mutex> lock(fsMutex);
//    try {
//        InitializeInodeTable();
//
//        std::vector<char> inode_data(inodeBlocks * disk.blockSize);
//
//        for (size_t block = 0; block < inodeBlocks; ++block) {
//            auto data = disk.readData(VirtualDisk::Extent(disk.getSystemBlocks() + static_cast<uint32_t>(MiniHSFS::superBlockBlocks) + static_cast<uint32_t>(block), 1));
//            std::copy(data.begin(), data.end(), inode_data.begin() + block * disk.blockSize);
//        }
//
//        for (size_t i = 0; i < inodeCount; ++i) {
//            DeserializeInode(inodeTable[i], &inode_data[i * inodeSize], inodeSize);
//        }
//    }
//    catch (const std::bad_alloc&) {
//        std::cerr << "Memory pressure detected during inode loading. Flushing cache!" << std::endl;
//        SaveBTree(); // Save BTree
//        // Clean Caches
//        inodeTable.clear();
//        inodeLruMap.clear();
//        inodeLruList.clear();
//
//        throw;
//    }
//}
//
//void MiniHSFS::SaveInodeTable() {
//    std::lock_guard<std::recursive_mutex> lock(fsMutex);
//    std::vector<char> inode_data(inodeBlocks * disk.blockSize, 0);
//
//    for (size_t i = 0; i < inodeCount; ++i) {
//        SerializeInode(inodeTable[i], &inode_data[i * inodeSize], inodeSize);
//    }
//
//    for (size_t block = 0; block < inodeBlocks; ++block) {
//        std::vector<char> block_data(inode_data.begin() + block * disk.blockSize,
//            inode_data.begin() + (block + 1) * disk.blockSize);
//        disk.writeData(block_data, VirtualDisk::Extent(disk.getSystemBlocks() + static_cast<uint32_t>(MiniHSFS::superBlockBlocks) + static_cast<uint32_t>(block), 1), "", true);
//    }
//}

void MiniHSFS::LoadBTree() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    try {
        // Load root data from disk
        auto rootData = disk.readData(VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + rootNodeIndex), 1 });

        // Use the correct btreeOrder in the configuration
        BTreeNode rootNode(btreeOrder);
        DeserializeBTreeNode(rootNode, rootData.data());

        // Store root in cache
        btreeCache[rootNodeIndex] = std::move(rootNode);
        TouchBTreeNode(rootNodeIndex);
    }
    catch (...) {
        // If the upload fails, rebuild the tree from scratch.
        InitializeBTree();
    }
}

void MiniHSFS::SaveBTree() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    for (auto& entry : btreeCache) {
        if (entry.second.isDirty) {
            SaveBTreeNode(entry.first, entry.second);
            entry.second.isDirty = false;
        }
    }
}

MiniHSFS::BTreeNode MiniHSFS::LoadBTreeNode(int nodeIndex) {
    try {
        if (nodeIndex < 0 || nodeIndex >= btreeBlocks) {
            throw std::out_of_range("Invalid B-tree node index");
        }

        auto it = btreeCache.find(nodeIndex);
        if (it != btreeCache.end()) {
            it->second.accessCount++;
            TouchBTreeNode(nodeIndex);
            return it->second;
        }

        // Load node data from disk
        auto nodeData = disk.readData(
            VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + nodeIndex), 1 });

        BTreeNode node(btreeOrder);
        DeserializeBTreeNode(node, nodeData.data());

        node.accessCount = 1;
        btreeCache[nodeIndex] = node;
        TouchBTreeNode(nodeIndex);

        btreeLoadCounter++;
        if (btreeLoadCounter >= 100) {
            for (auto& entry : btreeCache) {
                entry.second.accessCount /= 2;
            }
            btreeLoadCounter = 0;
        }

        return node;
    }
    catch (const std::bad_alloc&) {
        std::cerr << "!! Memory pressure detected during BTree node load. Clearing BTree cache.\n";
        btreeCache.clear();
        btreeLruMap.clear();
        btreeLruList.clear();
        throw;
    }
}

void MiniHSFS::SaveBTreeNode(int nodeIndex, const BTreeNode& node) {
    if (nodeIndex < 0 || nodeIndex >= btreeBlocks) {
        throw std::out_of_range("Invalid B-tree node index");
    }

    std::vector<char> buffer(disk.blockSize, 0);
    SerializeBTreeNode(node, buffer.data());

    disk.writeData(buffer,
        VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + nodeIndex), 1 },
        "", true);

    // Update the cache without resetting the entire node
    auto it = btreeCache.find(nodeIndex);
    if (it != btreeCache.end()) {
        it->second.isDirty = false;
    }
    else {
        btreeCache[nodeIndex] = node;
        btreeCache[nodeIndex].isDirty = false;
    }

    TouchBTreeNode(nodeIndex);
}

/////////////////////////////File System Operations

int MiniHSFS::FindFile(const std::string& path) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    if (!mounted) throw std::runtime_error("Filesystem not mounted");

    // Fast path for root directory
    if (path == "/") return 0;

    ValidatePath(path);  // Check Right Path
    const auto& components = SplitPath(path);
    if (components.empty()) return 0;

    int currentInode = 0;
    for (const auto& component : components) {
        if (!inodeTable[currentInode].isDirectory)
            return -1;

        auto it = inodeTable[currentInode].entries.find(component);
        if (it == inodeTable[currentInode].entries.end())
            return -1;

        currentInode = it->second;
    }

    return currentInode;
}

std::vector<std::string> MiniHSFS::SplitPath(const std::string& path) const {
    std::vector<std::string> components;
    if (path.empty() || path == "/") return components;

    const char* start = path.data() + 1; // Skip leading '/'
    const char* end = path.data() + path.size();

    while (start < end) {
        const char* slash = std::find(start, end, '/');
        components.emplace_back(start, slash);
        start = slash + (slash != end);
    }

    return components;
}

void MiniHSFS::ValidatePath(const std::string& path) {
    if (path.empty()) {
        throw std::invalid_argument("Path cannot be empty");
    }

    if (path.length() > maxPathLength) {
        throw std::invalid_argument("Path too long");
    }

    if (path[0] != '/') {
        throw std::invalid_argument("Path must be absolute");
    }
}

int MiniHSFS::PathToInode(const std::vector<std::string>& path) {
    int currentInode = 0; // Start at root

    for (const auto& component : path) {
        if (!inodeTable[currentInode].isDirectory) {
            return -1; // Not a directory
        }

        auto it = inodeTable[currentInode].entries.find(component);
        if (it == inodeTable[currentInode].entries.end()) {
            return -1; // Component not found
        }

        currentInode = it->second;
    }

    return currentInode;
}

/////////////////////////////Printing Operation

void MiniHSFS::PrintSuperblockInfo() {
    SuperblockInfo info = LoadSuperblock();

    auto printField = [](const std::string& label, const std::string& value) {
        std::cout << "\033[1m\033[34m" << label << ":\033[0m " << "\033[32m" << value << "\033[0m\n";
        };

    printField("Filesystem Magic", std::string(info.magic, strnlen(info.magic, sizeof(info.magic))));

    std::ostringstream version;
    version << (info.version >> 16) << "."
        << ((info.version >> 8) & 0xFF) << "."
        << (info.version & 0xFF);
    printField("Version", version.str());
    printField("System Blocks Total", std::to_string(info.systemSize));
    printField("Block Size", std::to_string(info.blockSize));
    printField("Inode Size", std::to_string(info.inodeSize));
    printField("Total Blocks", std::to_string(info.totalBlocks));
    printField("Free Blocks", std::to_string(info.freeBlocks));
    printField("Total Inodes", std::to_string(info.totalInodes));
    printField("Free Inodes", std::to_string(info.freeInodes));

    char buffer[26];
#ifdef _WIN32
    ctime_s(buffer, sizeof(buffer), &info.creationTime);
#else
    ctime_r(&info.creationTime, buffer);
#endif
    printField("Created", std::string(buffer));
#ifdef _WIN32
    ctime_s(buffer, sizeof(buffer), &info.lastMountTime);
#else
    ctime_r(&info.lastMountTime, buffer);
#endif
    printField("Last Mount", std::string(buffer));
#ifdef _WIN32
    ctime_s(buffer, sizeof(buffer), &info.lastWriteTime);
#else
    ctime_r(&info.lastWriteTime, buffer);
#endif
    printField("Last Write", std::string(buffer));

    printField("State", std::to_string(info.state));
}

void MiniHSFS::PrintBTreeStructure() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    if (!mounted) {
        std::cout << "\033[1m\033[31mFilesystem not mounted\033[0m\n";
        return;
    }

    std::cout << "\n\033[1m\033[34mB-Tree Structure (Root: " << rootNodeIndex << ")\033[0m\n";
    std::cout << "\033[34m----------------------------------------\033[0m\n";

    // Map to track visited nodes
    std::unordered_set<int> visitedNodes;

    //Defining the NodeInfo structure inside a function
    struct NodeInfo {
        int index;
        int level;
        bool from_next_leaf;
    };

    std::deque<NodeInfo> nodes;
    nodes.push_back({ rootNodeIndex, 0, false });

    while (!nodes.empty()) {
        NodeInfo current = nodes.front();
        nodes.pop_front();

        // Skip if this node has already been visited
        if (visitedNodes.count(current.index)) {
            continue;
        }
        visitedNodes.insert(current.index);

        try {
            BTreeNode node = LoadBTreeNode(current.index);

            // Indents by level
            for (int i = 0; i < current.level; i++) {
                std::cout << (i == current.level - 1 ? "\033[90m|-- " : "\033[90m|   ");
            }

            // Node information
            std::cout << "\033[1m\033[36m[" << current.index << "] "
                << (node.isLeaf ? "\033[32mLeaf\033[0m" : "\033[33mNode\033[0m")
                << " (" << node.keyCount << " keys)\033[0m: ";

            // Print keys and values
            for (int i = 0; i < node.keyCount; i++) {
                std::cout << "\033[35m" << node.keys[i] << "\033[0m";
                if (node.isLeaf) {
                    std::cout << (node.values[i] ? "\033[92m(U)\033[0m" : "\033[90m(F)\033[0m");
                }
                if (i < node.keyCount - 1) std::cout << ", ";
            }

            // Print children's indicators for internal nodes
            if (!node.isLeaf) {
                std::cout << " \033[34m[Children: ";
                for (int i = 0; i <= node.keyCount; i++) {
                    if (node.children[i] != -1) {
                        std::cout << node.children[i];
                        if (i < node.keyCount) std::cout << ", ";
                    }
                }
                std::cout << "]\033[0m";
            }

            // Print the next sheet index if present
            if (node.isLeaf && node.nextLeaf != -1) {
                std::cout << " \033[90m-> Next: " << node.nextLeaf << "\033[0m";
            }

            std::cout << std::endl;

            // Add contract to waiting list
            if (!node.isLeaf && !current.from_next_leaf) {
                // For internal nodes: Add children
                for (int i = node.keyCount; i >= 0; i--) {
                    if (node.children[i] != -1) {
                        nodes.push_front({ node.children[i], current.level + 1, false });
                    }
                }
            }
            else if (node.isLeaf && node.nextLeaf != -1) {
                // For paper knots: Follow the chain
                nodes.push_back({ node.nextLeaf, current.level, true });
            }
        }
        catch (const std::exception& e) {
            std::cout << "\033[1m\033[31mError loading node " << current.index
                << ": " << e.what() << "\033[0m\n";
        }
    }

    std::cout << "\033[34m----------------------------------------\033[0m\n";
    std::cout << "Total nodes visited: " << visitedNodes.size() << std::endl;
}

/////////////////////////////Helper Function

int MiniHSFS::FindFreeBlock() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    auto searchFreeBlock = [this]() -> int {
        int currentLeaf = rootNodeIndex;

        // Move to the first leaf node
        while (!btreeCache[currentLeaf].isLeaf) {
            currentLeaf = btreeCache[currentLeaf].children[0];
        }

        // Search paper nodes
        while (currentLeaf != -1) {
            BTreeNode& leaf = btreeCache[currentLeaf];

            for (int i = 0; i < leaf.keyCount; ++i) {
                if (leaf.values[i] == 0) {  //Free block
                    int block = leaf.keys[i];

                    // Check block scope and grouping preference
                    if (block >= dataStartIndex) {
                        // Prefer contiguous blocks (optimize for fragmentation)
                        if (i + 1 < leaf.keyCount && leaf.values[i + 1] == 0) {
                            return leaf.keys[i + 1];  // Return the next block to help with contiguous allocation
                        }
                        return block;
                    }
                }
            }
            currentLeaf = leaf.nextLeaf;  // Move to the next leaf node
        }
        return -1;  // No free blocks found
        };

    //First attempt
    int freeBlock = searchFreeBlock();
    if (freeBlock != -1) return freeBlock;

    // If there are no free blocks, perform defragmentation.
    DefragmentDisk();

    // Second attempt after defragmentation
    return searchFreeBlock();
}

void MiniHSFS::MarkBlockUsed(int blockIndex) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    // Quick check of cache first
    auto rootIt = btreeCache.find(rootNodeIndex);
    if (rootIt != btreeCache.end()) {
        BTreeNode& rootNode = rootIt->second;

        // Fast binary search in the root node
        auto it = std::lower_bound(rootNode.keys, rootNode.keys + rootNode.keyCount, blockIndex);
        int pos = it - rootNode.keys;

        if (pos < rootNode.keyCount && rootNode.keys[pos] == blockIndex) {
            if (rootNode.values[pos] != 1) {
                rootNode.values[pos] = 1;
                rootNode.isDirty = true;
            }
            return;  // Updated successfully
        }
    }
    // If not in root, use global insertion
    if (!BTreeInsert(rootNodeIndex, blockIndex, 1)) {
        throw std::runtime_error("Failed to mark block as used");
    }
}

void MiniHSFS::MarkBlocksUsed(const VirtualDisk::Extent& extent) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    // Helper functions
    auto logError = [](const std::string& msg) {
        std::cerr << "\n[ERROR] " << msg << std::endl;
        };

    auto showProgress = [](int processed, int total) {
        int percent = static_cast<int>((processed * 100.0) / total);
        std::cerr << "\rMarking blocks: " << percent << "% ("
            << processed << "/" << total << ")" << std::flush;
        };

    // Validate input
    if (extent.startBlock < dataStartIndex || extent.startBlock + extent.blockCount > disk.totalBlocks()) {
        std::ostringstream msg;
        msg << "Invalid block range [" << extent.startBlock << ", "
            << extent.startBlock + extent.blockCount << "]";
        logError(msg.str());
        throw std::invalid_argument(msg.str());
    }

    const int totalBlocks = extent.blockCount;
    int processed = 0;
    bool hasErrors = false;

    // Processing large batches
    constexpr int batchThreshold = 2;
    if (totalBlocks >= batchThreshold) {
        try {
            int currentBlock = extent.startBlock;
            int remaining = totalBlocks;
            int lastUsedNodeIndex = -1;
            BTreeNode lastUsedNode(btreeOrder);
            bool hasLastNode = false;

            while (remaining > 0) {
                // Find the appropriate node
                int nodeIndex = rootNodeIndex;
                BTreeNode node;

                if (hasLastNode && currentBlock > lastUsedNode.keys[0] &&
                    currentBlock < lastUsedNode.keys[lastUsedNode.keyCount - 1]) {
                    nodeIndex = lastUsedNodeIndex;
                    node = lastUsedNode;
                }
                else {
                    int cur = rootNodeIndex;
                    node = LoadBTreeNode(cur);

                    while (!node.isLeaf) {
                        int i = 0;
                        while (i < node.keyCount && currentBlock > node.keys[i]) i++;
                        cur = node.children[i];
                        node = LoadBTreeNode(cur);
                    }
                    nodeIndex = cur;
                }

                // Insert blocks into the node
                int available = (btreeOrder - 1) - node.keyCount;
                int blocksToInsert = (std::min)(remaining, available);

                for (int i = 0; i < blocksToInsert; ++i) {
                    int key = currentBlock;
                    int pos = 0;

                    // Find the right position
                    while (pos < node.keyCount && key > node.keys[pos]) pos++;

                    if (pos < node.keyCount&& node.keys[pos] == key) {
                        node.values[pos] = 1; // Update an existing block
                    }
                    else {
                        // Insert a new block
                        for (int j = node.keyCount; j > pos; --j) {
                            node.keys[j] = node.keys[j - 1];
                            node.values[j] = node.values[j - 1];
                        }
                        node.keys[pos] = key;
                        node.values[pos] = 1;
                        node.keyCount++;
                    }

                    currentBlock++;
                    remaining--;
                    processed++;
                    showProgress(processed, totalBlocks);
                }

                node.isDirty = true;
                SaveBTreeNode(nodeIndex, node);

                lastUsedNode = node;
                lastUsedNodeIndex = nodeIndex;
                hasLastNode = true;

                if (remaining > 0 && node.keyCount == btreeOrder - 1) {
                    if (node.nextLeaf == -1) break;
                }
            }
        }
        catch (const std::exception& e) {
            logError(std::string("Batch processing failed: ") + e.what());
            hasErrors = true;
        }
    }

    // Process the remaining blocks individually
    if (processed < totalBlocks) {
        for (uint32_t i = processed; i < totalBlocks; ++i) {
            try {
                BTreeInsert(rootNodeIndex, extent.startBlock + i, 1);
                processed++;
                showProgress(processed, totalBlocks);
            }
            catch (const std::exception& e) {
                logError("Failed to mark block " + std::to_string(extent.startBlock + i) +
                    ": " + e.what());
                hasErrors = true;
            }
        }
    }
    std::cout << "" << std::endl;
}

int MiniHSFS::GetInodeIndex(const Inode& inode) const {
    for (int i = 0; i < inodeTable.size(); ++i) {
        if (&inodeTable[i] == &inode) {
            return i;
        }
    }
    throw std::runtime_error("Inode not found in inodeTable");
}

bool MiniHSFS::FreeFileBlocks(Inode& inode) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    if (!inode.isUsed || inode.firstBlock == -1 || inode.blocksUsed == 0)
        return true;  //No need to free

    try {
        for (int i = 0; i < inode.blocksUsed; ++i) {
            int block = inode.firstBlock + i;

            if (block >= 0 && block < Disk().totalBlocks()) {
                if (Disk().getBitmap()[block]) {
                    Disk().setBitmap(block, false);
                }

                BTreeDelete(rootNodeIndex, block);
            }
        }

        // Remove blocks from the disk
        disk.freeBlocks(VirtualDisk::Extent(inode.firstBlock, inode.blocksUsed));

        // Update the inode
        inode.firstBlock = -1;
        inode.blocksUsed = 0;
        inode.isDirty = true;
        UpdateInodeTimestamps(GetInodeIndex(inode), true);
        SaveInodeToDisk(GetInodeIndex(inode));

        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "Error freeing file blocks: " << e.what() << "\n";
        return false;
    }
}

bool MiniHSFS::IsBlockUsed(int blockIndex) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    auto result = BTreeFind(rootNodeIndex, blockIndex);
    return result.first && result.second == 1;
}

void MiniHSFS::ValidateInode(int inodeIndex, bool checkDirectory) {
    // Check the validity of the inode number
    if (inodeIndex < 0 || inodeIndex >= inodeCount) {
        throw std::out_of_range("Invalid inode index");
    }

    // Check if inode is in use
    if (!inodeTable[inodeIndex].isUsed) {
        throw std::runtime_error("Inode not in use");
    }

    // If checkDirectory is enabled, we check if the inode represents a directory.
    if (checkDirectory && !inodeTable[inodeIndex].isDirectory) {
        throw std::runtime_error("Not a directory");
    }
}

void MiniHSFS::UpdateInodeTimestamps(int inodeIndex, bool modify) {
    if (inodeIndex < 0 || inodeIndex >= inodeCount) return;

    time_t now = time(nullptr);
    inodeTable[inodeIndex].lastAccessed = now;

    if (modify) {
        inodeTable[inodeIndex].modificationTime = now;
    }
    else if (inodeTable[inodeIndex].creationTime == 0) {
        inodeTable[inodeIndex].creationTime = now;
        inodeTable[inodeIndex].modificationTime = now;
    }

    inodeTable[inodeIndex].isDirty = true;
}

////////////////////////////Calculation Operation

void MiniHSFS::calculatePercentage(double inodePercentage, double btreePercentage)
{
    this->inodePercentage = inodePercentage;
    this->btreePercentage = btreePercentage;
}

size_t MiniHSFS::calculateInodeCount() {
    if (inodePercentage > 1)
        return inodePercentage;

    size_t diskSizeBytes = disk.totalBlocks() * disk.blockSize;

    double inodeAreaSize = static_cast<double>(diskSizeBytes) * inodePercentage;
    size_t inodeCount = static_cast<size_t>(inodeAreaSize / inodeSize);

    return std::max<size_t>(inodeCount, 32);//Minimum 32 blocks
}

size_t MiniHSFS::calculateInodeBlocks() {
    return static_cast<size_t>(std::ceil(static_cast<double>(inodeCount * inodeSize) / disk.blockSize));
}

size_t MiniHSFS::calculateBTreeBlocks() {
    if (btreePercentage > 1)
        return btreePercentage;

    size_t totalBlocks = disk.totalBlocks();
    size_t suggested = static_cast<size_t>(std::ceil(totalBlocks * btreePercentage));
    return std::max<size_t>(suggested, 16); //Minimum 16 blocks
}

size_t MiniHSFS::calculateBTreeOrder() {
    return (disk.blockSize - (sizeof(bool) + sizeof(int) * 2)) / (sizeof(int) * 2);
}

//size_t MiniHSFS::Inode::calculateSerializedSize() const {
//    size_t total = sizeof(size) + sizeof(blocksUsed) + sizeof(firstBlock) +
//        sizeof(isDirectory) + sizeof(isUsed) +
//        sizeof(creationTime) + sizeof(modificationTime);
//
//    if (isDirectory) {
//        total += sizeof(uint16_t); // entry count
//        for (const auto& entry : entries) {
//            const std::string& name = entry.first;
//            total += sizeof(uint8_t) + name.size() + sizeof(int);
//        }
//    }
//
//    return total;
//}

//size_t MiniHSFS::CountFreeInodes() {
//    size_t count = 0;
//    for (const auto& inode : inodeTable) {
//        if (!inode.isUsed) {
//            count++;
//        }
//    }
//    return count;
//}

size_t MiniHSFS::getAvailableMemory() {
    return disk.getAvailableMemory();
}

//////////////////////////////Convertion Operation

//void MiniHSFS::SerializeInode(const Inode& inode, char* buffer, size_t bufferSize) {
//    size_t offset = 0;
//    auto write = [&](const void* data, size_t size) {
//        if (offset + size > bufferSize) throw std::runtime_error("Buffer overflow");
//        std::memcpy(buffer + offset, data, size);
//        offset += size;
//        };
//
//    write(&inode.size, sizeof(inode.size));
//    write(&inode.blocksUsed, sizeof(inode.blocksUsed));
//    write(&inode.firstBlock, sizeof(inode.firstBlock));
//    write(&inode.isDirectory, sizeof(inode.isDirectory));
//    write(&inode.isUsed, sizeof(inode.isUsed));
//    write(&inode.creationTime, sizeof(inode.creationTime));
//    write(&inode.modificationTime, sizeof(inode.modificationTime));
//
//    if (inode.isDirectory) {
//        uint16_t count = static_cast<uint16_t>(inode.entries.size());
//        write(&count, sizeof(count));
//        for (const auto& entry : inode.entries) {
//            const std::string& name = entry.first;
//            int id = entry.second;
//            uint8_t len = static_cast<uint8_t>(name.size());
//            write(&len, sizeof(len));
//            write(name.data(), len);
//            write(&id, sizeof(id));
//        }
//    }
//
//    if (offset < bufferSize) {
//        std::memset(buffer + offset, 0, bufferSize - offset);
//    }
//}
//
//void MiniHSFS::DeserializeInode(Inode& inode, const char* buffer, size_t bufferSize) {
//    size_t offset = 0;
//    auto read = [&](void* dest, size_t size) {
//        if (offset + size > bufferSize) throw std::runtime_error("Buffer underflow");
//        std::memcpy(dest, buffer + offset, size);
//        offset += size;
//        };
//
//    read(&inode.size, sizeof(inode.size));
//    read(&inode.blocksUsed, sizeof(inode.blocksUsed));
//    read(&inode.firstBlock, sizeof(inode.firstBlock));
//    read(&inode.isDirectory, sizeof(inode.isDirectory));
//    read(&inode.isUsed, sizeof(inode.isUsed));
//    read(&inode.creationTime, sizeof(inode.creationTime));
//    read(&inode.modificationTime, sizeof(inode.modificationTime));
//
//    inode.entries.clear();
//    if (inode.isDirectory) {
//        uint16_t count;
//        read(&count, sizeof(count));
//        for (uint16_t i = 0; i < count && offset < bufferSize; ++i) {
//            uint8_t len;
//            read(&len, sizeof(len));
//            char name[256] = {};
//            read(name, len);
//            int id;
//            read(&id, sizeof(id));
//            inode.entries[std::string(name, len)] = id;
//        }
//    }
//}

void MiniHSFS::SerializeBTreeNode(const BTreeNode& node, char* buffer) {
    size_t offset = 0;
    int order = node.order;

    if (node.keyCount < 0 || node.keyCount > order - 1) {
        throw std::runtime_error("SerializeBTreeNode: Invalid key_count value");
    }

    auto write = [&](const void* data, size_t size) {
        if (offset + size > disk.blockSize) throw std::runtime_error("SerializeBTreeNode: buffer overflow");
        std::memcpy(buffer + offset, data, size);
        offset += size;
        };

    write(&node.isLeaf, sizeof(bool));
    write(&node.keyCount, sizeof(int));
    write(&node.order, sizeof(int));
    write(node.keys, sizeof(int) * (order - 1));

    if (node.isLeaf) {
        write(node.values, sizeof(int) * (order - 1));
        write(&node.nextLeaf, sizeof(int));
    }
    else {
        write(node.children, sizeof(int) * order);
    }
}

void MiniHSFS::DeserializeBTreeNode(BTreeNode& node, const char* buffer) {
    size_t offset = 0;
    bool isLeaf;
    int key_count, order;

    auto read = [&](void* dest, size_t size) {
        if (offset + size > disk.blockSize) throw std::runtime_error("DeserializeBTreeNode: buffer underflow");
        std::memcpy(dest, buffer + offset, size);
        offset += size;
        };

    read(&isLeaf, sizeof(bool));
    read(&key_count, sizeof(int));
    read(&order, sizeof(int));

    if (key_count < 0 || key_count > order - 1) {
        throw std::runtime_error("DeserializeBTreeNode: Invalid key count");
    }

    node = BTreeNode(order, isLeaf);
    node.keyCount = key_count;

    read(node.keys, sizeof(int) * (order - 1));
    if (isLeaf) {
        read(node.values, sizeof(int) * (order - 1));
        read(&node.nextLeaf, sizeof(int));
    }
    else {
        read(node.children, sizeof(int) * order);
    }
}

//////////////////////////////Defragment Blocks

void MiniHSFS::DefragmentFileBlocks(int inodeIndex) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    ValidateInode(inodeIndex);

    MiniHSFS::Inode& inode = inodeTable[inodeIndex];

    if (inode.isDirectory || inode.blocksUsed <= 1)
        return;

    // 1. Read data with proper encryption handling
    VirtualDisk::Extent oldExtent(inode.firstBlock, inode.blocksUsed);
    std::vector<char> fileData;

    // Read normally
    fileData = disk.readData(oldExtent);

    // 2. Free old blocks
    for (int i = 0; i < (int)oldExtent.blockCount; ++i) {
        BTreeDelete(rootNodeIndex, oldExtent.startBlock + i);
    }
    disk.freeBlocks(oldExtent);

    // 3. Allocate new contiguous blocks
    VirtualDisk::Extent newExtent = AllocateContiguousBlocks(inode.blocksUsed);
    if (newExtent.startBlock == -1) {
        throw std::runtime_error("Failed to allocate blocks during defragmentation");
    }

    // 4. Write data with proper encryption handling
    if (!disk.writeData(fileData, newExtent, "", false)) {
        throw std::runtime_error("Failed to write data during defragmentation");
    }

    // 5. Update inode information
    inode.firstBlock = newExtent.startBlock;
    inode.blocksUsed = newExtent.blockCount;
    inode.isDirty = true;
    UpdateInodeTimestamps(inodeIndex, true);
}

VirtualDisk::Extent MiniHSFS::AllocateContiguousBlocks(int blocksNeeded) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    if (blocksNeeded <= 0) {
        throw std::invalid_argument("Block count must be positive");
    }

    // First: Try customizing directly
    try {

        VirtualDisk::Extent extent = disk.allocateBlocks(blocksNeeded);

        if (extent.blockCount > 100)
        {
            for (uint32_t i = 0; i < extent.blockCount; ++i) {
                MarkBlockUsed(extent.startBlock + i);
            }
        }
        else
            MarkBlocksUsed(extent);

        return extent;
    }
    catch (const VirtualDisk::DiskFullException&) {
        // If it fails, defragment and try again
        DefragmentDisk();

        // Try allocating again after defragmenting
        try {
            VirtualDisk::Extent extent = disk.allocateBlocks(blocksNeeded);
            for (uint32_t i = 0; i < extent.blockCount; ++i) {
                MarkBlockUsed(extent.startBlock + i);
            }
            return extent;
        }
        catch (const VirtualDisk::DiskFullException&) {
            VirtualDisk::Extent extent(-1, 0);
            return extent;
        }
    }
}

void MiniHSFS::SynchronizeDisk() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    if (!mounted) throw std::runtime_error("Filesystem not mounted");

    // Save all temporary data
    SaveInodeTable();
    SaveBTree();

    // Sync virtual disk
    disk.syncToDisk();
}

//void MiniHSFS::DefragmentDisk() {
//    std::lock_guard<std::recursive_mutex> lock(fsMutex);
//
//    // 1. Collect information about files that need to be defragmented
//    std::vector<int> filesToDefrag;
//    for (int i = 0; i < inodeCount; ++i) {
//        if (inodeTable[i].isUsed &&
//            !inodeTable[i].isDirectory &&
//            inodeTable[i].blocksUsed > 1) {
//            filesToDefrag.push_back(i);
//        }
//    }
//
//    // 2. Sort files by fragment size (largest first)
//    std::sort(filesToDefrag.begin(), filesToDefrag.end(),
//        [this](int a, int b) {
//            return inodeTable[a].blocksUsed > inodeTable[b].blocksUsed;
//        });
//
//    // 3. Defragment each file
//    for (int inodeIndex : filesToDefrag) {
//        try {
//            DefragmentFileBlocks(inodeIndex);
//        }
//        catch (const std::exception& e) {
//            std::cerr << "Failed to defragment inode " << inodeIndex
//                << ": " << e.what() << std::endl;
//            continue;
//        }
//    }
//
//    // 4. Rebuild the free block map
//    RebuildFreeBlockList();
//}

void MiniHSFS::DefragmentDisk() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    // 1. Collect information about files that need to be defragmented
    std::vector<int> filesToDefrag;
    for (int i = 0; i < inodeCount; ++i) {
        if (inodeTable[i].isUsed &&
            !inodeTable[i].isDirectory &&
            inodeTable[i].blocksUsed > 1) {
            filesToDefrag.push_back(i);
        }
    }

    // 2. Sort files by fragment size (largest first)
    std::sort(filesToDefrag.begin(), filesToDefrag.end(),
        [this](int a, int b) {
            return inodeTable[a].blocksUsed > inodeTable[b].blocksUsed;
        });

    // 3. Defragment each file and print progress
    int totalFiles = filesToDefrag.size();
    for (int i = 0; i < totalFiles; ++i) {
        int inodeIndex = filesToDefrag[i];
        try {
            DefragmentFileBlocks(inodeIndex);
        }
        catch (const std::exception& e) {
            std::cerr << "Failed to defragment inode " << inodeIndex
                << ": " << e.what() << std::endl;
            continue;
        }

        // Print progress percentage
        int percent = static_cast<int>((i + 1) * 100.0 / totalFiles);
        std::cout << "\rDefragmenting... " << percent << "% completed" << std::flush;
    }

    std::cout << std::endl << "Defragmentation completed." << std::endl;

    // 4. Rebuild the free block map
    RebuildFreeBlockList();
}

void MiniHSFS::RebuildFreeBlockList() {
    std::vector<int> freeBlocks;

    // Clear all blocks in the data range
    for (int block = dataStartIndex; block < disk.totalBlocks(); ++block) {
        if (!IsBlockUsed(block)) {
            freeBlocks.push_back(block);
        }
    }

    // Reconstruct the B-tree with free blocks
    InitializeBTree();
}

//void MiniHSFS::SaveInodeToDisk(int inodeIndex) {
//    std::vector<char> buffer(inodeSize, 0);
//    SerializeInode(inodeTable[inodeIndex], buffer.data(), inodeSize);
//
//    size_t blockIndex = inodeIndex * inodeSize / disk.blockSize;
//    size_t offset = (inodeIndex * inodeSize) % disk.blockSize;
//
//    auto diskBlock = disk.readData(
//        VirtualDisk::Extent(disk.getSystemBlocks() + static_cast<uint32_t>(superBlockBlocks) + static_cast<uint32_t>(blockIndex), 1));
//
//    
//    size_t bytesToCopy = (std::min)(buffer.size(), diskBlock.size() - offset);
//
//    std::memcpy(diskBlock.data() + offset, buffer.data(), bytesToCopy);
//
//    disk.writeData(diskBlock,
//        VirtualDisk::Extent(disk.getSystemBlocks() + static_cast<uint32_t>(superBlockBlocks) + static_cast<uint32_t>(blockIndex), 1), "", true);
//
//    inodeTable[inodeIndex].isDirty = false;
//}

void MiniHSFS::TouchBTreeNode(int index) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    auto it = btreeCache.find(index);
    if (it != btreeCache.end()) {
        it->second.accessCount++; // Update usage
    }

    if (btreeLruMap.find(index) != btreeLruMap.end()) {
        btreeLruList.erase(btreeLruMap[index]);
    }
    btreeLruList.push_front(index);
    btreeLruMap[index] = btreeLruList.begin();

    if (btreeLruList.size() > std::max<size_t>(1000, static_cast<size_t>((getAvailableMemory() * 0.05) / sizeof(BTreeNode)))) {
        FreeLRUBTreeNode(); // Throw out the least used
    }
}

void MiniHSFS::FreeLRUBTreeNode() {
    if (btreeLruList.empty()) return;

    // Get the oldest node (last in LRU)
    int victimIndex = btreeLruList.back();
    btreeLruList.pop_back();
    btreeLruMap.erase(victimIndex);

    auto it = btreeCache.find(victimIndex);
    if (it != btreeCache.end()) {
        if (it->second.isDirty) {
            SaveBTreeNode(victimIndex, it->second);
        }
        btreeCache.erase(it);
    }
}

//Nowww