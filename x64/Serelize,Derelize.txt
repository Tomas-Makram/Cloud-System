//size_t MiniHSFS::SerializeInode(const Inode& inode, char* buffer, size_t bufferSize) {
//    if (bufferSize < inodeSize) {
//        std::cerr << "Buffer too small for inode serialization. Needed: "
//            << inodeSize << ", Got: " << bufferSize << std::endl;
//        return 0;
//    }
//
//    std::memset(buffer, 0, bufferSize);
//    size_t offset = 0;
//
//    // Serialize all data FIRST
//    std::memcpy(buffer + offset, &inode.size, sizeof(inode.size));                 offset += sizeof(inode.size);
//    std::memcpy(buffer + offset, &inode.blocksUsed, sizeof(inode.blocksUsed));     offset += sizeof(inode.blocksUsed);
//    std::memcpy(buffer + offset, &inode.firstBlock, sizeof(inode.firstBlock));     offset += sizeof(inode.firstBlock);
//
//    uint8_t flags = 0;
//    if (inode.isDirectory) flags |= 0x01;
//    if (inode.isUsed)      flags |= 0x02;
//    if (inode.isDirty)     flags |= 0x04;
//    std::memcpy(buffer + offset, &flags, sizeof(flags));                           offset += sizeof(flags);
//
//    time_t c = inode.creationTime > 0 ? inode.creationTime : time(nullptr);
//    time_t m = inode.modificationTime > 0 ? inode.modificationTime : c;
//    time_t a = inode.lastAccessed > 0 ? inode.lastAccessed : c;
//
//    std::memcpy(buffer + offset, &c, sizeof(c));                                   offset += sizeof(c);
//    std::memcpy(buffer + offset, &m, sizeof(m));                                   offset += sizeof(m);
//    std::memcpy(buffer + offset, &a, sizeof(a));                                   offset += sizeof(a);
//
//    // Directory entries
//    if (inode.isDirectory && inode.isUsed) {
//        uint32_t count = static_cast<uint32_t>(inode.entries.size());
//        if (offset + sizeof(count) <= bufferSize) {
//            std::memcpy(buffer + offset, &count, sizeof(count));                   offset += sizeof(count);
//
//            for (const auto& kv : inode.entries) {
//                const std::string& name = kv.first;
//                uint16_t nameLen = static_cast<uint16_t>(name.size());
//                size_t need = sizeof(nameLen) + nameLen + sizeof(int);
//
//                if (offset + need > bufferSize) break;
//
//                std::memcpy(buffer + offset, &nameLen, sizeof(nameLen));           offset += sizeof(nameLen);
//                std::memcpy(buffer + offset, name.data(), nameLen);                offset += nameLen;
//                std::memcpy(buffer + offset, &kv.second, sizeof(kv.second));       offset += sizeof(kv.second);
//            }
//        }
//    }
//
//    // InfoInode - Serialize ALL data before checksum
//    // username
//    uint16_t unameLen = static_cast<uint16_t>(inode.infoInode.username.size());
//    if (offset + sizeof(unameLen) > bufferSize) return 0;
//    std::memcpy(buffer + offset, &unameLen, sizeof(unameLen)); offset += sizeof(unameLen);
//    if (unameLen > 0 && offset + unameLen <= bufferSize) {
//        std::memcpy(buffer + offset, inode.infoInode.username.data(), unameLen);
//        offset += unameLen;
//    }
//
//    // password
//    uint32_t passLen = static_cast<uint32_t>(inode.infoInode.password.size());
//    if (offset + sizeof(passLen) > bufferSize) return 0;
//    std::memcpy(buffer + offset, &passLen, sizeof(passLen)); offset += sizeof(passLen);
//    if (passLen > 0 && offset + passLen <= bufferSize) {
//        std::memcpy(buffer + offset, inode.infoInode.password.data(), passLen);
//        offset += passLen;
//    }
//
//    // email
//    uint16_t emailLen = static_cast<uint16_t>(inode.infoInode.email.size());
//    if (offset + sizeof(emailLen) > bufferSize) return 0;
//    std::memcpy(buffer + offset, &emailLen, sizeof(emailLen)); offset += sizeof(emailLen);
//    if (emailLen > 0 && offset + emailLen <= bufferSize) {
//        std::memcpy(buffer + offset, inode.infoInode.email.data(), emailLen);
//        offset += emailLen;
//    }
//
//    // totalSize + mySize + isRoot
//    if (offset + sizeof(inode.infoInode.totalSize) > bufferSize) return 0;
//    std::memcpy(buffer + offset, &inode.infoInode.totalSize, sizeof(inode.infoInode.totalSize));
//    offset += sizeof(inode.infoInode.totalSize);
//
//    if (offset + sizeof(inode.infoInode.mySize) > bufferSize) return 0;
//    std::memcpy(buffer + offset, &inode.infoInode.mySize, sizeof(inode.infoInode.mySize));
//    offset += sizeof(inode.infoInode.mySize);
//
//    uint8_t rootFlag = inode.infoInode.isRoot ? 1 : 0;
//    if (offset + sizeof(rootFlag) > bufferSize) return 0;
//    std::memcpy(buffer + offset, &rootFlag, sizeof(rootFlag));
//    offset += sizeof(rootFlag);
//
//    // NOW calculate checksum on ALL serialized data
//    uint32_t checksum = CalculateChecksum(buffer, offset);
//    if (offset + sizeof(checksum) <= bufferSize) {
//        std::memcpy(buffer + offset, &checksum, sizeof(checksum));
//        offset += sizeof(checksum);
//    }
//
//    return offset;
//}
//
//size_t MiniHSFS::DeserializeInode(Inode& inode, const char* buffer, size_t bufferSize) {
//    if (bufferSize < inodeSize) {
//        std::cerr << "Buffer too small for inode deserialization. Needed: "
//            << inodeSize << ", Got: " << bufferSize << std::endl;
//        return 0;
//    }
//
//    // Create a working copy for checksum verification
//    std::vector<char> copy(buffer, buffer + bufferSize);
//    size_t offset = 0;
//    size_t data_end = 0; // Track where data ends before checksum
//
//    try {
//        // Basic fields
//        std::memcpy(&inode.size, buffer + offset, sizeof(inode.size)); offset += sizeof(inode.size);
//        std::memcpy(&inode.blocksUsed, buffer + offset, sizeof(inode.blocksUsed)); offset += sizeof(inode.blocksUsed);
//        std::memcpy(&inode.firstBlock, buffer + offset, sizeof(inode.firstBlock)); offset += sizeof(inode.firstBlock);
//
//        // flags
//        uint8_t flags = 0;
//        std::memcpy(&flags, buffer + offset, sizeof(flags)); offset += sizeof(flags);
//        inode.isDirectory = (flags & 0x01) != 0;
//        inode.isUsed = (flags & 0x02) != 0;
//        inode.isDirty = (flags & 0x04) != 0;
//
//        // timestamps
//        std::memcpy(&inode.creationTime, buffer + offset, sizeof(inode.creationTime)); offset += sizeof(inode.creationTime);
//        std::memcpy(&inode.modificationTime, buffer + offset, sizeof(inode.modificationTime)); offset += sizeof(inode.modificationTime);
//        std::memcpy(&inode.lastAccessed, buffer + offset, sizeof(inode.lastAccessed)); offset += sizeof(inode.lastAccessed);
//
//        time_t now = time(nullptr);
//        if (inode.creationTime <= 0 || inode.creationTime > now + 3600) inode.creationTime = now;
//        if (inode.modificationTime <= 0 || inode.modificationTime > now + 3600) inode.modificationTime = inode.creationTime;
//        if (inode.lastAccessed <= 0 || inode.lastAccessed > now + 3600) inode.lastAccessed = inode.creationTime;
//
//        // Directory entries
//        inode.entries.clear();
//        if (inode.isDirectory && inode.isUsed && offset < bufferSize) {
//            if (offset + sizeof(uint32_t) <= bufferSize) {
//                uint32_t count = 0;
//                std::memcpy(&count, buffer + offset, sizeof(count)); offset += sizeof(count);
//
//                for (uint32_t i = 0; i < count && offset < bufferSize; ++i) {
//                    if (offset + sizeof(uint16_t) > bufferSize) break;
//                    uint16_t nameLen = 0;
//                    std::memcpy(&nameLen, buffer + offset, sizeof(nameLen)); offset += sizeof(nameLen);
//
//                    if (offset + nameLen > bufferSize) break;
//                    std::string name(nameLen, '\0');
//                    if (nameLen > 0) {
//                        std::memcpy(&name[0], buffer + offset, nameLen); offset += nameLen;
//                    }
//
//                    if (offset + sizeof(int) > bufferSize) break;
//                    int child = -1;
//                    std::memcpy(&child, buffer + offset, sizeof(child)); offset += sizeof(child);
//
//                    if (child >= 0) inode.entries.emplace(std::move(name), child);
//                }
//            }
//        }
//
//        // InfoInode - read all data
//        // username
//        if (offset + sizeof(uint16_t) > bufferSize) return 0;
//        uint16_t unameLen = 0;
//        std::memcpy(&unameLen, buffer + offset, sizeof(unameLen)); offset += sizeof(unameLen);
//        if (unameLen > 0) {
//            if (offset + unameLen > bufferSize) return 0;
//            inode.infoInode.username.assign(buffer + offset, unameLen);
//            offset += unameLen;
//        }
//
//        // password
//        if (offset + sizeof(uint32_t) > bufferSize) return 0;
//        uint32_t passLen = 0;
//        std::memcpy(&passLen, buffer + offset, sizeof(passLen)); offset += sizeof(passLen);
//        if (passLen > 0) {
//            if (offset + passLen > bufferSize) return 0;
//            inode.infoInode.password.resize(passLen);
//            std::memcpy(inode.infoInode.password.data(), buffer + offset, passLen);
//            offset += passLen;
//        }
//
//        // email
//        if (offset + sizeof(uint16_t) > bufferSize) return 0;
//        uint16_t emailLen = 0;
//        std::memcpy(&emailLen, buffer + offset, sizeof(emailLen)); offset += sizeof(emailLen);
//        if (emailLen > 0) {
//            if (offset + emailLen > bufferSize) return 0;
//            inode.infoInode.email.assign(buffer + offset, emailLen);
//            offset += emailLen;
//        }
//
//        // totalSize, mySize, isRoot
//        if (offset + sizeof(inode.infoInode.totalSize) > bufferSize) return 0;
//        std::memcpy(&inode.infoInode.totalSize, buffer + offset, sizeof(inode.infoInode.totalSize));
//        offset += sizeof(inode.infoInode.totalSize);
//
//        if (offset + sizeof(inode.infoInode.mySize) > bufferSize) return 0;
//        std::memcpy(&inode.infoInode.mySize, buffer + offset, sizeof(inode.infoInode.mySize));
//        offset += sizeof(inode.infoInode.mySize);
//
//        if (offset + sizeof(uint8_t) > bufferSize) return 0;
//        uint8_t rootFlag = 0;
//        std::memcpy(&rootFlag, buffer + offset, sizeof(rootFlag)); offset += sizeof(rootFlag);
//        inode.infoInode.isRoot = (rootFlag != 0);
//
//        data_end = offset; // Mark end of data before checksum
//
//        // Verify checksum - use the same buffer that was read
//        if (offset + sizeof(uint32_t) <= bufferSize) {
//            uint32_t stored_checksum = 0;
//            std::memcpy(&stored_checksum, buffer + offset, sizeof(stored_checksum));
//
//            // Calculate checksum on the actual data that was read
//            uint32_t calculated_checksum = CalculateChecksum(buffer, data_end);
//
//            if (stored_checksum != calculated_checksum) {
//                std::cerr << "Checksum mismatch in inode. Stored: " << stored_checksum
//                    << ", Calculated:sssssssssssssssssssssssssssssss " << calculated_checksum << std::endl;
//                //inode = Inode(); // Reset to default
//                //return 0;
//            }
//            offset += sizeof(stored_checksum);
//        }
//
//        return offset;
//    }
//    catch (...) {
//        inode = Inode();
//        return 0;
//    }
//}