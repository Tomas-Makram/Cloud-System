#include "Parser.h"

// Initialization
Parser::Parser() : fsAI(nullptr) {}

Parser::~Parser() {
    if (fsAI != nullptr) {
        delete fsAI;
    }
}

void Parser::initializeAI(MiniHSFS& mini) {
    if (fsAI == nullptr) {
        fsAI = new MiniHSFSAI(mini);
    }
}

// Basic Operations
void Parser::cd(const std::string& path, MiniHSFS& mini) {
    if (path.empty()) {
        return;
    }

    initializeAI(mini);

    std::string combinedPath;
    if (path[0] == '/') {
        combinedPath = path;
    }
    else {
        combinedPath = run::currentPath;
        if (combinedPath.back() != '/') {
            combinedPath += "/";
        }
        combinedPath += path;
    }

    std::vector<std::string> parts = mini.SplitPath(combinedPath);
    std::vector<std::string> normalized;

    for (const std::string& part : parts) {
        if (part == "." || part.empty()) {
            continue;
        }
        else if (part == "..") {
            if (!normalized.empty()) {
                normalized.pop_back();
            }
        }
        else {
            normalized.push_back(part);
        }
    }

    std::string newPath = "/";
    for (const auto& part : normalized) {
        newPath += part + "/";
    }

    if (newPath.length() > 1 && newPath.back() == '/') {
        newPath.pop_back();
    }

    if (newPath.empty()) {
        newPath = "/";
    }

    // ✅ تحقق إضافي: إذا كنا بالفعل في "/" وحاولنا الرجوع للخلف
    if (newPath == "/" && run::currentPath == "/") {
        std::cout << ">> You are already in the root directory\n";
        return;
    }

    try {
        mini.ValidatePath(newPath);
        std::vector<std::string> checkParts = mini.SplitPath(newPath);
        int inode = mini.PathToInode(checkParts);

        if (inode == -1 || !mini.inodeTable[inode].isDirectory) {
            throw std::runtime_error("Directory not found: " + newPath);
        }

        run::currentPath = newPath;
    }
    catch (const std::exception& ex) {
        throw std::runtime_error(ex.what());
    }
    // AI Enhancement: Analyze access pattern
    fsAI->analyzeAccessPattern(path.empty() ? "/" : path);
}

void Parser::ls(const std::string& input, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("\033[31mFilesystem not mounted\033[0m");

    initializeAI(mini);

    // Parse command options
    bool show_inode_info = false;
    bool long_format = false;
    bool show_hidden = false;
    bool tree = false;
    std::string path;

    // CORRECT way to split input into tokens
    std::vector<std::string> tokens;
    std::istringstream iss(input);  // Initialize with input string
    std::string token;
    while (iss >> token) {         // Extract tokens
        tokens.push_back(token);
    }

    // Process options and path
    for (size_t i = 0; i < tokens.size(); ++i) {  // Skip command name (tokens[0] == "ls")
        const auto& token = tokens[i];

        if (tokens[0][0] == '-') {
            // It's an option flag
            if (tokens[0][1] == 'i') show_inode_info = true;
            if (tokens[0][1] == 'l') long_format = true;
            if (tokens[0][1] == 'a') show_hidden = true;
            if (tokens[0][1] == 'R') tree = true;
        }
        else {
            // It's a path (take the first one only)
            if (path.empty()) {
                path = token;
            }
        }
    }
    std::string target;
    // Determine target path
    if (tokens.size() == 2)
        target = tokens[1];
    else
        target = path.empty() ?
        (run::currentPath.empty() ? "/" : run::currentPath) :
        path;

    // Validate and get inode
    mini.ValidatePath(target);
    int target_inode = mini.PathToInode(mini.SplitPath(target));

    if (target_inode == -1) {
        throw std::runtime_error("\033[31mPath not found: " + target + "\033[0m");
    }

    const MiniHSFS::Inode& inode = mini.inodeTable[target_inode];

    if (show_inode_info) {
        printInodeInfo(target_inode, target, long_format, mini);
    }
    else if (inode.isDirectory) {
        printDirectoryContents(target_inode, target, long_format, show_hidden, tree, "", false, mini);
    }
    else {
        printFileInfo(target_inode, target, long_format, mini);
    }
    // AI Enhancement: Predict next files after listing
    predictNextAccess(mini);
}

std::vector<MiniHSFS::Inode> Parser::getDirectoryItems(const std::string& path, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);
    std::vector<MiniHSFS::Inode> result;

    if (!mini.mounted) {
        throw std::runtime_error("Filesystem not mounted");
    }

    mini.ValidatePath(path);
    int inodeIndex = mini.PathToInode(mini.SplitPath(path));
    if (inodeIndex == -1)
        throw std::runtime_error("Directory not found: " + path);

    const auto& dirInode = mini.inodeTable[inodeIndex];
    if (!dirInode.isDirectory)
        throw std::runtime_error("Path is not a directory: " + path);

    for (const auto& entry : dirInode.entries) {
        const auto& name = entry.first;
        int childIndex = entry.second;
        const auto& child = mini.inodeTable[childIndex];

        MiniHSFS::Inode info;
        info.entries = std::map<std::string, int>{ {entry.first, entry.second} };
        info.isDirectory = child.isDirectory;
        info.size = child.blocksUsed * mini.Disk().blockSize;
        info.modificationTime = child.modificationTime;

        result.push_back(info);
    }

    return result;
}

void Parser::printDirectoryContents(int dir_inode, const std::string& path,
    bool long_format, bool show_hidden, bool recursive,
    const std::string& indent, bool is_last, MiniHSFS& mini) {

    const MiniHSFS::Inode& dir = mini.inodeTable[dir_inode];

    // Print current directory header (only for top-level call)
    if (indent.empty()) {
        std::cout << "\n";
        std::cout << "\033[1m" << (long_format ? "Detailed contents of " : "Contents of ")
            << path << " (inode " << dir_inode << "):\n" << "\033[0m";
        std::cout << "\033[1m" << "Total entries: " << dir.entries.size() << "\n";
        std::cout << "----------------------------------------\n" << "\033[0m";
    }

    // List entries
    size_t entry_count = 0;
    size_t visible_entries = 0;
    for (const auto& entry : dir.entries) {
        if (!show_hidden && entry.first[0] == '.') continue;
        visible_entries++;
    }


    const char* units[] = { "B", "KB", "MB", "GB", "TB" };
    auto formatSize = [&](uint64_t bytes) -> std::string {
        size_t unit = 0;
        double size = static_cast<double>(bytes);

        while (size >= 1024 && unit < 4) {
            size /= 1024;
            ++unit;
        }

        std::ostringstream out;
        out << std::fixed << std::setprecision(2) << size << " " << units[unit];
        return out.str();
        };

    size_t current_entry = 0;
    for (const auto& entry : dir.entries) {
        const std::string& name = entry.first;

        // Skip hidden if not requested
        if (!show_hidden && name[0] == '.') continue;

        current_entry++;
        bool last_entry = (current_entry == visible_entries);
        const MiniHSFS::Inode& inode = mini.inodeTable[entry.second];

        // Print indentation and tree structure
        std::cout << indent;
        if (recursive && !indent.empty()) {
            std::cout << (is_last ? "    " : "| ");//"│   ");
        }
        if (recursive) {
            std::cout << (last_entry ? "|__ " : "|-- ");
        }

        if (long_format) {
            std::cout << (inode.isDirectory ? "\033[32m" : "\033[34m")
                << std::left << std::setw(20) << name << "\033[0m";

            std::cout << std::setw(10) << (inode.isDirectory ? "DIR" : "FILE");
            std::cout << std::setw(10) << (inode.isDirectory ? "-" : std::to_string(inode.size));
            std::cout << std::setw(10) << entry.second;

            char time_buf[26];
#if _WIN32
            ctime_s(time_buf, sizeof(time_buf), &inode.modificationTime);
#else
            ctime_r(&inode.modificationTime, time_buf);
#endif
            time_buf[24] = '\0';
            std::cout << "\033[33m" << time_buf << "\033[0m" << "\n";
        }
        else {
            std::cout << (inode.isDirectory ? "\033[32m" : "\033[34m") << name << "\033[0m";
            if (inode.isDirectory) {
                std::cout << " <DIR>";
            }
            else {
                std::cout << " (" << formatSize(inode.size) << ")";
            }
            std::cout << "\n";
        }

        // Recursive listing for directories
        if (recursive && inode.isDirectory && name != "." && name != "..") {
            std::string new_indent = indent + (is_last ? "    " : "|   ");
            std::string child_path = (path == "/" ? "/" : path + "/") + name;
            printDirectoryContents(entry.second, child_path, long_format,
                show_hidden, recursive, new_indent, last_entry, mini);
        }
    }

    // Print footer for the root directory only
    if (indent.empty()) {
        std::cout << "\033[1m" << "----------------------------------------\n" << "\033[0m";


        std::cout << "\033[32mFree space: "
            << formatSize(mini.Disk().freeBlocksCount() * mini.Disk().blockSize)
            << " | Inode: " << dir_inode
            << "\n\033[0m";
    }
}

void Parser::printFileInfo(int file_inode, const std::string& path, bool long_format, MiniHSFS& mini) {
    // Validate inode number
    if (file_inode < 0 || file_inode >= mini.inodeTable.size()) {
        std::cerr << "\033[31m" << "Error: Invalid inode number " << file_inode
            << "\033[0m" << std::endl;
        return;
    }

    const MiniHSFS::Inode& file = mini.inodeTable[file_inode];

    // Header with better visual separation
    std::cout << "\033[1m" << "\033[32m" << "File Information\n";
    std::cout << "-----------------------------------------\n" << "\033[0m";

    // Format size in human-readable way
    auto formatSize = [](size_t bytes) -> std::string {
        const char* units[] = { "B", "KB", "MB", "GB", "TB" };
        size_t unit = 0;
        double size = static_cast<double>(bytes);

        while (size >= 1024 && unit < 4) {
            size /= 1024;
            unit++;
        }

        std::ostringstream oss;
        oss << std::fixed << std::setprecision(2) << size << " " << units[unit];
        return oss.str();
        };

    // Main information with consistent formatting
    std::cout << std::left << std::setw(15) << "Name:"
        << "\033[34m" << path << "\033[0m" << "\n";
    std::cout << std::setw(15) << "Inode:" << file_inode << "\n";
    std::cout << std::setw(15) << "Size:"
        << formatSize(file.size) << " (" << file.size << " bytes)\n";
    std::cout << std::setw(15) << "Blocks used:" << file.blocksUsed << "\n";
    std::cout << std::setw(15) << "First block:" << file.firstBlock << "\n";

    // Time formatting with error handling
    auto printTime = [](const char* label, time_t time) {
        std::cout << std::setw(15) << label;
        if (time == 0) {
            std::cout << "\033[33m" << "Unknown" << "\033[0m" << "\n";
        }
        else {
            char time_buf[26];
#if _WIN32
            if (ctime_s(time_buf, sizeof(time_buf), &time) == 0) {
                time_buf[24] = '\0'; // Remove newline
                std::cout << "\033[33m" << time_buf << "\033[0m";
            }
            else {
                std::cout << "\033[31m" << "Invalid timestamp" << "\033[0m";
            }
#else
            if (ctime_r(&time, time_buf) == 0) {
                time_buf[24] = '\0'; // Remove newline
                std::cout << "\033[33m" << time_buf << "\033[0m";
            }
            else {
                std::cout << "\033[31m" << "Invalid timestamp" << "\033[0m";
            }
#endif
            std::cout << "\n";
        }
        };

    printTime("Created:", file.creationTime);
    printTime("Modified:", file.modificationTime);

    // Footer
    std::cout << "\033[1m" << "\033[32m"
        << "-----------------------------------------\n"
        << "\033[0m";
}

void Parser::printInodeInfo(int inode_num, const std::string& path, bool long_format, MiniHSFS& mini) {
    // Validate inode number
    if (inode_num < 0 || inode_num >= mini.inodeTable.size()) {
        std::cerr << "\033[31m" << "Error: Invalid inode number " << inode_num
            << "\033[0m" << std::endl;
        return;
    }

    const MiniHSFS::Inode& inode = mini.inodeTable[inode_num];

    // Header with better visual separation
    std::cout << "\033[1m" << "\033[36m" << "Inode Information\n";
    std::cout << "-----------------------------------------\n" << "\033[0m";

    // Main information with consistent formatting
    std::cout << std::left << std::setw(15) << "Path:"
        << "\033[36m" << path << "\033[0m" << "\n";
    std::cout << std::setw(15) << "Inode:" << inode_num << "\n";

    // Type information with better visual distinction
    std::cout << std::setw(15) << "Type:";
    if (inode.isDirectory) {
        std::cout << "\033[36m" << "Directory" << "\033[0m"
            << " (" << inode.entries.size() << " entries)\n";
    }
    else {
        std::cout << "\033[34m" << "File" << "\033[0m" << "\n";

        // File-specific information with human-readable size
        auto formatSize = [](size_t bytes) {
            const char* units[] = { "B", "KB", "MB", "GB", "TB" };
            size_t unit = 0;
            double size = static_cast<double>(bytes);
            while (size >= 1024 && unit < 4) {
                size /= 1024;
                unit++;
            }
            std::ostringstream oss;
            oss << std::fixed << std::setprecision(2) << size << " " << units[unit];
            return oss.str();
            };

        std::cout << std::setw(15) << "Size:"
            << formatSize(inode.size) << " (" << inode.size << " bytes)\n";
        std::cout << std::setw(15) << "Blocks used:" << inode.blocksUsed << "\n";
        std::cout << std::setw(15) << "First block:" << inode.firstBlock << "\n";
    }

    // Time formatting with error handling
    auto printTime = [](const char* label, time_t time) {
        std::cout << std::setw(15) << label;
        if (time == 0) {
            std::cout << "\033[33m" << "Unknown" << "\033[0m" << "\n";
        }
        else {
            char time_buf[26];
#if _WIN32
            if (ctime_s(time_buf, sizeof(time_buf), &time) == 0) {
                time_buf[24] = '\0';
                std::cout << "\033[33m" << time_buf << "\033[0m";
            }
            else {
                std::cout << "\033[31m" << "Invalid timestamp" << "\033[0m";
            }
#else
            if (ctime_r(&time, time_buf) == 0) {
                time_buf[24] = '\0';
                std::cout << "\033[33m" << time_buf << "\033[0m";
            }
            else {
                std::cout << "\033[31m" << "Invalid timestamp" << "\033[0m";
            }
#endif
            std::cout << "\n";
        }
        };

    printTime("Created:", inode.creationTime);
    printTime("Modified:", inode.modificationTime);

    // Enhanced directory listing for long format
    if (long_format && inode.isDirectory && !inode.entries.empty()) {
        std::cout << "\033[1m" << "\nDirectory Contents:\n" << "\033[0m";
        std::cout << "-----------------------------------------\n";

        for (const auto& entry : inode.entries) {
            const auto& child_inode = mini.inodeTable[entry.second];
            std::cout << "  " << (child_inode.isDirectory ? "\033[32m" : "\033[34m")
                << std::left << std::setw(30) << entry.first
                << "\033[0m" << " (inode: " << entry.second << ")";

            if (!child_inode.isDirectory) {
                std::cout << " - " << child_inode.size << " bytes";
            }
            std::cout << "\n";
        }
    }

    // Footer
    std::cout << "\033[1m" << "\033[36m"
        << "-----------------------------------------\n"
        << "\033[0m";
}

//---------------------------------------------------------------------//
void Parser::printFileSystemInfo(MiniHSFS& mini)
{
    mini.PrintSuperblockInfo();
}

void Parser::PrintBTreeStructure(MiniHSFS& mini)
{
    mini.PrintBTreeStructure();
}
//-----------------------------------------------------------------//
void Parser::createDirectory(const std::string path, const std::string name, MiniHSFS& mini)
{
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);
    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
    mini.ValidatePath(path + name);

    auto path_components = mini.SplitPath(path + name);
    if (path_components.empty()) throw std::invalid_argument("Invalid path");

    std::string dirname = path_components.back();
    path_components.pop_back();

    if (dirname.length() > mini.maxFileNameLength) {
        throw std::invalid_argument("Directory name too long");
    }

    int parent_inode = mini.PathToInode(path_components);
    if (parent_inode == -1 || !mini.inodeTable[parent_inode].isDirectory) {
        throw std::runtime_error("Parent directory does not exist");
    }

    // Check if directory already exists
    if (mini.inodeTable[parent_inode].entries.count(dirname) > 0) {
        throw std::runtime_error("Directory already exists");
    }

    // Find free inode
    int new_inode = -1;
    for (int i = 1; i < mini.inodeCount; i++) {
        if (!mini.inodeTable[i].isUsed) {
            new_inode = i;
            break;
        }
    }

    if (new_inode == -1) throw std::runtime_error("No free inodes available");

    // Initialize new inode as directory
    mini.inodeTable[new_inode].isUsed = true;
    mini.inodeTable[new_inode].isDirectory = true;
    mini.inodeTable[new_inode].creationTime = time(nullptr);
    mini.inodeTable[new_inode].modificationTime = mini.inodeTable[new_inode].creationTime;

    // No blocks needed for empty directories in this model

    // Add to parent directory
    mini.inodeTable[parent_inode].entries[dirname] = new_inode;
    mini.UpdateInodeTimestamps(parent_inode, true);

    mini.lastTimeWrite = time(nullptr);
    //return new_inode;
}

bool Parser::deleteDirectory(const std::string& path, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
    mini.ValidatePath(path);

    int inode_index = mini.FindFile(path);
    if (inode_index == -1) throw std::runtime_error("Directory not found");

    if (!mini.inodeTable[inode_index].isDirectory) {
        throw std::runtime_error("Path is not a directory");
    }

    if (!mini.inodeTable[inode_index].entries.empty()) {
        std::cout << "\033[1;31mDirectory is not empty. Do you want to delete all contents? [Y/N]: \033[0m";
        std::string answer;
        std::getline(std::cin, answer);
        if (answer != "Y" && answer != "y") {
            std::cout << "Operation cancelled.\n";
            return false;
        }

        // حذف كل العناصر داخل المجلد بشكل recursive
        auto entriesCopy = mini.inodeTable[inode_index].entries; // لتجنب تعديل التكرار
        for (const auto& entry : entriesCopy) {
            std::string childPath = path + "/" + entry.first;
            int childInode = entry.second;
            if (mini.inodeTable[childInode].isDirectory) {
                deleteDirectory(childPath, mini);
            }
            else {
                deleteFile(childPath, mini);
            }
        }
    }

    // إزالة من المجلد الأب
    auto path_components = mini.SplitPath(path);
    std::string dirname = path_components.back();
    path_components.pop_back();

    int parent_inode = mini.PathToInode(path_components);
    if (parent_inode != -1) {
        mini.inodeTable[parent_inode].entries.erase(dirname);
        mini.UpdateInodeTimestamps(parent_inode, true);
    }

    // تصفير الـ inode
    mini.inodeTable[inode_index].isUsed = false;
    mini.inodeTable[inode_index].isDirectory = false;
    mini.inodeTable[inode_index].entries.clear();
    mini.inodeTable[inode_index].firstBlock = -1;
    mini.inodeTable[inode_index].blocksUsed = 0;
    mini.inodeTable[inode_index].modificationTime = 0;
    mini.inodeTable[inode_index].creationTime = 0;

    return true;
}

int Parser::createFile(const std::string& path, const std::string name, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
    mini.ValidatePath(path + name);

    auto path_components = mini.SplitPath(path + name);
    if (path_components.empty()) throw std::invalid_argument("Invalid path");

    std::string filename = path_components.back();
    path_components.pop_back();

    if (filename.length() > mini.maxFileNameLength) {
        throw std::invalid_argument("Filename too long");
    }

    int parent_inode = mini.PathToInode(path_components);
    if (parent_inode == -1 || !mini.inodeTable[parent_inode].isDirectory) {
        throw std::runtime_error("Parent directory does not exist");
    }

    // Check if file already exists
    if (mini.inodeTable[parent_inode].entries.count(filename) > 0) {
        throw std::runtime_error("File already exists");
    }

    // Find free inode
    int new_inode = -1;
    for (int i = 1; i < mini.inodeCount; i++) {
        if (!mini.inodeTable[i].isUsed) {
            new_inode = i;
            break;
        }
    }
    if (new_inode == -1) throw std::runtime_error("No free inodes available");

    // Initialize new file inode
    mini.inodeTable[new_inode].isUsed = true;
    mini.inodeTable[new_inode].isDirectory = false;
    mini.inodeTable[new_inode].creationTime = time(nullptr);
    mini.inodeTable[new_inode].modificationTime = mini.inodeTable[new_inode].creationTime;

    // Allocate one block
    int first_block = mini.FindFreeBlock();
    if (first_block == -1) {
        mini.inodeTable[new_inode].isUsed = false;
        throw std::runtime_error("No free blocks available");
    }

    mini.MarkBlockUsed(first_block);
    mini.inodeTable[new_inode].firstBlock = first_block;
    mini.inodeTable[new_inode].blocksUsed = 1;

    // Add to parent directory
    mini.inodeTable[parent_inode].entries[filename] = new_inode;
    mini.UpdateInodeTimestamps(parent_inode, true);

    mini.lastTimeWrite = time(nullptr);
    return new_inode;
}

bool Parser::deleteFile(const std::string& path, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) {
        throw std::runtime_error("Filesystem not mounted");
    }

    mini.ValidatePath(path);

    int inode_index = mini.FindFile(path);
    if (inode_index == -1) {
        throw std::runtime_error("File not found");
    }

    // تأكد أنه ملف وليس مجلد
    if (mini.inodeTable[inode_index].isDirectory) {
        throw std::runtime_error("Cannot delete directory using del, use rd instead");
    }

    // حفظ معلومات الكتل قبل الحذف
    int first_block = mini.inodeTable[inode_index].firstBlock;
    int blocks_used = mini.inodeTable[inode_index].blocksUsed;

    // 1. حذف من الدليل الأب أولاً
    auto path_components = mini.SplitPath(path);
    std::string filename = path_components.back();
    path_components.pop_back();

    int parent_inode = mini.PathToInode(path_components);
    if (parent_inode == -1) {
        throw std::runtime_error("Parent directory not found");
    }

    // حفظ حالة الإدخال للتراجع إذا لزم الأمر
    auto old_entry = mini.inodeTable[parent_inode].entries[filename];

    // حذف الإدخال من الدليل الأب
    mini.inodeTable[parent_inode].entries.erase(filename);
    mini.UpdateInodeTimestamps(parent_inode, true);

    try {
        // 2. تحرير كتل الملف في الـ bitmap
        if (first_block != -1 && blocks_used > 0) {
            VirtualDisk::Extent extent(first_block, blocks_used);

            // 3. تحديث B-tree أولاً
            for (int i = 0; i < blocks_used; ++i) {
                mini.BTreeDelete(mini.rootNodeIndex, first_block + i);

                // عرض التقدم
                double progress = 100.0 * (i + 1) / blocks_used;
                std::cout << "\rDeleting blocks... " << std::fixed << std::setprecision(2)
                    << progress << "%" << std::flush;
            }
            std::cout << std::endl; // سطر جديد بعد الانتهاء

            // 4. تحرير الكتل فعلياً
            if (!mini.FreeFileBlocks(mini.inodeTable[inode_index])) {
                throw std::runtime_error("Failed to free blocks in bitmap");
            }
        }

        // 5. مسح الـ inode
        mini.inodeTable[inode_index] = MiniHSFS::Inode();

        return true;
    }
    catch (const std::exception& e) {
        // التراجع عن التغييرات في حالة الفشل
        if (parent_inode != -1) {
            mini.inodeTable[parent_inode].entries[filename] = old_entry;
        }

        std::cerr << "Error deleting file: " << e.what() << std::endl;
        throw;
    }
}

//std::vector<char> Parser::readFile(const std::string& path, MiniHSFS& mini) {
//    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);
//
//    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
//    mini.ValidatePath(path);
//
//    int inode_index = mini.FindFile(path);
//    if (inode_index == -1) throw std::runtime_error("File not found");
//
//    MiniHSFS::Inode& inode = mini.inodeTable[inode_index];
//    if (inode.isDirectory) {
//        throw std::runtime_error("Cannot read a directory");
//    }
//
//    std::vector<char> data;
//    data.reserve(inode.size);
//
//    int current_block = inode.firstBlock;
//    int blocks_remaining = inode.blocksUsed;
//    size_t total_read = 0;
//
//    while (current_block != -1 && blocks_remaining > 0) {
//        auto block_data = mini.Disk().readData(VirtualDisk::Extent(current_block, 1));
//        size_t bytes_to_read = std::min<>(
//            static_cast<size_t>(inode.size - total_read),
//            block_data.size()
//        );
//
//        data.insert(data.end(), block_data.begin(), block_data.begin() + bytes_to_read);
//        total_read += bytes_to_read;
//        current_block++;
//        blocks_remaining--;
//    }
//
//    return data;
//}
//
//std::vector<char> Parser::readFile(const std::string& path, MiniHSFS& mini,
//    size_t max_size, bool show_progress) {
//
//    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);
//
//    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
//    mini.ValidatePath(path);
//
//    int inode_index = mini.FindFile(path);
//    if (inode_index == -1) throw std::runtime_error("File not found");
//
//    MiniHSFS::Inode& inode = mini.inodeTable[inode_index];
//    if (inode.isDirectory) throw std::runtime_error("Cannot read a directory");
//
//    const size_t file_size = inode.size;
//    const size_t chunk_size = (max_size == 0 ? file_size : (std::min)(max_size, file_size));
//
//    std::vector<char> data;
//    data.reserve(chunk_size);
//
//    const uint32_t block_size = mini.Disk().blockSize; // تأكد أن عندك دالة بتجيب حجم البلوك
//    const uint32_t blocks_needed = static_cast<uint32_t>(std::ceil((double)chunk_size / block_size));
//
//    int current_block = inode.firstBlock;
//    size_t total_read = 0;
//
//    for (uint32_t i = 0; i < blocks_needed; ++i) {
//        if (current_block == -1) break; // في حال الملف متجزأ وتوقف البلوك
//
//        auto future_block = mini.Disk().readDataAsync(VirtualDisk::Extent(current_block, 1));
//        std::vector<char> block_data = future_block.get();
//
//        size_t bytes_to_read = (std::min)(block_data.size(), chunk_size - total_read);
//        data.insert(data.end(), block_data.begin(), block_data.begin() + bytes_to_read);
//        total_read += bytes_to_read;
//        current_block++; // فرض إن البلوكات متسلسلة
//
//        if (show_progress) {
//            double progress = 100.0 * total_read / file_size;
//            std::cout << "\rReading... " << std::fixed << std::setprecision(2)
//                << progress << "% (" << total_read / (1024 * 1024)
//                << " MB of " << file_size / (1024 * 1024) << " MB)" << std::flush;
//        }
//    }
//
//    if (show_progress) {
//        std::cout << std::endl;
//        if (max_size > 0 && total_read < file_size) {
//            std::cout << "Note: Read " << total_read / (1024 * 1024)
//                << "MB (chunked mode). Use 'readfull' for complete file." << std::endl;
//        }
//    }
//
//    return data;
//}

// File Operations with AI
std::vector<char> Parser::readFile(const std::string& path, MiniHSFS& mini,
    size_t max_size, bool show_progress, const std::string& password) {

    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
    mini.ValidatePath(path);

    int inode_index = mini.FindFile(path);
    if (inode_index == -1) throw std::runtime_error("File not found");

    MiniHSFS::Inode& inode = mini.inodeTable[inode_index];
    if (inode.isDirectory) throw std::runtime_error("Cannot read a directory");

    if (inode.blocksUsed == 0 || inode.firstBlock == -1) {
        return {}; // ملف فارغ
    }

    VirtualDisk::Extent extent(inode.firstBlock, inode.blocksUsed);
    std::vector<char> result = mini.Disk().readData(extent, password);

    if (max_size > 0 && result.size() > max_size) {
        result.resize(max_size);
    }

    return result;
}

bool Parser::writeFile(const std::string& path, const std::vector<char>& data, MiniHSFS& mini,
    bool append, const std::string& password) {

    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
    mini.ValidatePath(path);

    int inode_index = mini.FindFile(path);
    
    if (inode_index == -1) throw std::runtime_error("Failed to create file");

    MiniHSFS::Inode& inode = mini.inodeTable[inode_index];
    if (inode.isDirectory) throw std::runtime_error("Cannot write to a directory");

    const size_t blockSize = mini.Disk().blockSize;

    // حساب عدد البلوكات المطلوبة
    size_t dataSize = data.size();

    size_t encryptedOverhead = password.empty() ? 0 :
        (CryptoUtils::ExtraSize());// + sizeof(uint32_t) * 2); // حجم العلامة + حجمين للرأس

    size_t blocks_needed = (dataSize + encryptedOverhead + blockSize - 1) / blockSize;
//    size_t blockFileSize = static_cast<size_t>(std::ceil(static_cast<double>(inode.size) / static_cast<double>(blockSize)));

    if (blocks_needed > static_cast<size_t>(mini.Disk().freeBlocksCount())) { //+ blockFileSize) {
        throw std::runtime_error("Not enough space to write this file");
    }

    // تخصيص البلوكات
    VirtualDisk::Extent extent = mini.AllocateContiguousBlocks(static_cast<int>(blocks_needed));

    if (extent.startBlock == -1) {
        throw std::runtime_error("Failed to allocate blocks even after defragmentation");
    }

    // كتابة البيانات
    if (!mini.Disk().writeData(data, extent, password, true)) {
        mini.Disk().freeBlocks(extent);
        throw std::runtime_error("Failed to write data to disk");
    }

    // تحديث معلومات الملف
    if (!append) {
        if (inode.firstBlock != -1) {
            mini.FreeFileBlocks(inode);
        }
        inode.firstBlock = extent.startBlock;
        inode.blocksUsed = extent.blockCount;
        inode.size = dataSize;
    }
    else {
        if (inode.firstBlock == -1) {
            inode.firstBlock = extent.startBlock;
            inode.blocksUsed = extent.blockCount;
        }
        else {
            // في حالة الإلحاق، نحتاج إلى دمج البلوكات القديمة والجديدة
            // هذا يتطلب تنفيذ أكثر تعقيدًا يعتمد على نظام الملفات
            throw std::runtime_error("Appending to encrypted files not fully supported yet");
        }
        inode.size += dataSize;
    }

    inode.modificationTime = time(nullptr);
    inode.isDirty = true;

    return true;
}

//bool Parser::writeFile(const std::string& path, const std::vector<char>& data, MiniHSFS& mini) {
//    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);
//
//    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
//    mini.ValidatePath(path);
//
//    int inode_index = mini.FindFile(path);
//    if (inode_index == -1) throw std::runtime_error("File not found");
//
//    MiniHSFS::Inode& inode = mini.inodeTable[inode_index];
//    if (inode.isDirectory) throw std::runtime_error("Cannot write to a directory");
//
//    if (inode.firstBlock != -1) {
//        if (!mini.FreeFileBlocks(inode)) {
//            throw std::runtime_error("Failed to free old file blocks");
//        }
//        inode.firstBlock = -1;
//        inode.blocksUsed = 0;
//    }
//
//    int blocks_needed = static_cast<int>(std::ceil(static_cast<double>(data.size()) / mini.Disk().blockSize));
//    if (blocks_needed == 0 && !data.empty()) blocks_needed = 1;
//
//    if (blocks_needed > static_cast<int>(mini.Disk().freeBlocksCount()))
//        throw std::runtime_error("Not enough space to write this file");
//
//    VirtualDisk::Extent extent = mini.AllocateContiguousBlocks(blocks_needed);
//    if (extent.startBlock == -1)
//        extent = mini.AllocateContiguousBlocks(blocks_needed);
//    if(extent.startBlock == -1)
//        throw std::runtime_error("Failed to allocate contiguous blocks even after defragmentation");
//
//    if (extent.blockCount == 0) throw std::runtime_error("Failed to allocate blocks");
//
//    uint64_t written = 0;
//    for (int i = 0; i < blocks_needed; ++i) {
//        uint64_t bytes_to_write = min(mini.Disk().blockSize, data.size() - written);
//        std::vector<char> block_data(data.begin() + written, data.begin() + written + bytes_to_write);
//        auto X = mini.Disk().writeDataAsync(block_data, VirtualDisk::Extent(extent.startBlock + i, 1), true);
//        X.get();
//        written += bytes_to_write;
//    }
//
//    inode.firstBlock = extent.startBlock;
//    inode.blocksUsed = extent.blockCount;
//    inode.size = data.size();
//    auto formatSize = [](size_t bytes) -> std::string {
//        const char* units[] = { "B", "KB", "MB", "GB", "TB" };
//        size_t unit = 0;
//        double size = static_cast<double>(bytes);
//
//        while (size >= 1024 && unit < 4) {
//            size /= 1024;
//            unit++;
//        }
//
//        std::ostringstream oss;
//        oss << std::fixed << std::setprecision(2) << size << " " << units[unit];
//        return oss.str();
//        };
//    std::cout << formatSize(data.size()) << std::endl;
//    inode.modificationTime = time(nullptr);
//    inode.isDirty = true;
//
//    return true;
//}
//

//bool Parser::writeFile(const std::string& path, const std::vector<char>& data, MiniHSFS& mini, bool append) {
//    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);
//
//    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
//    mini.ValidatePath(path);
//
//    int inode_index = mini.FindFile(path);
//    if (inode_index == -1) {
//        inode_index = createFile("", path, mini);
//        if (inode_index == -1) throw std::runtime_error("Failed to create file");
//    }
//
//    MiniHSFS::Inode& inode = mini.inodeTable[inode_index];
//    if (inode.isDirectory) throw std::runtime_error("Cannot write to a directory");
//
//    const size_t blockSize = mini.Disk().blockSize;
//    const size_t blocks_needed = (data.size() + blockSize - 1) / blockSize;
//
//    if (blocks_needed > mini.Disk().freeBlocksCount()) {
//        throw std::runtime_error("Not enough space to write this file");
//    }
//
//    if (!append) {
//        // وضع الكتابة العادية (استبدال المحتوى)
//        if (inode.firstBlock != -1 && !mini.FreeFileBlocks(inode)) {
//            throw std::runtime_error("Failed to free old file blocks");
//        }
//
//        VirtualDisk::Extent extent = mini.AllocateContiguousBlocks(blocks_needed);
//        if (extent.startBlock == -1) {
//            throw std::runtime_error("Failed to allocate blocks");
//        }
//
//        // كتابة البيانات
//        size_t written = 0;
//        for (size_t i = 0; i < blocks_needed; ++i) {
//            size_t bytes_to_write = (std::min)(blockSize, data.size() - written);
//            std::vector<char> block_data(data.begin() + written, data.begin() + written + bytes_to_write);
//
//            mini.Disk().writeData(block_data, VirtualDisk::Extent(extent.startBlock + i, 1),"123", true);
//            written += bytes_to_write;
//        }
//
//        inode.firstBlock = extent.startBlock;
//        inode.blocksUsed = extent.blockCount;
//        inode.size = data.size();
//    }
//    else {
//        // وضع الإلحاق
//        std::vector<VirtualDisk::Extent> new_extents;
//
//        // تخصيص الكتل الجديدة
//        VirtualDisk::Extent extent = mini.AllocateContiguousBlocks(blocks_needed);
//        if (extent.startBlock == -1) {
//            throw std::runtime_error("Failed to allocate blocks for append");
//        }
//        new_extents.push_back(extent);
//
//        // كتابة البيانات
//        size_t written = 0;
//        for (size_t i = 0; i < blocks_needed; ++i) {
//            size_t bytes_to_write = (std::min)(blockSize, data.size() - written);
//            std::vector<char> block_data(data.begin() + written, data.begin() + written + bytes_to_write);
//
//            mini.Disk().writeData(block_data, VirtualDisk::Extent(extent.startBlock + i, 1), "123", true);
//            written += bytes_to_write;
//        }
//
//        // تحديث الـ inode
//        if (inode.firstBlock == -1) {
//            // إذا كان الملف فارغاً
//            inode.firstBlock = extent.startBlock;
//            inode.blocksUsed = extent.blockCount;
//        }
//        else {
//            // إضافة الكتل الجديدة إلى الكتل الموجودة
//            inode.blocksUsed += extent.blockCount;
//
//            // هنا يجب إضافة الكتل الجديدة إلى نظام تتبع الكتل الخاص بك
//            // مثلاً: mini.AddBlocksToFile(inode_index, new_extents);
//        }
//
//        inode.size += data.size();
//    }
//
//    inode.modificationTime = time(nullptr);
//    inode.isDirty = true;
//
//    return true;
//}

size_t Parser::getFileSize(const std::string& path, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
    mini.ValidatePath(path);

    int inode_index = mini.FindFile(path);
    if (inode_index == -1) throw std::runtime_error("File not found");

    return mini.inodeTable[inode_index].size;
}

bool Parser::rename(const std::string& old_path, const std::string& new_name, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted)
        throw std::runtime_error("Filesystem not mounted");

    mini.ValidatePath(old_path);

    auto path_components = mini.SplitPath(old_path);
    if (path_components.empty())
        throw std::invalid_argument("Invalid path");

    std::string old_entry_name = path_components.back();
    path_components.pop_back();

    int parent_inode = mini.PathToInode(path_components);
    if (parent_inode == -1 || !mini.inodeTable[parent_inode].isDirectory)
        throw std::runtime_error("Parent directory not found");

    auto& entries = mini.inodeTable[parent_inode].entries;

    // تحقق من وجود الاسم القديم
    if (entries.count(old_entry_name) == 0)
        throw std::runtime_error("This name" + old_entry_name + "not found");

    int target_inode = entries[old_entry_name];

    // تحقق من عدم وجود الاسم الجديد مسبقاً
    if (entries.count(new_name) > 0)
        throw std::runtime_error("An entry with the new name" + new_name + "already exists");

    // يمكن إضافة شرط إذا أردت منع إعادة تسمية أنواع معينة، أو سجل Log بناءً على is_directory
    // bool is_dir = MiniHSFS::inode_table[target_inode].is_directory;

    // إعادة التسمية
    entries.erase(old_entry_name);
    entries[new_name] = target_inode;

    mini.UpdateInodeTimestamps(parent_inode, true);
    return true;
}

bool Parser::move(const std::string& srcPath, const std::string& destPath, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");

    mini.ValidatePath(srcPath);
    mini.ValidatePath(destPath);

    int srcInode = mini.FindFile(srcPath);
    if (srcInode == -1) throw std::runtime_error("Source not found");

    int destInode = mini.FindFile(destPath);
    if (destInode == -1 || !mini.inodeTable[destInode].isDirectory)
        throw std::runtime_error("Destination must be a valid directory");

    const std::string name = mini.SplitPath(srcPath).back();

    if (mini.inodeTable[srcInode].isDirectory) {
        // إنشاء مجلد جديد في الوجهة بنفس الاسم
        std::string newFolderPath = destPath + "/" + name;
        createDirectory(destPath + "/", name, mini);

        for (const auto& entry : mini.inodeTable[srcInode].entries) {
            const std::string childSrcPath = srcPath + "/" + entry.first;
            move(childSrcPath, newFolderPath, mini); // نقل العناصر داخليًا بشكل recursive
        }

        deleteDirectory(srcPath, mini);
    }
    else {
        // فقط انقل الملف (نفس كود الإصدار السابق)

        // إزالة من الدليل الأب
        auto srcParts = mini.SplitPath(srcPath);
        std::string entryName = srcParts.back();
        srcParts.pop_back();
        int parentInode = mini.PathToInode(srcParts);

        if (parentInode != -1) {
            mini.inodeTable[parentInode].entries.erase(entryName);
            mini.UpdateInodeTimestamps(parentInode, true);
        }

        // إضافة إلى الدليل الوجهة
        mini.inodeTable[destInode].entries[entryName] = srcInode;
        mini.UpdateInodeTimestamps(destInode, true);
    }

    return true;
}

bool Parser::copy(const std::string& srcPath, const std::string& destPath, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");

    mini.ValidatePath(srcPath);
    mini.ValidatePath(destPath);

    int srcInode = mini.FindFile(srcPath);
    if (srcInode == -1) throw std::runtime_error("Source not found");

    int destInode = mini.FindFile(destPath);
    if (destInode == -1 || !mini.inodeTable[destInode].isDirectory)
        throw std::runtime_error("Destination must be a directory");

    std::string name = mini.SplitPath(srcPath).back();

    if (mini.inodeTable[srcInode].isDirectory) {
        // إنشاء مجلد في الوجهة
        std::string newFolderPath = destPath + "/" + name;
        createDirectory(destPath + "/", name, mini);

        for (const auto& entry : mini.inodeTable[srcInode].entries) {
            std::string childSrcPath = srcPath + "/" + entry.first;
            copy(childSrcPath, newFolderPath, mini);
        }
    }
    else {
        // --- ✅ قراءة المحتوى
        std::vector<char> content = readFile(srcPath, mini);
        size_t fileSize = content.size();
        int blockSize = mini.Disk().blockSize;
        int neededBlocks = static_cast<int>(std::ceil(static_cast<double>(fileSize) / blockSize));

        // --- ✅ تحقق من المساحة المتاحة
        if (neededBlocks > static_cast<int>(mini.Disk().freeBlocksCount())) {
            throw std::runtime_error("Not enough disk space to copy file: " + srcPath);
        }

        // --- ✅ نسخ فعلي
        createFile(destPath + "/", name, mini);
        writeFile(destPath + "/" + name, content, mini);
    }

    return true;
}

//-----------------------------------------------------------------//
void Parser::cls() {
#ifdef _WIN32
    system("cls");   // Windows
#else
    system("clear"); // Linux/macOS
#endif
}

void Parser::printBitmap(MiniHSFS& mini) {
    mini.Disk().printBitmap();
}

void Parser::exit(MiniHSFS& mini) {
    std::cout << "\033[32mBye :)\033[0m" << std::endl;
}

//------------------------------------------------------------------//

// AI Analysis Functions
void Parser::analyzeStorage(MiniHSFS& mini) {
    initializeAI(mini);
    fsAI->generateStorageReport();

    // Additional analysis
    auto bitmap = mini.Disk().getBitmap();
    size_t used_blocks = std::count(bitmap.begin(), bitmap.end(), true);
    size_t total_blocks = bitmap.size();

    std::cout << "\n\033[1mBlock Usage Analysis:\033[0m\n";
    std::cout << " - Used Blocks: " << used_blocks << " ("
        << (used_blocks * 100 / total_blocks) << "%)\n";
    std::cout << " - Free Blocks: " << (total_blocks - used_blocks) << " ("
        << ((total_blocks - used_blocks) * 100 / total_blocks) << "%)\n";

    // Fragmentation analysis
    size_t free_blocks = 0;
    size_t max_contiguous = 0;
    size_t current_contiguous = 0;

    for (size_t i = mini.dataStartIndex; i < total_blocks; i++) {
        if (!bitmap[i]) {
            free_blocks++;
            current_contiguous++;
            if (current_contiguous > max_contiguous) {
                max_contiguous = current_contiguous;
            }
        }
        else {
            current_contiguous = 0;
        }
    }

    std::cout << "\n\033[1mFragmentation Analysis:\033[0m\n";
    std::cout << " - Largest Contiguous Free Space: " << max_contiguous << " blocks\n";
    std::cout << " - Fragmentation Level: "
        << (free_blocks > 0 ? (100 - (max_contiguous * 100 / free_blocks)) : 0)
        << "%\n";
}

void Parser::predictNextAccess(MiniHSFS& mini) {
    initializeAI(mini);

    std::vector<std::string> predicted_files = fsAI->predictNextFiles(
        run::currentPath.empty() ? "/" : run::currentPath
    );

    if (!predicted_files.empty()) {
        std::cout << "\n\033[1mAI Prediction:\033[0m Next likely files to access:\n";
        for (const auto& file : predicted_files) {
            std::cout << " - " << file << "\n";
        }
    }
}

void Parser::optimizeFilePlacement(const std::string& filePath, MiniHSFS& mini) {
    initializeAI(mini);

    int inode = mini.PathToInode(mini.SplitPath(filePath));
    if (inode == -1) return;

    MiniHSFS::Inode& file = mini.inodeTable[inode];
    if (file.isDirectory || file.firstBlock == -1) return;

    // Get current file data
    std::vector<char> data = readFile(filePath, mini);
    std::string file_type = detectFileType(data);

    // Get optimal placement suggestion
    VirtualDisk::Extent new_extent = fsAI->suggestOptimalBlockPlacement(
        file.blocksUsed,
        file_type
    );

    // If better placement found, move the file
    if (new_extent.startBlock != -1 && new_extent.startBlock != file.firstBlock) {
        if (mini.Disk().writeData(data, new_extent, "", true)) {
            // Free old blocks
            VirtualDisk::Extent old_extent(file.firstBlock, file.blocksUsed);
            mini.Disk().freeBlocks(old_extent);

            // Update inode
            file.firstBlock = new_extent.startBlock;
            file.modificationTime = time(nullptr);

            std::cout << "\033[32mOptimized placement for file: " << filePath
                << " (moved to blocks " << new_extent.startBlock
                << "-" << (new_extent.startBlock + new_extent.blockCount - 1)
                << ")\033[0m\n";
        }
    }
}

void Parser::checkSecurity(const std::string& operation, const std::string& path,
    MiniHSFS& mini, const std::string& password) {
    initializeAI(mini);

    if (fsAI->detectAnomalousActivity(path, operation, password)) {
        std::cerr << "\n\033[1m\033[31mSECURITY ALERT!\033[0m\n";
        std::cerr << "Suspicious activity detected:\n";
        std::cerr << " - Operation: " << operation << "\n";
        std::cerr << " - Path: " << path << "\n";

        // Additional security measures can be added here
        throw std::runtime_error("Security violation detected");
    }
}

// Helper Functions
std::string Parser::detectFileType(const std::vector<char>& data) {
    if (fsAI == nullptr) return "unknown";
    return fsAI->detectFileType(data);
}