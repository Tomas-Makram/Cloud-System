-------------------------------------------------------------
                 	      FileSystem
-------------------------------------------------------------
------------------------------
CryptoUtils.h
------------------------------
#ifndef CRYPTO_UTILS_H
#define CRYPTO_UTILS_H

#include <vector>
#include <string>
#include <cstdint>
#include <fstream>
#include <random>
#include <algorithm>
#include <array>
#include <iostream>
#include <iomanip>
#include <cctype>
#include <cstring>
#include <stdexcept>
#include <cstdlib>

#ifdef _WIN32
#include <windows.h>
#include <bcrypt.h>
#pragma comment(lib, "bcrypt.lib")
#elif __linux__
#include <sys/syscall.h>
#include <unistd.h>

static ssize_t getrandom(void* buf, size_t buflen, unsigned int flags) {
    return syscall(SYS_getrandom, buf, buflen, flags);
}

#else
#include <random>  // fallback
#endif

class CryptoUtils {
public:
    static constexpr size_t nonceSize = 24;  // 192-bit
    static constexpr size_t saltSize = 16;  // 128-bit salt
    static constexpr size_t keySize = 32;  // 256-bit    
    static constexpr size_t tagSize = 16; // 128-bit
   
    // Basic encryption and decryption
    static std::vector<uint8_t> EncryptWithSalt(const std::vector<uint8_t>& plaintext,const std::string& password);
    static std::vector<uint8_t> DecryptWithSalt(const std::vector<uint8_t>& fullData,const std::string& password);

    static const size_t ExtraSize()
    {
        return saltSize + nonceSize + tagSize; //16 + 24 + 16 = 56
    }

private:
    //////////////////////////////////First Position
    // Generate Nonce and salt
    static std::vector<uint8_t> GenerateNonce();
    static std::vector<uint8_t> GenerateSalt();

    //////////////////////////////////Second Position
    //To Encryption First TAG
    static std::vector<uint8_t> sha256(const std::vector<uint8_t>& data);

    // Derivation of keys
    static std::vector<uint8_t> DeriveKey(const std::string& password,
        const std::vector<uint8_t>& salt,
        int iterations = 100000);

    //Convert Bits to Bytes
    static uint32_t Load32(const uint8_t* src);

    //Initialize Chacha20 Settings
    static void SetupChaChaState(
        uint32_t state[16],
        const std::vector<uint8_t>& key,
        const std::vector<uint8_t>& nonce,
        uint32_t counter = 1
    );

    //Basic encryption and decryption
    static std::vector<uint8_t> Encrypt(const std::vector<uint8_t>& plaintext,
        const std::vector<uint8_t>& key,
        const std::vector<uint8_t>& nonce);

    static std::vector<uint8_t> Decrypt(
        const std::vector<uint8_t>& ciphertext,
        const std::vector<uint8_t>& key,
        const std::vector<uint8_t>& nonce);

    // Internal algorithms
    static void ChaCha20Block(uint32_t out[16], const uint32_t in[16]);
    static void Poly1305Mac(const uint8_t* message, size_t length,
        const uint8_t key[32], uint8_t tag[16]);

    // Helper functions
    static void XORBlocks(const uint8_t* a, const uint8_t* b, uint8_t* out, size_t len);
    static void GenerateRandomBytes(uint8_t* output, size_t size);
    static void HChaCha20(const uint8_t key[32], const uint8_t nonce[16], uint8_t out[32]);

};
#endif // CRYPTO_UTILS_H
------------------------------
CryptoUtils.cpp
------------------------------
#include "CryptoUtils.h"

namespace {
    // ChaCha20 constants
    constexpr uint32_t chachaConstants[4] = {
        0x61707865, 0x3320646e, 0x79622d32, 0x6b206574
    };

  
    const uint32_t k[64] = {
    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,
    0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,
    0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,
    0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,
    0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,
    0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,
    0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,
    0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,
    0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
    };

// Auxiliary functions

    //Move X to y and y To x by  Left
    uint32_t RotateLeft(uint32_t x, int n) {
        return (x << n) | (x >> (32 - n));
    }

    //Move X to y and y To x by Right
    inline uint32_t RotateRight(uint32_t x, uint32_t n) {
        return (x >> n) | (x << (32 - n));
    }

    //Choice function Choose between y && z by x
    inline uint32_t ch(uint32_t x, uint32_t y, uint32_t z) {
        return (x & y) ^ (~x & z);
    }

    void QuarterRound(uint32_t& a, uint32_t& b, uint32_t& c, uint32_t& d) {
        a += b; d ^= a; d = RotateLeft(d, 16);
        c += d; b ^= c; b = RotateLeft(b, 12);
        a += b; d ^= a; d = RotateLeft(d, 8);
        c += d; b ^= c; b = RotateLeft(b, 7);
    }
    
    //Get the most Value between x,y,z and return this value
    inline uint32_t maj(uint32_t x, uint32_t y, uint32_t z) {
        return (x & y) ^ (x & z) ^ (y & z);
    }

    inline uint32_t sig0(uint32_t x) {
        return RotateRight(x, 7) ^ RotateRight(x, 18) ^ (x >> 3);
    }

    inline uint32_t sig1(uint32_t x) {
        return RotateRight(x, 17) ^ RotateRight(x, 19) ^ (x >> 10);
    }

    inline uint32_t ep0(uint32_t x) {
        return RotateRight(x, 2) ^ RotateRight(x, 13) ^ RotateRight(x, 22);
    }

    inline uint32_t ep1(uint32_t x) {
        return RotateRight(x, 6) ^ RotateRight(x, 11) ^ RotateRight(x, 25);
    }
}

//////////////////////////////////////First Position

//Generate secure random numbers (To Generate Salt && Nonce )
void CryptoUtils::GenerateRandomBytes(uint8_t* output, size_t size) {
#if defined(_WIN32)
    if (BCryptGenRandom(nullptr, output, static_cast<ULONG>(size),
        BCRYPT_USE_SYSTEM_PREFERRED_RNG) != 0) {
        throw std::runtime_error("BCryptGenRandom failed");
    }

#elif defined(__linux__)
    ssize_t result = getrandom(output, size, 0);
    if (result != static_cast<ssize_t>(size)) {
        throw std::runtime_error("getrandom failed");
    }

#else
    // fallback to C++ random_device
    static std::random_device rd;
    for (size_t i = 0; i < size; ++i) {
        output[i] = static_cast<uint8_t>(rd() & 0xFF); //To get last Random 8 bits
    }
#endif
}

// Generate a random key (Nonce)
std::vector<uint8_t> CryptoUtils::GenerateNonce() {
    std::vector<uint8_t> nonce(nonceSize);
    GenerateRandomBytes(nonce.data(), nonce.size());
    return nonce;
}

// Generate a random salt (Salt)
std::vector<uint8_t> CryptoUtils::GenerateSalt() {
    std::vector<uint8_t> salt(saltSize);
    GenerateRandomBytes(salt.data(), salt.size());
    return salt;
}

//////////////////////////////////////Second Position

//To Encryption First TAG
std::vector<uint8_t> CryptoUtils::sha256(const std::vector<uint8_t>& data) {
    //initial State to hash code [2,3,5,7,11,13,17,19]
    uint32_t h[8] = {
        0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,
        0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19
    };

    size_t originalLen = data.size();
    size_t paddedLen = ((originalLen + 9 + 63) / 64) * 64;// 1 byte for 0x80, 8 bytes for length

    std::vector<uint8_t> padded(paddedLen, 0);
    std::copy(data.begin(), data.end(), padded.begin()); //copy Data in padded
    padded[originalLen] = 0x80; //Save this code in Last Array before Length to mean it is Last Data

    //Save Length in Last Array
    uint64_t bitLen = static_cast<uint64_t>(originalLen) * 8;//Convert Byte to Bits
    for (int i = 0; i < 8; ++i) {
        padded[paddedLen - 1 - i] = static_cast<uint8_t>((bitLen >> (8 * i)) & 0xff);
    }

    //blender Code
    for (size_t i = 0; i < padded.size(); i += 64) {
        uint32_t w[64] = {};
        for (int j = 0; j < 16; ++j) { //Convert bytes from padded to Bits to w (4 bytes = 32 bits)
            w[j] = (padded[i + 4 * j] << 24) |
                (padded[i + 4 * j + 1] << 16) |
                (padded[i + 4 * j + 2] << 8) |
                (padded[i + 4 * j + 3]);
        }

        for (int j = 16; j < 64; ++j) {
            w[j] = sig1(w[j - 2]) + w[j - 7] + sig0(w[j - 15]) + w[j - 16];
        }

        uint32_t a = h[0], b = h[1], c = h[2], d = h[3];
        uint32_t e = h[4], f = h[5], g = h[6], hval = h[7];

        for (int j = 0; j < 64; ++j) {
            uint32_t temp1 = hval + ep1(e) + ch(e, f, g) + k[j] + w[j];
            uint32_t temp2 = ep0(a) + maj(a, b, c);
            hval = g;
            g = f;
            f = e;
            e = d + temp1;
            d = c;
            c = b;
            b = a;
            a = temp1 + temp2;
        }

        h[0] += a; h[1] += b; h[2] += c; h[3] += d;
        h[4] += e; h[5] += f; h[6] += g; h[7] += hval;
    }

    //Convert Hashing To Bytes
    std::vector<uint8_t> hash(32);
    for (int i = 0; i < 8; ++i) {
        hash[i * 4 + 0] = (h[i] >> 24) & 0xff;
        hash[i * 4 + 1] = (h[i] >> 16) & 0xff;
        hash[i * 4 + 2] = (h[i] >> 8) & 0xff;
        hash[i * 4 + 3] = h[i] & 0xff;
    }

    return hash;
}

//To Merge Password && Salt
std::vector<uint8_t> CryptoUtils::DeriveKey(const std::string& password, const std::vector<uint8_t>& salt, int iterations) {
    if (iterations < 10000) {
        throw std::invalid_argument("Iteration count must be at least 10000");
    }
    if (salt.empty()) {
        throw std::invalid_argument("Salt must not be empty");
    }

    std::vector<uint8_t> key(keySize, 0);
    std::vector<uint8_t> inputBlock;
    inputBlock.reserve(password.size() + salt.size());
    inputBlock.assign(password.begin(), password.end());
    inputBlock.insert(inputBlock.end(), salt.begin(), salt.end());

    for (int i = 0; i < iterations; ++i) {
        auto hash = sha256(inputBlock);

        for (size_t j = 0; j < key.size(); ++j) {
            key[j] ^= hash[j % hash.size()];
        }

        inputBlock = std::move(hash);

    }

    // Clear sensitive temp memory
    std::fill(inputBlock.begin(), inputBlock.end(), 0);

    return key;
}

//////////////////////////////////////Third Position

//Convert Bits to Bytes
uint32_t CryptoUtils::Load32(const uint8_t* src) {
    return ((uint32_t)src[0]) |
        ((uint32_t)src[1] << 8) |
        ((uint32_t)src[2] << 16) |
        ((uint32_t)src[3] << 24);
}

//Initialize Chacha20 Settings
void CryptoUtils::SetupChaChaState(uint32_t state[16], const std::vector<uint8_t>& key, const std::vector<uint8_t>& nonce, uint32_t counter) {
    state[0] = chachaConstants[0];
    state[1] = chachaConstants[1];
    state[2] = chachaConstants[2];
    state[3] = chachaConstants[3];

    for (int i = 0; i < 8; ++i)
        state[4 + i] = Load32(key.data() + (i * 4));

    state[12] = counter;
    for (int i = 0; i < 3; ++i)
        state[13 + i] = Load32(nonce.data() + (i * 4));
}

// Apply the ChaCha20 algorithm to a single block
void CryptoUtils::ChaCha20Block(uint32_t out[16], const uint32_t in[16]) {
    uint32_t x[16];
    std::copy(in, in + 16, x);

    // Lambda function for quarter round
    auto quarterRound = [](uint32_t& a, uint32_t& b, uint32_t& c, uint32_t& d) {
        a += b; d ^= a; d = RotateLeft(d, 16);
        c += d; b ^= c; b = RotateLeft(b, 12);
        a += b; d ^= a; d = RotateLeft(d, 8);
        c += d; b ^= c; b = RotateLeft(b, 7);
        };

    for (int i = 0; i < 10; ++i) {
        // Column rounds
        quarterRound(x[0], x[4], x[8], x[12]);
        quarterRound(x[1], x[5], x[9], x[13]);
        quarterRound(x[2], x[6], x[10], x[14]);
        quarterRound(x[3], x[7], x[11], x[15]);

        // Diagonal rounds
        quarterRound(x[0], x[5], x[10], x[15]);
        quarterRound(x[1], x[6], x[11], x[12]);
        quarterRound(x[2], x[7], x[8], x[13]);
        quarterRound(x[3], x[4], x[9], x[14]);
    }

    for (int i = 0; i < 16; ++i) {
        out[i] = x[i] + in[i];
    }
}

// Apply XOR to two blocks
void CryptoUtils::XORBlocks(const uint8_t* a, const uint8_t* b, uint8_t* out, size_t len) {
    size_t i = 0;

#if defined(__AVX2__)
    constexpr size_t simd_size = 32;
    for (; i + simd_size <= len; i += simd_size) {
        __m256i va = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(a + i));
        __m256i vb = _mm256_loadu_si256(reinterpret_cast<const __m256i*>(b + i));
        __m256i vres = _mm256_xor_si256(va, vb);
        _mm256_storeu_si256(reinterpret_cast<__m256i*>(out + i), vres);
    }
#elif defined(__SSE2__)
    constexpr size_t simd_size = 16;
    for (; i + simd_size <= len; i += simd_size) {
        __m128i va = _mm_loadu_si128(reinterpret_cast<const __m128i*>(a + i));
        __m128i vb = _mm_loadu_si128(reinterpret_cast<const __m128i*>(b + i));
        __m128i vres = _mm_xor_si128(va, vb);
        _mm_storeu_si128(reinterpret_cast<__m128i*>(out + i), vres);
    }
#endif

    // Process 64-bit if enough data is found
    for (; i + 8 <= len; i += 8) {
        uint64_t va, vb;
        std::memcpy(&va, a + i, 8);
        std::memcpy(&vb, b + i, 8);
        uint64_t vr = va ^ vb;
        std::memcpy(out + i, &vr, 8);
    }

    // Process the remainder byte by byte
    for (; i < len; ++i) {
        out[i] = a[i] ^ b[i];
    }
}

// Generate a Poly1305 key
void CryptoUtils::HChaCha20(const uint8_t key[32], const uint8_t nonce[16], uint8_t out[32]) {
    uint32_t state[16] = {
        chachaConstants[0], chachaConstants[1],
        chachaConstants[2], chachaConstants[3],
        Load32(key + 0),
        Load32(key + 4),
        Load32(key + 8),
        Load32(key + 12),
        Load32(key + 16),
        Load32(key + 20),
        Load32(key + 24),
        Load32(key + 28),
        Load32(nonce + 0),
        Load32(nonce + 4),
        Load32(nonce + 8),
        Load32(nonce + 12)
    };

    uint32_t result[16];
    ChaCha20Block(result, state);

    std::copy(reinterpret_cast<uint8_t*>(result),
        reinterpret_cast<uint8_t*>(result) + 32,
        out);
}

// Poly1305 authentication account
void CryptoUtils::Poly1305Mac(const uint8_t* message, size_t length, const uint8_t key[32], uint8_t tag[16]) {
    uint32_t r[5] = {}, h[5] = {}, s[4];
    uint64_t d;

    // Prepare the key
    r[0] = Load32(key + 0) & 0x0fffffff;
    r[1] = Load32(key + 4) & 0x0ffffffc;
    r[2] = Load32(key + 8) & 0x0ffffffc;
    r[3] = Load32(key + 12) & 0x0ffffffc;
    s[0] = Load32(key + 16);
    s[1] = Load32(key + 20);
    s[2] = Load32(key + 24);
    s[3] = Load32(key + 28);

    // Processing the message
    size_t i = 0;
    while (length > 0) {
        uint32_t c[5] = {};
        size_t blockSize = (length < 16) ? length : 16;

        for (size_t j = 0; j < blockSize; ++j) {
            c[j / 4] |= message[i + j] << (8 * (j % 4));
        }
        c[blockSize / 4] |= 1 << (8 * (blockSize % 4));
        i += blockSize;
        length -= blockSize;

        // Apply the algorithm
        for (int j = 0; j < 5; ++j) h[j] += c[j];
        for (int j = 0; j < 5; ++j) {
            d = 0;
            for (int k = 0; k < 5; ++k) {
                d += (uint64_t)h[k] * (j <= k ? r[k - j] : 5 * r[k + 5 - j]);
            }
            h[j] = d & 0xffffffff;
        }
        d = h[0] >> 26; h[0] &= 0x3ffffff;
        for (int j = 1; j < 5; ++j) {
            h[j] += d;
            d = h[j] >> 26;
            h[j] &= 0x3ffffff;
        }
        h[0] += d * 5;
    }

    // Final normalization
    d = h[0] + 5;
    uint32_t g[5];
    g[0] = d & 0xffffffff;
    for (int j = 1; j < 5; ++j) {
        g[j] = h[j] + (d >> 32);
        d = g[j];
    }
    d = (g[4] >> 22) | ((uint64_t)(g[4] & 0x3fffff) << 10);
    d = (d - 1) >> 63;
    for (int j = 0; j < 5; ++j) g[j] &= ~d;
    for (int j = 0; j < 5; ++j) h[j] = (h[j] & d) | (g[j] & ~d);

    // Add the key
    uint32_t f0 = h[0] + s[0];
    uint32_t f1 = h[1] + s[1] + (f0 >> 26); f0 &= 0x3ffffff;
    uint32_t f2 = h[2] + s[2] + (f1 >> 26); f1 &= 0x3ffffff;
    uint32_t f3 = h[3] + s[3] + (f2 >> 26); f2 &= 0x3ffffff;
    uint32_t f4 = h[4] + (f3 >> 26); f3 &= 0x3ffffff;

    // Final output
    *(uint32_t*)(tag + 0) = f0 | (f1 << 26);
    *(uint32_t*)(tag + 4) = (f1 >> 6) | (f2 << 20);
    *(uint32_t*)(tag + 8) = (f2 >> 12) | (f3 << 14);
    *(uint32_t*)(tag + 12) = (f3 >> 18) | (f4 << 8);
}

//Encryption Data
std::vector<uint8_t> CryptoUtils::Encrypt(const std::vector<uint8_t>& plaintext, const std::vector<uint8_t>& key, const std::vector<uint8_t>& nonce)
{
    if (key.size() != keySize) {
        throw std::runtime_error("Invalid key size");
    }
    if (nonce.size() != nonceSize) {
        throw std::runtime_error("Invalid nonce size");
    }

    std::vector<uint8_t> ciphertext(plaintext.size() + tagSize);

    // 1. ChaCha20 encryption
    uint32_t counter = 1;
    uint32_t state[16];
    SetupChaChaState(state, key, nonce, 1);


    size_t bytesProcessed = 0;
    while (bytesProcessed < plaintext.size()) {
        uint32_t block[16];
        ChaCha20Block(block, state);

        size_t blockSize = std::min<size_t>(64, plaintext.size() - bytesProcessed);
        XORBlocks(plaintext.data() + bytesProcessed,
            reinterpret_cast<uint8_t*>(block),
            ciphertext.data() + bytesProcessed,
            blockSize);

        bytesProcessed += blockSize;
        state[12]++; // Increment the counter
    }

    // 2. Generate a Poly1305 key
    uint8_t polyKey[32];
    HChaCha20(key.data(), nonce.data(), polyKey);

    // 3. Data Authentication Account
    Poly1305Mac(ciphertext.data(), plaintext.size(), polyKey, ciphertext.data() + plaintext.size());

    return ciphertext;
}

//Decreption Data
std::vector<uint8_t> CryptoUtils::Decrypt(const std::vector<uint8_t>& ciphertext, const std::vector<uint8_t>& key, const std::vector<uint8_t>& nonce)
{
    if (ciphertext.size() < tagSize) {
        throw std::runtime_error("Invalid ciphertext size");
    }

    const uint8_t* encryptedData = ciphertext.data();
    size_t dataSize = ciphertext.size() - tagSize;

    // Data validation
    uint8_t polyKey[32];
    HChaCha20(key.data(), nonce.data(), polyKey);

    uint8_t calculatedTag[tagSize];
    Poly1305Mac(encryptedData, dataSize, polyKey, calculatedTag);

    if (!std::equal(calculatedTag, calculatedTag + tagSize,
        encryptedData + dataSize)) {
        throw std::runtime_error("Authentication failed");
    }

    // Decryption
    std::vector<uint8_t> plaintext(dataSize);

    uint32_t counter = 1;
    uint32_t state[16];
    SetupChaChaState(state, key, nonce, 1);

    size_t bytesProcessed = 0;
    while (bytesProcessed < dataSize) {
        uint32_t block[16];
        ChaCha20Block(block, state);

        size_t blockSize = std::min<size_t>(64, dataSize - bytesProcessed);
        XORBlocks(encryptedData + bytesProcessed,
            reinterpret_cast<uint8_t*>(block),
            plaintext.data() + bytesProcessed,
            blockSize);

        bytesProcessed += blockSize;
        state[12]++; // Increment the counter
    }

    return plaintext;
}

//////////////////////////////////Run Code

std::vector<uint8_t> CryptoUtils::EncryptWithSalt(const std::vector<uint8_t>& plaintext, const std::string& password)
{

    // 1. Generate random salt
    std::vector<uint8_t> salt = GenerateSalt();

    // 2. Generate a random nonce
    std::vector<uint8_t> nonce = GenerateNonce();

    // 3. Deriving the key
    auto key = DeriveKey(password, salt);

    // 4. Data encryption
    auto ciphertext = Encrypt(plaintext, key, nonce);

    // 5. Merge salt and nonce with the output
    std::vector<uint8_t> result;
    result.reserve(salt.size() + nonce.size() + ciphertext.size());
    result.insert(result.end(), salt.begin(), salt.end());
    result.insert(result.end(), nonce.begin(), nonce.end());
    result.insert(result.end(), ciphertext.begin(), ciphertext.end());

    return result;
}

std::vector<uint8_t> CryptoUtils::DecryptWithSalt(const std::vector<uint8_t>& fullData, const std::string& password)
{

    if (fullData.size() < saltSize + nonceSize + tagSize) {
        throw std::runtime_error("Invalid data size for decryption");
    }

    std::vector<uint8_t> salt(fullData.begin(), fullData.begin() + saltSize);
    auto key = DeriveKey(password, salt);

    std::vector<uint8_t> nonce(
        fullData.begin() + saltSize,
        fullData.begin() + saltSize + nonceSize);

    std::vector<uint8_t> encryptedDataWithTag(
        fullData.begin() + tagSize + nonceSize,
        fullData.end());

    return Decrypt(encryptedDataWithTag, key, nonce);
}
------------------------------
VirtualDisk.h
------------------------------
#ifndef VIRTUALDISK_H
#define VIRTUALDISK_H

#include <vector>
#include <string>
#include <stdexcept>
#include <iomanip>
#include <cstdint>
#include <memory>
#include <mutex>
#include <algorithm>
#include <iostream>
#include "CryptoUtils.h"

#ifdef _WIN32
#include <windows.h>
#include <io.h>

#elif __linux__
#include <unistd.h>
#include <sys/sysinfo.h>
#include <sys/mman.h>

#else
#include <fsteram>

#endif

class VirtualDisk {
public:

    class VirtualDiskException : public std::runtime_error {
    public:
        using std::runtime_error::runtime_error;
    };

    //Error Space
    class DiskFullException : public VirtualDiskException {
    public:
        DiskFullException() : VirtualDiskException("Insufficient disk space") {}
    };

    //Error in Data
    class CorruptedDiskException : public VirtualDiskException {
    public:
        CorruptedDiskException() : VirtualDiskException("Disk corruption detected") {}
    };

    //Cluster (Blocks)
    struct Extent {
        uint32_t startBlock;
        uint32_t blockCount;
        Extent(uint32_t start = 0, uint32_t count = 0)
            : startBlock(start), blockCount(count) {}
        uint32_t size(uint32_t blockSize) const {
            return blockCount * blockSize;
        }
    };

    //Size Cluster (1 Block)
    uint32_t blockSize;

    static constexpr uint32_t extraSystemBlocks = 2; // ++Block in Initialize

    static const uint32_t toleranceBlocks = 4;

    static const uint32_t defaultSizeDisk = 50;

    int superBlockBlocks;

    size_t diskSize;

    //Contractors
    VirtualDisk(int superBlock, uint32_t BlockSize);
    ~VirtualDisk();

    // Disk management
    void Initialize(const std::string& path, uint64_t diskSizeMB = defaultSizeDisk);
    bool IsNew() { return isNewDisk; }
    void Close();

    // Block management
    uint32_t getSystemBlocks() const { return systemBlock; }
    Extent allocateBlocks(uint32_t blocksNeeded);
    void freeBlocks(const Extent& extent);
    size_t totalBlocks() { return blockBitmap.size(); }
    uint64_t freeBlocksCount();
    void createNewDisk(uint64_t totalBlocks);
    void loadExistingDisk(uint64_t expectedBlocks);
    std::vector<bool> getBitmap();
    void setBitmap(int index, bool state);


    // Data operations
    bool writeData(const std::vector<char>& data, const Extent& extent, const std::string& password = "", bool flushImmediately = false);
    std::vector<char> readData(const Extent& extent, const std::string& password = "");

    // Maintenance
    void printBitmap();

    // Helper functions
    bool ensureOpen();
    void syncToDisk();

    //Get Available Memory 
    size_t getAvailableMemory();

    //To Change Color
    enum ConsoleColor {
        Default,
        Red,
        Green,
        Blue,
        Yellow,
        Cyan,
        Magenta,
        White,
        Gray
    };

    void SetConsoleColor(ConsoleColor color);


private:

#ifdef _WIN32
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
#elif __linux__
    int fileDescriptor = -1;
#else
    std::fstream diskFile;
#endif

    //Number of System Blocks
    bool isNewDisk;
    uint32_t systemBlock;
    std::string diskPath; //Disk Name
    std::vector<bool> blockBitmap; //Block Map List
    std::recursive_mutex diskMutex;

    // Helper functions
    void loadBitmap();
    size_t determineSmartBufferSize();
    void saveBitmap(bool forceFlush = false);
    uint32_t findContiguousBlocks(uint32_t count);
};

#endif // VIRTUALDISK_H
------------------------------
VirtualDisk.cpp
------------------------------
#include "VirtualDisk.h"

//Contractor
VirtualDisk::VirtualDisk(int superblock, uint32_t blockSize) : systemBlock(0), diskSize(0), superBlockBlocks(superblock), blockSize(blockSize), isNewDisk(false) {

}

//Destructor
VirtualDisk::~VirtualDisk() {
    Close();
}

//Ensure everything you want is preserved on the virtual disk
void VirtualDisk::syncToDisk() {
    std::lock_guard<std::recursive_mutex> lock(diskMutex);
    if (!ensureOpen()) return;

#ifdef _WIN32
    if (!FlushFileBuffers(fileHandle)) {
        DWORD errorCode = GetLastError();
        throw VirtualDiskException("Failed to sync disk (Windows error: " +
            std::to_string(errorCode) + ")");
    }

#elif __linux__
    if (fsync(fileDescriptor) != 0) {
        throw VirtualDiskException("Failed to sync disk: " + std::string(strerror(errno)));
    }

#else
    // C++ standard implementation
    diskFile.flush();
    if (!diskFile.good()) {
        throw VirtualDiskException("Failed to flush disk stream");
    }

#endif
}

//Initialize Disk
void VirtualDisk::Initialize(const std::string& path, uint64_t diskSizeMB) {
    std::lock_guard<std::recursive_mutex> lock(diskMutex);
    try {
        diskPath = path;
        diskSizeMB = (diskSizeMB < 1) ? VirtualDisk::defaultSizeDisk : diskSizeMB;
        VirtualDisk::diskSize = diskSizeMB;
        const uint64_t totalBlocks = (diskSizeMB * 1024 * 1024) / blockSize;
        if (totalBlocks == 0) {
            throw VirtualDiskException("Invalid disk size - too small");
        }

        blockBitmap.clear();
        blockBitmap.resize(totalBlocks, false);

        systemBlock = static_cast<uint32_t>(std::min<uint64_t>(
            static_cast<uint64_t>(ceil((totalBlocks / 8.0) / blockSize) + extraSystemBlocks),
            totalBlocks
        ));


#ifdef _WIN32
        //HANDLE hFile
        fileHandle = CreateFileA(path.c_str(), GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        bool exists = (fileHandle != INVALID_HANDLE_VALUE);
        if (exists) CloseHandle(fileHandle);

#elif __linux__

        fileDescriptor = open(path.c_str(), O_RDWR);
        bool exists = (fileDescriptor >= 0);
        if (exists) close(fileDescriptor);

#else
        // C++ standard implementation
        std::fstream testFile(path, std::ios::in | std::ios::binary);
        bool exists = testFile.is_open();
        if (exists) testFile.close();

#endif

        if (exists) {
            loadExistingDisk(totalBlocks);
        }
        else {
            createNewDisk(totalBlocks);
        }
    }
    catch (const std::exception& e) {
        std::cout << e.what() << std::endl;
        throw VirtualDiskException(e.what());
    }
}

//Setup Buffer Size
size_t VirtualDisk::determineSmartBufferSize() {
    size_t bufferSize = 64 * 1024; // default: 64KB

#ifdef _WIN32
    MEMORYSTATUSEX memStatus;
    memStatus.dwLength = sizeof(memStatus);
    if (GlobalMemoryStatusEx(&memStatus)) {
        DWORDLONG availPhys = memStatus.ullAvailPhys;

        if (availPhys > 8ULL * 1024 * 1024 * 1024)      bufferSize = 2 * 1024 * 1024;  // 2MB
        else if (availPhys > 4ULL * 1024 * 1024 * 1024) bufferSize = 1 * 1024 * 1024;  // 1MB
        else if (availPhys > 1ULL * 1024 * 1024 * 1024) bufferSize = 512 * 1024;       // 512KB
        else                                            bufferSize = 128 * 1024;       // 128KB
    }
    else {
        std::cerr << "Warning: Failed to get memory status, using default buffer size\n";
    }
#elif __linux__
    struct sysinfo memInfo;
    if (sysinfo(&memInfo) == 0) {
        unsigned long long availPhys = memInfo.freeram;
        availPhys *= memInfo.mem_unit;

        if (availPhys > 8ULL * 1024 * 1024 * 1024)      bufferSize = 2 * 1024 * 1024;  // 2MB
        else if (availPhys > 4ULL * 1024 * 1024 * 1024) bufferSize = 1 * 1024 * 1024;  // 1MB
        else if (availPhys > 1ULL * 1024 * 1024 * 1024) bufferSize = 512 * 1024;       // 512KB
        else                                            bufferSize = 128 * 1024;       // 128KB
    }
    else {
        std::cerr << "Warning: Failed to get system info, using default buffer size\n";
    }
#else
    // Fallback for other systems
    try {
        // Try to estimate available memory by allocating progressively larger blocks
        size_t testSize = 128 * 1024; // Start with 128KB
        while (testSize <= 8 * 1024 * 1024) { // Up to 8MB
            try {
                std::vector<char> testBuffer(testSize);
                bufferSize = testSize;
                testSize *= 2; // Try next size
            }
            catch (const std::bad_alloc&) {
                break; // Stop if allocation fails
            }
        }
        std::cerr << "Info: Determined buffer size empirically: "
            << bufferSize / 1024 << "KB\n";
    }
    catch (...) {
        std::cerr << "Warning: Memory test failed, using default buffer size\n";
    }
#endif

    // Ensure buffer size is within reasonable limits
    constexpr size_t minBufferSize = 16 * 1024;  // 16KB minimum
    constexpr size_t maxBufferSize = 8 * 1024 * 1024; // 8MB maximum

    bufferSize = (bufferSize < minBufferSize) ? minBufferSize :
        (bufferSize > maxBufferSize) ? maxBufferSize : bufferSize;

    return bufferSize;
}

//Create New Disk
void VirtualDisk::createNewDisk(uint64_t totalBlocks) {
    const size_t BUFFER_SIZE = determineSmartBufferSize();
    std::vector<char> buffer(BUFFER_SIZE, 0);
    uint64_t remaining = totalBlocks * blockSize;

#ifdef _WIN32
    fileHandle = CreateFileA(diskPath.c_str(), GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        throw VirtualDiskException("Failed to create new disk file");
    }

    while (remaining > 0) {
        DWORD chunk = static_cast<DWORD>(std::min<size_t>(BUFFER_SIZE, remaining));
        DWORD written;
        if (!WriteFile(fileHandle, buffer.data(), chunk, &written, NULL) || written != chunk) {
            CloseHandle(fileHandle);
            fileHandle = INVALID_HANDLE_VALUE;
            throw VirtualDiskException("Failed to write to disk");
        }
        remaining -= chunk;
    }

    FlushFileBuffers(fileHandle);
#elif __linux__
    fileDescriptor = open(diskPath.c_str(), O_CREAT | O_RDWR | O_TRUNC | O_SYNC, 0644);
    if (fileDescriptor < 0) {
        throw VirtualDiskException("Failed to create new disk file");
    }

    while (remaining > 0) {
        size_t chunk = std::min(BUFFER_SIZE, remaining);
        if (write(fileDescriptor, buffer.data(), chunk) != (ssize_t)chunk) {
            close(fileDescriptor);
            fileDescriptor = -1;
            throw VirtualDiskException("Failed to write to disk");
        }
        remaining -= chunk;
    }

    fsync(fileDescriptor);
#else
    // C++ standard implementation
    diskFile.open(diskPath, std::ios::out | std::ios::binary);
    if (!diskFile.is_open()) {
        throw VirtualDiskException("Failed to create new disk file");
    }

    while (remaining > 0) {
        size_t chunk = std::min(BUFFER_SIZE, remaining);
        diskFile.write(buffer.data(), chunk);
        if (!diskFile.good()) {
            diskFile.close();
            throw VirtualDiskException("Failed to write to disk");
        }
        remaining -= chunk;
    }

    diskFile.flush();
    diskFile.close();
#endif

    std::fill_n(blockBitmap.begin(), systemBlock + superBlockBlocks, true);
    saveBitmap(true);
    isNewDisk = true;
}

//Load Disk
void VirtualDisk::loadExistingDisk(uint64_t expectedBlocks) {
#ifdef _WIN32
    fileHandle = CreateFileA(diskPath.c_str(), GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, NULL);
    if (!ensureOpen()) {
        throw VirtualDiskException("Failed to open disk file");
    }
#elif __linux__
    fileDescriptor = open(diskPath.c_str(), O_RDWR);
    if (fileDescriptor < 0) {
        throw VirtualDiskException("Failed to open disk file");
    }
#else
    // C++ standard implementation
    diskFile.open(diskPath, std::ios::in | std::ios::out | std::ios::binary);
    if (!diskFile.is_open()) {
        throw VirtualDiskException("Failed to open disk file");
    }
#endif

    loadBitmap();
    isNewDisk = false;
}

//Use Blocks and Mark it
VirtualDisk::Extent VirtualDisk::allocateBlocks(uint32_t blocksNeeded) {
    std::lock_guard<std::recursive_mutex> lock(diskMutex);

    if (freeBlocksCount() < blocksNeeded) {
        throw DiskFullException();
    }

    if (blocksNeeded == 0) {
        throw std::invalid_argument("Block count cannot be zero");
    }

    int totalBlocks = static_cast<int>(blockBitmap.size());
    int start = -1;
    int count = 0;

    for (int currentBlock = systemBlock; currentBlock < totalBlocks; ++currentBlock) {
        if (!blockBitmap[currentBlock]) {
            if (start == -1)
                start = currentBlock;
            count++;

            if (count == blocksNeeded) {
                for (int j = start; j < start + static_cast<int>(blocksNeeded); ++j)
                    blockBitmap[j] = true;

                return Extent(start, blocksNeeded);
            }
        }
        else {
            start = -1;
            count = 0;
        }
    }

    throw DiskFullException();
}

//Get Bit Map
std::vector<bool> VirtualDisk::getBitmap()
{
    return blockBitmap;
}

//Set Status Bit Map
void VirtualDisk::setBitmap(int index, bool state)
{
    blockBitmap[index] = state;
}

//Free Blocks Was Used
void VirtualDisk::freeBlocks(const Extent& extent) {
    std::lock_guard<std::recursive_mutex> lock(diskMutex);
    ensureOpen();

    if (extent.startBlock + extent.blockCount > blockBitmap.size() && extent.startBlock != -1) {
        throw std::out_of_range("Extent exceeds disk bounds");
    }
    if (extent.startBlock != -1)
        std::fill_n(blockBitmap.begin() + extent.startBlock, extent.blockCount, false);
    saveBitmap(true);  // Force flush after freeing blocks
}

//Get Total Blocks Free Count
uint64_t VirtualDisk::freeBlocksCount() {
    std::lock_guard<std::recursive_mutex> lock(diskMutex);
    ensureOpen();
    return static_cast<uint64_t>(std::count(blockBitmap.begin(), blockBitmap.end(), false));
}

//Write in Disk
bool VirtualDisk::writeData(const std::vector<char>& data, const Extent& extent, const std::string& password, bool flushImmediately) {
    std::lock_guard<std::recursive_mutex> lock(diskMutex);
    if (!ensureOpen()) return false;

    std::vector<uint8_t> finalData;

    if (password.empty()) {
        finalData.assign(data.begin(), data.end());
    }
    else {
        uint32_t originalSize = static_cast<uint32_t>(data.size());
        std::vector<uint8_t> fullData(sizeof(uint32_t) + data.size());
        std::memcpy(fullData.data(), &originalSize, sizeof(uint32_t));
        std::memcpy(fullData.data() + sizeof(uint32_t), data.data(), data.size());

        auto encrypted = CryptoUtils::EncryptWithSalt(fullData, password);

        uint32_t encryptedSize = static_cast<uint32_t>(encrypted.size());
        finalData.resize(sizeof(uint32_t) + encryptedSize);
        std::memcpy(finalData.data(), &encryptedSize, sizeof(uint32_t));
        std::memcpy(finalData.data() + sizeof(uint32_t), encrypted.data(), encryptedSize);
    }

    size_t totalBlockSize = extent.blockCount * blockSize;
    if (finalData.size() > totalBlockSize) return false;
    finalData.resize(totalBlockSize, 0);

#ifdef _WIN32
    LARGE_INTEGER offset;
    offset.QuadPart = static_cast<LONGLONG>(extent.startBlock) * blockSize;
    SetFilePointerEx(fileHandle, offset, NULL, FILE_BEGIN);
    DWORD written;
    BOOL result = WriteFile(fileHandle, finalData.data(), (DWORD)finalData.size(), &written, NULL);
    if (flushImmediately) FlushFileBuffers(fileHandle);
    return result && written == finalData.size();
#elif __linux__
    off_t offset = static_cast<off_t>(extent.startBlock) * blockSize;
    if (lseek(fileDescriptor, offset, SEEK_SET) == -1) {
        return false;
    }
    ssize_t written = write(fileDescriptor, finalData.data(), finalData.size());
    if (flushImmediately) fsync(fileDescriptor);
    return written == (ssize_t)finalData.size();
#else
    // C++ standard implementation
    diskFile.seekp(extent.startBlock * blockSize);
    diskFile.write(reinterpret_cast<const char*>(finalData.data()), finalData.size());
    if (flushImmediately) {
        diskFile.flush();
    }
    return diskFile.good();
#endif
}

//Read From Disk
std::vector<char> VirtualDisk::readData(const Extent& extent, const std::string& password) {
    std::lock_guard<std::recursive_mutex> lock(diskMutex);
    if (!ensureOpen()) return {};
    std::vector<char> buffer(extent.blockCount * blockSize);

#ifdef _WIN32
    LARGE_INTEGER offset;
    offset.QuadPart = static_cast<LONGLONG>(extent.startBlock) * blockSize;
    SetFilePointerEx(fileHandle, offset, NULL, FILE_BEGIN);
    DWORD bytesRead;
    BOOL result = ReadFile(fileHandle, buffer.data(), (DWORD)buffer.size(), &bytesRead, NULL);
    if (!result || bytesRead == 0) return {};
#elif __linux__
    off_t offset = static_cast<off_t>(extent.startBlock) * blockSize;
    if (lseek(fileDescriptor, offset, SEEK_SET) == -1) {
        return {};
    }
    ssize_t bytesRead = read(fileDescriptor, buffer.data(), buffer.size());
    if (bytesRead <= 0) return {};
#else
    // C++ standard implementation
    diskFile.seekg(extent.startBlock * blockSize);
    diskFile.read(buffer.data(), buffer.size());
    if (diskFile.gcount() <= 0) {
        return {};
    }
#endif

    if (password.empty()) {
        size_t actualSize = buffer.size();
        while (actualSize > 0 && buffer[actualSize - 1] == 0) {
            --actualSize;
        }
        buffer.resize(actualSize);
        return buffer;
    }

    if (buffer.size() < sizeof(uint32_t)) return {};
    uint32_t encryptedSize;
    std::memcpy(&encryptedSize, buffer.data(), sizeof(uint32_t));
    if (encryptedSize == 0 || encryptedSize + sizeof(uint32_t) > buffer.size()) return {};

    std::vector<uint8_t> encryptedBytes(buffer.begin() + sizeof(uint32_t), buffer.begin() + sizeof(uint32_t) + encryptedSize);
    std::vector<uint8_t> decryptedBytes;
    try {
        decryptedBytes = CryptoUtils::DecryptWithSalt(encryptedBytes, password);
    }
    catch (...) {
        return {};
    }

    if (decryptedBytes.size() < sizeof(uint32_t)) return {};
    uint32_t originalSize;
    std::memcpy(&originalSize, decryptedBytes.data(), sizeof(uint32_t));
    if (originalSize + sizeof(uint32_t) > decryptedBytes.size()) return {};

    return std::vector<char>(decryptedBytes.begin() + sizeof(uint32_t), decryptedBytes.begin() + sizeof(uint32_t) + originalSize);
}

//Close Disk
void VirtualDisk::Close() {
    std::lock_guard<std::recursive_mutex> lock(diskMutex);
#ifdef _WIN32
    if (fileHandle != INVALID_HANDLE_VALUE) {
        try {
            saveBitmap(true);
            FlushFileBuffers(fileHandle);
            CloseHandle(fileHandle);
            fileHandle = INVALID_HANDLE_VALUE;
        }
        catch (...) {
            if (fileHandle != INVALID_HANDLE_VALUE) {
                CloseHandle(fileHandle);
                fileHandle = INVALID_HANDLE_VALUE;
            }
            throw;
        }
    }
#elif __linux__
    if (fileDescriptor >= 0) {
        try {
            saveBitmap(true);
            fsync(fileDescriptor);
            close(fileDescriptor);
            fileDescriptor = -1;
        }
        catch (...) {
            if (fileDescriptor >= 0) {
                close(fileDescriptor);
                fileDescriptor = -1;
            }
            throw;
        }
    }
#else
    if (diskFile.is_open()) {
        try {
            saveBitmap(true);
            diskFile.flush();
            diskFile.close();
        }
        catch (...) {
            if (diskFile.is_open()) {
                diskFile.close();
            }
            throw;
        }
    }
#endif
}

//Print Bit Map Status
void VirtualDisk::printBitmap() {
    std::lock_guard<std::recursive_mutex> lock(diskMutex);
    ensureOpen();

    const size_t blocksPerRow = 32;
    const size_t totalBlocks = blockBitmap.size();
    const size_t usedBlocks = totalBlocks - freeBlocksCount();
    const float usedPercent = (static_cast<float>(usedBlocks) / totalBlocks) * 100.0f;

    // Header with basic information
    std::cout << "\n";
    std::cout << "=========================================================\n";
    std::cout << "|              VIRTUAL DISK BITMAP                     |\n";
    std::cout << "=========================================================\n";
    std::cout << "| Total Blocks: " << std::setw(10) << totalBlocks
        << " | Free: " << std::setw(5) << freeBlocksCount()
        << " | Used: " << std::setw(6) << usedBlocks << " |\n";
    std::cout << "| Usage: " << std::setw(4) << std::fixed << std::setprecision(1)
        << usedPercent << "%"
        << std::string(42, ' ') << "|\n";
    std::cout << "| Legend: [ ] = Free, [X] = Used"
        << std::string(24, ' ') << "|\n";
    std::cout << "=========================================================\n\n";

    // Column headers
    std::cout << "Block  +";
    for (size_t col = 0; col < blocksPerRow; ++col) {
        std::cout << "--";
    }
    std::cout << "+\n";

    std::cout << "       |";
    for (size_t col = 0; col < blocksPerRow; ++col) {
        std::cout << std::setw(2) << col % 10; // Show only last digit for space
    }
    std::cout << "|\n";
    std::cout << "-------+";
    for (size_t col = 0; col < blocksPerRow; ++col) {
        std::cout << "--";
    }
    std::cout << "+\n";

    // Bitmap data
    for (size_t i = 0; i < totalBlocks; i++) {
        if (i % blocksPerRow == 0) {
            if (i != 0) {
                std::cout << "|\n";
            }
            std::cout << std::setw(6) << i << " |";
        }

        std::cout << (blockBitmap[i] ? "X " : "  ");
    }

    // Footer
    std::cout << "|\n";
    std::cout << "-------+";
    for (size_t col = 0; col < blocksPerRow; ++col) {
        std::cout << "--";
    }
    std::cout << "+\n";

    // Usage bar (ASCII art)
    std::cout << "\nUsage: [";
    const int barWidth = 50;
    int usedWidth = static_cast<int>((usedPercent / 100.0f) * barWidth);
    for (int i = 0; i < barWidth; i++) {
        std::cout << (i < usedWidth ? '#' : '-');
    }
    std::cout << "] " << std::fixed << std::setprecision(1) << usedPercent << "%\n";

    // Summary
    std::cout << "\n";
    std::cout << "====[ SUMMARY ]===================================\n";
    std::cout << "| Free Space: " << std::setw(10) << freeBlocksCount()
        << " blocks (" << std::setw(6)
        << std::fixed << std::setprecision(1)
        << (100.0f - usedPercent) << "% free)   |\n";
    std::cout << "| Used Space: " << std::setw(10) << usedBlocks
        << " blocks (" << std::setw(6)
        << std::fixed << std::setprecision(1)
        << usedPercent << "% used)   |\n";
    std::cout << "=================================================\n\n";
}

//Save BitMap Status in Disk
void VirtualDisk::saveBitmap(bool forceFlush) {
    std::lock_guard<std::recursive_mutex> lock(diskMutex);
    if (!ensureOpen()) return;

    size_t bitmapSize = blockBitmap.size();
    size_t byteSize = (bitmapSize + 7) / 8;
    size_t totalAvailableBytes = systemBlock * blockSize;

    if (byteSize > totalAvailableBytes) {
        std::cerr << "Error: SYSTEM_BLOCKS too small to hold bitmap.\n";
        return;
    }

    std::vector<char> bitmap(byteSize, 0);
    for (size_t i = 0; i < bitmapSize; ++i) {
        if (blockBitmap[i]) {
            bitmap[i / 8] |= (1 << (i % 8));
        }
    }

    size_t bytesRemaining = byteSize;
    size_t offset = 0;

    for (size_t block = 1; block < systemBlock && bytesRemaining > 0; ++block) {
        size_t chunkSize = (std::min)(static_cast<size_t>(blockSize), bytesRemaining);
        size_t blockOffset = block * blockSize;

#ifdef _WIN32
        LARGE_INTEGER li;
        li.QuadPart = static_cast<LONGLONG>(blockOffset);
        SetFilePointerEx(fileHandle, li, NULL, FILE_BEGIN);
        DWORD written;
        WriteFile(fileHandle, &bitmap[offset], (DWORD)chunkSize, &written, NULL);
        if (chunkSize < blockSize) {
            std::vector<char> padding(blockSize - chunkSize, 0);
            WriteFile(fileHandle, padding.data(), (DWORD)padding.size(), &written, NULL);
        }
#elif __linux__
        lseek(fileDescriptor, blockOffset, SEEK_SET);
        write(fileDescriptor, &bitmap[offset], chunkSize);
        if (chunkSize < blockSize) {
            std::vector<char> padding(blockSize - chunkSize, 0);
            write(fileDescriptor, padding.data(), padding.size());
        }
#else
        // C++ standard implementation
        diskFile.seekp(blockOffset);
        diskFile.write(&bitmap[offset], chunkSize);
        if (chunkSize < blockSize) {
            std::vector<char> padding(blockSize - chunkSize, 0);
            diskFile.write(padding.data(), padding.size());
        }
#endif

        offset += chunkSize;
        bytesRemaining -= chunkSize;
    }

    if (forceFlush) {
#ifdef _WIN32
        FlushFileBuffers(fileHandle);
#elif __linux__
        fsync(fileDescriptor);
#else
        diskFile.flush();
#endif
    }
}

//Load BitMap Status From Disk
void VirtualDisk::loadBitmap() {
    std::lock_guard<std::recursive_mutex> lock(diskMutex);
    if (!ensureOpen()) return;

    size_t bitmapSize = blockBitmap.size();
    size_t byteSize = (bitmapSize + 7) / 8;
    size_t totalAvailableBytes = systemBlock * blockSize;

    if (byteSize > totalAvailableBytes) {
        std::cerr << "Error: SYSTEM_BLOCKS too small to load bitmap.\n";
        return;
    }

    std::vector<char> bitmap(byteSize, 0);
    size_t bytesRemaining = byteSize;
    size_t offset = 0;

    for (size_t block = 1; block < systemBlock && bytesRemaining > 0; ++block) {
        size_t chunkSize = (std::min)(static_cast<size_t>(blockSize), bytesRemaining);
        size_t blockOffset = block * blockSize;

#ifdef _WIN32
        LARGE_INTEGER li;
        li.QuadPart = static_cast<LONGLONG>(blockOffset);
        SetFilePointerEx(fileHandle, li, NULL, FILE_BEGIN);
        DWORD readBytes;
        BOOL success = ReadFile(fileHandle, &bitmap[offset], (DWORD)chunkSize, &readBytes, NULL);
        if (!success || readBytes != chunkSize) {
            std::cerr << "Failed to read bitmap block at offset " << blockOffset << "\n";
            return;
        }
#elif __linux__
        lseek(fileDescriptor, blockOffset, SEEK_SET);
        ssize_t readBytes = read(fileDescriptor, &bitmap[offset], chunkSize);
        if (readBytes != (ssize_t)chunkSize) {
            std::cerr << "Failed to read bitmap block at offset " << blockOffset << "\n";
            return;
        }
#else
        // C++ standard implementation
        diskFile.seekg(blockOffset);
        diskFile.read(&bitmap[offset], chunkSize);
        if (diskFile.gcount() != (std::streamsize)chunkSize) {
            std::cerr << "Failed to read bitmap block at offset " << blockOffset << "\n";
            return;
        }
#endif

        offset += chunkSize;
        bytesRemaining -= chunkSize;
    }

    for (size_t i = 0; i < bitmapSize; ++i) {
        blockBitmap[i] = (bitmap[i / 8] >> (i % 8)) & 1;
    }
}

//Get Free Blocks
uint32_t VirtualDisk::findContiguousBlocks(uint32_t count) {
    if (count == 0) return UINT32_MAX;

    uint32_t currentStart = UINT32_MAX;
    uint32_t currentLength = 0;

    for (uint32_t i = 0; i < blockBitmap.size(); ++i) {
        if (!blockBitmap[i]) {
            if (currentLength == 0) {
                currentStart = i;
            }

            ++currentLength;

            if (currentLength == count) {
                return currentStart;
            }
        }
        else {
            currentLength = 0;
        }
    }

    return UINT32_MAX;
}

//Check if Disk is open or not
bool VirtualDisk::ensureOpen() {
#ifdef _WIN32
    if (fileHandle == INVALID_HANDLE_VALUE) {
        throw VirtualDiskException("Disk is not open (Windows fileHandle invalid)");
    }
    return fileHandle != INVALID_HANDLE_VALUE;
#elif __linux__
    if (fileDescriptor < 0) {
        throw VirtualDiskException("Disk is not open (Linux fileDescriptor invalid)");
    }
    return fileDescriptor >= 0;
#else
    if (!diskFile.is_open()) {
        throw VirtualDiskException("Disk is not open (C++ file stream not open)");
    }
    return diskFile.is_open();
#endif
}

//Get Available Memory (Cach Memory) 
size_t VirtualDisk::getAvailableMemory() {
#ifdef _WIN32
    MEMORYSTATUSEX status;
    status.dwLength = sizeof(status);
    GlobalMemoryStatusEx(&status);
    return status.ullAvailPhys; // Available memory now
#else
    struct sysinfo info;
    sysinfo(&info);
    return info.freeram * info.mem_unit; // free memory
#endif
}

//To Change Color Console
void VirtualDisk::SetConsoleColor(ConsoleColor color) {
#ifdef _WIN32
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    WORD attributes = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;

    switch (color) {
    case ConsoleColor::Red:     attributes = FOREGROUND_RED | FOREGROUND_INTENSITY; break;
    case ConsoleColor::Green:   attributes = FOREGROUND_GREEN | FOREGROUND_INTENSITY; break;
    case ConsoleColor::Blue:    attributes = FOREGROUND_BLUE | FOREGROUND_INTENSITY; break;
    case ConsoleColor::Yellow:  attributes = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY; break;
    case ConsoleColor::Cyan:    attributes = FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY; break;
    case ConsoleColor::Magenta: attributes = FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY; break;
    case ConsoleColor::White:   attributes = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY; break;
    case ConsoleColor::Gray:    attributes = FOREGROUND_INTENSITY; break;
    default: break;
    }

    SetConsoleTextAttribute(hConsole, attributes);
#else
    switch (color) {
    case ConsoleColor::Red:     std::cout << "\033[31m"; break;
    case ConsoleColor::Green:   std::cout << "\033[32m"; break;
    case ConsoleColor::Yellow:  std::cout << "\033[33m"; break;
    case ConsoleColor::Blue:    std::cout << "\033[34m"; break;
    case ConsoleColor::Magenta: std::cout << "\033[35m"; break;
    case ConsoleColor::Cyan:    std::cout << "\033[36m"; break;
    case ConsoleColor::White:   std::cout << "\033[37m"; break;
    case ConsoleColor::Gray:    std::cout << "\033[90m"; break;
    case ConsoleColor::Default: std::cout << "\033[0m"; break;
    }
#endif
}
------------------------------
MiniHSFS.h
------------------------------
#ifndef MINI_HSFS_H
#define MINI_HSFS_H

#include "VirtualDisk.h"
#include <unordered_map>
#include <unordered_set>
#include <algorithm>
#include <stdexcept>
#include <iostream>
#include <sstream>
#include <cstring>
#include <vector>
#include <string>
#include <memory>
#include <ctime>
#include <mutex>
#include <deque>
#include <list>
#include <map>


class MiniHSFS {


public:

    // Inode structure
    struct Inode {
        size_t size = 0;                        // 8 bytes
        int blocksUsed = 0;                    // 4 bytes
        int firstBlock = -1;                  // 4 bytes
        bool isDirectory = false;            // 1 byte
        bool isUsed = false;                // 1 byte
        bool isDirty = false;              // 1 byte ( Has it been modified? )
        time_t creationTime = 0;          // 8 bytes
        time_t modificationTime = 0;     // 8 bytes
        time_t lastAccessed = 0;        // 8 bytes
        std::unordered_map<std::string, int> entries; // For directories

        // Calculate the actual size of the node
        size_t actualSize() const {
            size_t baseSize = sizeof(size) + sizeof(blocksUsed) + sizeof(firstBlock) +
                sizeof(isDirectory) + sizeof(isUsed) +
                sizeof(creationTime) + sizeof(modificationTime) +
                sizeof(lastAccessed) + sizeof(isDirty);

            if (isDirectory) {
                baseSize += sizeof(size_t); // For the size of the unordered_map
                for (const auto& entry : entries) {
                    baseSize += entry.first.size() + sizeof(int);
                }
            }
            return baseSize;
        }

        // Helper function to check validity
        bool isValid() const {
            if (!isUsed) return true;

            //Basic value verification
            if (size < 0) return false;
            if (blocksUsed < 0) return false;
            if (creationTime <= 0) return false;
            if (modificationTime <= 0) return false;
            if (lastAccessed <= 0) return false;

            // Check data consistency
            if (isDirectory) {
                // For folders: Check entries
                for (const auto& entry : entries) {
                    if (entry.first.empty() || entry.second < 0) {
                        return false;
                    }
                }
            }
            else {
                //For files: Check blocks
                if (blocksUsed > 0 && firstBlock < 0) return false;
            }

            return true;
        }
    };

    // Constants
    std::vector<Inode> inodeTable;
    std::recursive_mutex fsMutex;
    bool mounted = false;
    bool initialized = false;
    int dataStartIndex;
    time_t lastTimeWrite = -1;
    int rootNodeIndex = 0;
    const int maxFileNameLength = 255;
    const int maxPathLength = 4096;


    MiniHSFS(const std::string& path, uint32_t sizeMB, uint32_t blockSize);
    ~MiniHSFS();
    VirtualDisk& Disk();

    VirtualDisk::Extent AllocateContiguousBlocks(int blocksNeeded);
    int AllocateInode(bool isDirectory = false);
    void FreeInode(int inodeIndex);

    // Filesystem operations
    void Initialize();
    void Mount(size_t inodePercentage = 0, size_t btreePercentage = 0, size_t inodeSize = 512);
    void Unmount();
    void SaveInodeToDisk(int inodeIndex);

    // File operations
    int FindFile(const std::string& path);
    int FindFreeBlock();
    bool FreeFileBlocks(Inode& inode);

    // Directory operations
    void MarkBlockUsed(int blockIndex);


    int PathToInode(const std::vector<std::string>& path);
    std::vector<std::string> SplitPath(const std::string& path)const;
    void ValidatePath(const std::string& path); // Check Validate Path
    void UpdateInodeTimestamps(int inodeIndex, bool modify = true); // To Update Time after any Edit Parent Directory or File

    // Utility functions
    void PrintBTreeStructure();
    void PrintSuperblockInfo();

    // B-tree operations
    bool BTreeDelete(int nodeIndex, int key);


private:

    //SuperBlock Structue Using To Get Info Super Block
    struct SuperblockInfo {
        char magic[8];                   // 8 bytes (Name File System)
        uint32_t version;               // 4 bytes
        uint32_t systemSize;           // 4 bytes
        uint32_t blockSize;           // 4 bytes
        size_t inodeSize;            // 4 bytes
        uint64_t totalBlocks;       // 8 bytes
        uint64_t freeBlocks;       // 8 bytes
        size_t totalInodes;       // 4 bytes
        size_t freeInodes;       // 4 bytes
        time_t creationTime;    // 8 bytes
        time_t lastMountTime;  // 8 bytes
        time_t lastWriteTime; // 8 bytes
        uint32_t state;      // 4 bytes
    };

    // File Info Structure, Inode File Information Using in Defragmentation Inodes Table 
    struct FileInfo {
        int inodeIndex;
        uint32_t startBlock;
        uint32_t blockCount;
    };

    // Data Info Structure, Inode File Data Information Using in Defragmentation Data Inode
    struct DataMoveOperation {
        int inodeIndex;
        uint32_t oldStartBlock;
        uint32_t newStartBlock;
        uint32_t blockCount;
        bool success;
    };

    //B-Tree Structure, Using To Control in free or not Inodes
    struct BTreeNode {
        bool isLeaf;
        int keyCount;
        int* keys;
        union {
            int* children;
            int* values;
        };
        int nextLeaf;
        int accessCount;
        bool isDirty;
        int order; //We need to store btreeOrder in each node

        //Basic constructor
        BTreeNode(int btree_order, bool leaf = true)
            : isLeaf(leaf), keyCount(0), nextLeaf(-1),
            accessCount(0), isDirty(false), order(btree_order)
        {
            keys = new int[btree_order - 1];
            if (isLeaf)
                values = new int[btree_order - 1]();
            else
                children = new int[btree_order]();
            std::fill(keys, keys + btree_order - 1, -1);
        }

        //Default constructor(to bypass C2512 errors)
        BTreeNode() : isLeaf(true), keyCount(0), nextLeaf(-1),
            accessCount(0), isDirty(false), order(4)
        {
            keys = new int[order - 1];
            values = new int[order - 1]();
            std::fill(keys, keys + order - 1, -1);
        }

        ~BTreeNode() {
            delete[] keys;
            if (isLeaf)
                delete[] values;
            else
                delete[] children;
        }

        BTreeNode(const BTreeNode& other)
            : isLeaf(other.isLeaf), keyCount(other.keyCount),
            nextLeaf(other.nextLeaf), accessCount(other.accessCount),
            isDirty(other.isDirty), order(other.order)
        {
            keys = new int[order - 1];
            std::copy(other.keys, other.keys + order - 1, keys);
            if (isLeaf) {
                values = new int[order - 1];
                std::copy(other.values, other.values + order - 1, values);
            }
            else {
                children = new int[order];
                std::copy(other.children, other.children + order, children);
            }
        }

        BTreeNode& operator=(const BTreeNode& other) {
            if (this == &other) return *this;
            isLeaf = other.isLeaf;
            keyCount = other.keyCount;
            nextLeaf = other.nextLeaf;
            accessCount = other.accessCount;
            isDirty = other.isDirty;
            order = other.order;

            delete[] keys;
            keys = new int[order - 1];
            std::copy(other.keys, other.keys + order - 1, keys);

            if (isLeaf) {
                delete[] values;
                values = new int[order - 1];
                std::copy(other.values, other.values + order - 1, values);
            }
            else {
                delete[] children;
                children = new int[order];
                std::copy(other.children, other.children + order, children);
            }

            return *this;
        }
    };

    std::unordered_map<int, std::list<int>::iterator> btreeLruMap;
    std::vector<int> freeBTreeBlocksCache;
    std::map<int, BTreeNode> btreeCache;
    std::vector<int> freeInodesList;
    std::vector<bool> inodeBitmap;   //To track used/free nodes
    const int superBlockIndex = 0;  // First Index Have data SuperBlock 
    std::list<int> btreeLruList;   //
    size_t inodeAreaSize = 0;     //Current size of the contract space
    int btreeLoadCounter = 0;    //
    size_t nextFreeInode = 1;   // To speed up the search for a free node
    size_t freeBlocks = 0;     //Number of free blocks
    size_t inodePercentage;   // Control Inode Count
    size_t btreePercentage;  // Control B-Tree Inode Count (Free or Not)
    int superBlockBlocks;   // SuperBlock Blocks Count
    int btreeStartIndex;   // First Index of Block Data of B-Tree Inodes 
    size_t inodeBlocks;   // Inode Blocks Count
    BTreeNode rootNode;  // Root Inode Directory (Child && Entries)
    size_t inodeCount;  //Inode Count
    VirtualDisk disk;  // Object from VirtualDisk File
    size_t inodeSize; // Size of Inode
    int btreeBlocks; // B-Tree Blocks Count
    int btreeOrder; // B-Tree Order

    //Inode Operations
    int GetInodeIndex(const Inode& inode) const;

    //Btree Operations
    int AllocateBTreeNode();
    bool BTreeInsert(int nodeIndex, int key, int value);
    void FreeBTreeNode(int nodeIndex);
    bool IsBTreeBlockFree(int index);
    std::pair<bool, int> BTreeFind(int nodeIndex, int key);
    void BTreeSplitChild(int parentIndex, int childIndex, int index);
    bool BTreeMergeChildren(int nodeIndex, int index);
    bool BTreeInsertNonFull(int nodeIndex, int key, int value);
    int BTreeGetSuccessor(int nodeIndex);
    int BTreeGetPredecessor(int nodeIndex);
    bool BTreeDeleteFromNonLeaf(int nodeIndex, int index);
    bool BTreeDeleteFromLeaf(int nodeIndex, int index);
    void BTreeBorrowFromRight(int nodeIndex, int index);
    void BTreeBorrowFromLeft(int nodeIndex, int index);
    void BTreeFill(int nodeIndex, int index);

    // Initializations
    void InitializeSuperblock();
    void InitializeInodeTable();
    int InitializeInode(int index, bool isDirectory);
    void InitializeBTree();

    //Calculations
    void CalculatePercentage(double inodePercentage = 0.015, double btreePercentage = 0.01);
    size_t CalculateInodeCount();
    size_t CalculateInodeBlocks();
    size_t CalculateBTreeBlocks();
    size_t CalculateBTreeOrder();
    size_t CountFreeInodes();
    size_t getAvailableMemory();
    uint32_t CalculateChecksum(const char* data, size_t length);
    size_t CalculateBlocksForNewInodes(size_t inodeCount);

    //Loader
    BTreeNode LoadBTreeNode(int nodeIndex);
    SuperblockInfo LoadSuperblock();
    void LoadInodeTable();
    void LoadBTree();

    //Saver
    void SaveBTreeNode(int nodeIndex, const BTreeNode& node);
    void SaveSuperblock(const SuperblockInfo& info);
    void SaveInodeTable();
    void SaveBTree();

    // Directory operations
    void MarkBlocksUsed(const VirtualDisk::Extent& extent);

    //Updater
    void UpdateSuperblockForDynamicInodes();

    // B-tree operations
    bool IsBlockUsed(int blockIndex);

    // Helper functions
    void ValidateInode(int inodeIndex, bool checkDirectory = false);

    // Serialization && Deserialization
    size_t SerializeInode(const Inode& inode, char* buffer, size_t bufferSize);
    size_t DeserializeInode(Inode& inode, const char* buffer, size_t bufferSize);
    void SerializeBTreeNode(const BTreeNode& node, char* buffer);
    void DeserializeBTreeNode(BTreeNode& node, const char* buffer);

    //Defragmentations
    bool DefragmentAndExtendInodes(size_t extraInodes);
    void DefragmentFileBlocks(int inodeIndex);
    void DefragmentDisk();
    bool ExpandInodeAreaDirect(size_t additionalBlocks, size_t newTotalInodes);
    bool ExpandInodeAreaByInodes(size_t extraInodes);
    void RollbackMoves(const std::vector<DataMoveOperation>& moves);
    bool MoveFileBlocks(int inodeIndex, uint32_t oldStart, uint32_t newStart, uint32_t blockCount);
    std::vector<FileInfo> FindFilesInRange(uint32_t startBlock, uint32_t endBlock);
    uint32_t FindFreeSpaceAtEnd(size_t requiredBlocks);

    //Rebuldations
    void RebuildFreeBlockList();
    void RebuildFreeInodesList();
    void RebuildInodeBitmap();

    void TouchBTreeNode(int index);
    void FreeLRUBTreeNode();

};

#endif // MINI_HSFS_H
------------------------------
MiniHSFS.cpp
------------------------------
#include "MiniHSFS.h"

///////////////////////////////Start System

MiniHSFS::MiniHSFS(const std::string& path, uint32_t sizeMB, uint32_t blockSize)
    :disk(std::max<int>(1, static_cast<int>(std::ceil((double)sizeof(SuperblockInfo) / blockSize))), blockSize),
    mounted(false),
    initialized(false),
     btreeBlocks(0), btreeStartIndex(0), dataStartIndex(0), inodeBlocks(0), inodeCount(0) {

    // Format the virtual disk
    disk.Initialize(path, sizeMB);

    btreeOrder = static_cast<int>(CalculateBTreeOrder());

    // Root Formatting
    rootNode = BTreeNode(btreeOrder, true);

    freeBlocks = disk.freeBlocksCount() - inodeBlocks;
}

VirtualDisk& MiniHSFS::Disk()
{
    return disk;
}

MiniHSFS::~MiniHSFS()
{
    Unmount();
}

void MiniHSFS::Initialize() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    if (initialized) {
        throw std::runtime_error("Filesystem already initialized");
    }

    if (!disk.ensureOpen()) {
        throw std::runtime_error("Virtual disk not open");
    }
    superBlockBlocks = std::max<int>(1, static_cast<int>(std::ceil((double)sizeof(SuperblockInfo) / disk.blockSize)));
    inodeCount = CalculateInodeCount();
    inodeBlocks = CalculateInodeBlocks();
    btreeBlocks = static_cast<int>(CalculateBTreeBlocks());
    btreeStartIndex = static_cast<int>(inodeBlocks) + disk.getSystemBlocks() + superBlockBlocks;
    dataStartIndex = btreeStartIndex + btreeBlocks;

    try {
        if (disk.IsNew()) {
            InitializeSuperblock();

            InitializeBTree();
            disk.allocateBlocks(static_cast<uint32_t>(btreeBlocks ? btreeBlocks : 1));

            InitializeInodeTable();
            disk.allocateBlocks(static_cast<uint32_t>(inodeBlocks ? inodeBlocks : 1));

            SaveInodeTable();
            SaveBTree();
        }
        initialized = true;
    }
    catch (...) {
        //FlushDirtyInodes();
        SaveBTree();
        std::cerr << "!!Memory pressure during initialization. Flushing all caches.\n";

        btreeCache.clear();
        btreeLruMap.clear();
        btreeLruList.clear();
        inodeTable.clear();
        throw;
    }
}

void MiniHSFS::Mount(size_t inodePercentage, size_t btreePercentage, size_t inodeSize) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    this->inodeSize = inodeSize;

    if (inodePercentage != 0 && btreePercentage != 0)
        CalculatePercentage(inodePercentage, btreePercentage);
    else if (inodePercentage != 0 && btreePercentage == 0)
        CalculatePercentage(inodePercentage = inodePercentage);
    else if (inodePercentage == 0 && btreePercentage != 0)
        CalculatePercentage(btreePercentage = btreePercentage);
    else
        CalculatePercentage();

    if (mounted) {
        throw std::runtime_error("Filesystem already mounted");
    }

    if (!initialized) {
        Initialize();
    }
    try {

        LoadInodeTable();
        LoadBTree();


        //// Verify root directory
        if (!inodeTable[0].isUsed || !inodeTable[0].isDirectory) {
            throw std::runtime_error("Root directory corruption detected");
        }

        mounted = true;
    }
    catch (const std::exception& e) {
        // Clean up if mount fails
        inodeTable.clear();
        inodeTable.resize(inodeCount);
        rootNode = BTreeNode(true);
        std::cout << e.what() << std::endl;
        throw e;
    }
}

void MiniHSFS::Unmount() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    if (!mounted) {
        throw std::runtime_error("Filesystem not mounted");
    }

    try {
        MiniHSFS::SuperblockInfo info = MiniHSFS::LoadSuperblock();
        info.freeBlocks = disk.freeBlocksCount();
        info.lastMountTime = time(nullptr);
        int count = 0;
        for (int i = 1; i < inodeCount; i++) {
            if (!inodeTable[i].isUsed) {
                count++;
            }
        }
        info.lastWriteTime = (lastTimeWrite != -1) ? lastTimeWrite : info.lastWriteTime;
        info.systemSize = MiniHSFS::dataStartIndex;
        info.freeInodes = CountFreeInodes();

        //Save All Updates
        SaveSuperblock(info);
        SaveInodeTable();
        SaveBTree();

        // Sync virtual disk
        disk.syncToDisk();

        btreeCache.clear();
        inodeTable.clear();
        btreeLruList.clear();
        btreeLruMap.clear();

        mounted = false;
    }
    catch (const std::exception& e) {
        throw std::runtime_error(std::string("Failed to unmount: ") + e.what());
    }

}

////////////////////////////Initialize System

void MiniHSFS::InitializeSuperblock() {
    SuperblockInfo info;
    std::memset(&info, 0, sizeof(info));

    const char* magicStr = "Tomas";
    std::memcpy(info.magic, magicStr, strlen(magicStr));

    info.version = 0x00010000;
    info.blockSize = disk.blockSize;
    info.inodeSize = inodeSize;
    info.systemSize = static_cast<uint32_t>(inodeBlocks) + btreeBlocks + superBlockBlocks + disk.getSystemBlocks();
    info.totalBlocks = disk.totalBlocks();
    info.freeBlocks = static_cast<uint32_t>(info.totalBlocks - (static_cast<uint32_t>(inodeBlocks) + btreeBlocks + superBlockBlocks + disk.getSystemBlocks()));
    info.totalInodes = inodeCount;
    info.freeInodes = inodeCount - 1;
    info.creationTime = time(nullptr);
    info.lastMountTime = info.creationTime;
    info.lastWriteTime = info.creationTime;
    info.state = 1;

    SaveSuperblock(info);
}

void MiniHSFS::InitializeInodeTable() {

    inodeTable.clear();
    inodeTable.resize(inodeCount);
    inodeBitmap.assign(inodeCount, false);

    //Create root directory
    inodeTable[0].isUsed = true;
    inodeTable[0].isDirectory = true;
    time_t now = time(nullptr);
    inodeTable[0].creationTime = inodeTable[0].modificationTime = inodeTable[0].lastAccessed = now;
    inodeBitmap[0] = true;

}

int MiniHSFS::InitializeInode(int index, bool isDirectory) {
    if (index < 0 || static_cast<size_t>(index) >= inodeTable.size()) {
        throw std::out_of_range("Invalid inode index: " + std::to_string(index));
    }

    // Complete new configuration with default values
    Inode newInode;
    newInode.isUsed = true;
    newInode.isDirectory = isDirectory;
    newInode.size = 0;
    newInode.blocksUsed = 0;
    newInode.firstBlock = -1;
    newInode.entries.clear();

    time_t now = time(nullptr);
    newInode.creationTime = now;
    newInode.modificationTime = now;
    newInode.lastAccessed = now;
    newInode.isDirty = true;

    inodeTable[index] = newInode;

    if (inodeBitmap.size() > static_cast<size_t>(index)) {
        inodeBitmap[index] = true;
    }

    // Update SuperBlock 
    UpdateSuperblockForDynamicInodes();

    return index;
}

void MiniHSFS::InitializeBTree() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    rootNodeIndex = AllocateBTreeNode();
    if (rootNodeIndex == -1) {
        throw std::runtime_error("Failed to allocate root B-tree node");
    }

    BTreeNode rootNode(btreeOrder, true);
    btreeCache[rootNodeIndex] = rootNode;

    int currentNode = rootNodeIndex;
    int block = dataStartIndex;

    while (block < disk.totalBlocks()) {
        BTreeNode* node = &btreeCache[currentNode];

        if (node->keyCount == btreeOrder - 1) {
            int newNode = AllocateBTreeNode();
            if (newNode == -1) {
                throw std::runtime_error("No free B-tree nodes available");
            }

            BTreeNode newLeaf(btreeOrder, true);
            newLeaf.nextLeaf = node->nextLeaf;
            node->nextLeaf = newNode;

            SaveBTreeNode(currentNode, *node);
            currentNode = newNode;
            btreeCache[currentNode] = newLeaf;
            continue;
        }

        node->keys[node->keyCount] = block;
        node->values[node->keyCount] = 0;
        node->keyCount++;
        block++;
    }

    SaveBTreeNode(currentNode, btreeCache[currentNode]);

    if (currentNode != rootNodeIndex) {
        SaveBTreeNode(rootNodeIndex, btreeCache[rootNodeIndex]);
    }
}

///////////////////////////////B-Tree Operations

bool MiniHSFS::IsBTreeBlockFree(int index) {
    try {
        auto data = disk.readData(VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + index), 1 });

        // Empty if all data is Zero
        return std::all_of(data.begin(), data.end(), [](char c) { return c == 0; });
    }
    catch (...) {
        std::cout << "Error XX : Can Not Find Free Blocks!" << std::endl;
        // if Faild empty also
        return true;
    }
}

int MiniHSFS::AllocateBTreeNode() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    for (int i = 0; i < btreeBlocks; ++i) {
        if (IsBTreeBlockFree(i) && !disk.IsNew()) {

            // initial Block by zero data
            std::vector<char> zeroBuffer(disk.blockSize, 0);
            disk.writeData(
                zeroBuffer,
                VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + i), 1 },
                "", true
            );
            return i;
        }
        else
        {
            std::vector<char> zeroBuffer(disk.blockSize, 0);
            disk.writeData(
                zeroBuffer,
                VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + i), 1 },
                "", true
            );
            return i;
        }
    }

    return -1; // Not Blocks Empty
}

void MiniHSFS::FreeBTreeNode(int nodeIndex) {
    if (nodeIndex < 0 || nodeIndex >= btreeBlocks) return;
    BTreeNode emptyNode(btreeOrder);
    SaveBTreeNode(nodeIndex, emptyNode);
    btreeCache.erase(nodeIndex);
    std::vector<char> emptyBlock(disk.blockSize, 0);
    disk.writeData(emptyBlock, VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + nodeIndex), 1 }, "", true);
}

std::pair<bool, int> MiniHSFS::BTreeFind(int nodeIndex, int key) {

    // Load the current node
    BTreeNode node = LoadBTreeNode(nodeIndex);

    // Constant to define the boundary between linear and binary search
    constexpr int binarySearchThreshold = 16;

    int pos = 0; //Initial position

    // Selecting a search algorithm based on node size
    if (node.keyCount > binarySearchThreshold) {
        // Improved binary search for large nodes
        int left = 0;
        int right = node.keyCount - 1;

        while (left <= right) {
            pos = left + (right - left) / 2;

            if (key == node.keys[pos]) {
                // We found the key
                return { true, node.isLeaf ? node.values[pos] : node.children[pos + 1] };
            }

            if (key < node.keys[pos]) {
                right = pos - 1;
            }
            else {
                left = pos + 1;
            }
        }
        pos = left; // The position where the key would have been inserted
    }
    else {
        // Improved linear search for small nodes
        while (pos < node.keyCount && key > node.keys[pos]) {
            ++pos;
        }

        // Check if we found the key
        if (pos < node.keyCount && key == node.keys[pos]) {
            return { true, node.isLeaf ? node.values[pos] : node.children[pos + 1] };
        }
    }

    // If we get here and don't find the key
    if (node.isLeaf) {
        return { false, -1 }; // Key not found
    }

    // Continue searching for the appropriate child node
    return BTreeFind(node.children[pos], key);
}

bool MiniHSFS::BTreeInsert(int nodeIndex, int key, int value) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    if (value < 0) throw std::invalid_argument("B-tree value cannot be negative");
    BTreeNode node = LoadBTreeNode(nodeIndex);

    if (node.keyCount == btreeOrder - 1) {
        if (nodeIndex == rootNodeIndex) {
            BTreeNode newRoot(btreeOrder, false);
            int newRootIndex = AllocateBTreeNode();
            if (newRootIndex == -1) throw std::runtime_error("Failed to allocate new root node");
            newRoot.children[0] = rootNodeIndex;
            rootNodeIndex = newRootIndex;
            btreeCache[newRootIndex] = newRoot;
        }
        BTreeSplitChild(rootNodeIndex, nodeIndex, 0);
        return BTreeInsertNonFull(rootNodeIndex, key, value);
    }
    return BTreeInsertNonFull(nodeIndex, key, value);
}

bool MiniHSFS::BTreeInsertNonFull(int nodeIndex, int key, int value) {
    BTreeNode node = LoadBTreeNode(nodeIndex);
    int i = node.keyCount - 1;

    // Check if the core exists -> Just set the value and return true
    for (int j = 0; j < node.keyCount; ++j) {
        if (node.keys[j] == key) {
            node.values[j] = value;
            SaveBTreeNode(nodeIndex, node);
            return true;
        }
    }

    if (node.isLeaf) {
        // Insert the key into the correct position ->
        while (i >= 0 && key < node.keys[i]) {
            node.keys[i + 1] = node.keys[i];
            node.values[i + 1] = node.values[i];
            i--;
        }

        node.keys[i + 1] = key;
        node.values[i + 1] = value;
        node.keyCount++;
        SaveBTreeNode(nodeIndex, node);
        return true;
    }
    else {
        // Going down to the right child ->
        while (i >= 0 && key < node.keys[i]) i--;
        i++;

        BTreeNode child = LoadBTreeNode(node.children[i]);

        if (child.keyCount == btreeOrder - 1) {
            BTreeSplitChild(nodeIndex, node.children[i], i);
            // After splitting, the input location may change
            if (key > node.keys[i]) i++;
        }

        return BTreeInsertNonFull(node.children[i], key, value);
    }
}

void MiniHSFS::BTreeSplitChild(int parentIndex, int childIndex, int index) {
    BTreeNode parent = LoadBTreeNode(parentIndex);
    BTreeNode child = LoadBTreeNode(childIndex);
    BTreeNode newNode(btreeOrder, child.isLeaf);

    int newNodeIndex = AllocateBTreeNode();
    if (newNodeIndex == -1) throw std::runtime_error("No space for new B-tree node");

    int t = (btreeOrder - 1) / 2;
    newNode.keyCount = t;
    for (int j = 0; j < t; j++) {
        newNode.keys[j] = child.keys[j + t + 1];
        if (child.isLeaf) newNode.values[j] = child.values[j + t + 1];
    }

    if (!child.isLeaf) {
        for (int j = 0; j <= t; j++) {
            newNode.children[j] = child.children[j + t + 1];
        }
    }
    else {
        newNode.nextLeaf = child.nextLeaf;
        child.nextLeaf = newNodeIndex;
    }

    child.keyCount = t;

    for (int j = parent.keyCount; j > index; j--) {
        parent.children[j + 1] = parent.children[j];
        parent.keys[j] = parent.keys[j - 1];
    }
    parent.children[index + 1] = newNodeIndex;
    parent.keys[index] = child.keys[t];
    parent.keyCount++;

    SaveBTreeNode(parentIndex, parent);
    SaveBTreeNode(childIndex, child);
    SaveBTreeNode(newNodeIndex, newNode);
}

bool MiniHSFS::BTreeDelete(int nodeIndex, int key) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);  // simultaneous protection

    try {
        BTreeNode node = LoadBTreeNode(nodeIndex);
        int idx = 0;

        // Find the key inside the node
        while (idx < node.keyCount && key > node.keys[idx]) {
            idx++;
        }

        // Case 1: The key is inside the current node
        if (idx < node.keyCount && node.keys[idx] == key) {
            bool success;
            if (node.isLeaf)
                success = BTreeDeleteFromLeaf(nodeIndex, idx);
            else
                success = BTreeDeleteFromNonLeaf(nodeIndex, idx);

            if (success) {
                node.isDirty = true;
                SaveBTreeNode(nodeIndex, node);
            }

            return success;
        }

        // Case 2: The key does not exist and this is a leaf node
        if (node.isLeaf) {
            return false;  // Key not found
        }

        // Case 3: The key is in one of the children
        bool atEnd = (idx == node.keyCount);
        int childIndex = node.children[atEnd ? idx - 1 : idx];

        // Download the target child
        BTreeNode child = LoadBTreeNode(childIndex);

        // If the child has fewer keys than the minimum, fill in
        if (child.keyCount < (btreeOrder / 2)) {
            BTreeFill(nodeIndex, idx); // May be combined or borrowed from neighbors

            // Reload node and child after modification
            node = LoadBTreeNode(nodeIndex);
            childIndex = node.children[atEnd ? idx - 1 : idx];
        }

        // Follow-up deletion within the child
        return BTreeDelete(childIndex, key);
    }
    catch (const std::exception& e) {
        std::cerr << "BTreeDelete Exception: " << e.what() << "\n";
        return false;
    }
}

bool MiniHSFS::BTreeMergeChildren(int parentIndex, int index) {
    try {
        BTreeNode parent = LoadBTreeNode(parentIndex);
        int leftIndex = parent.children[index];
        int rightIndex = parent.children[index + 1];

        BTreeNode left = LoadBTreeNode(leftIndex);
        BTreeNode right = LoadBTreeNode(rightIndex);

        // Add the parent key between the two nodes
        left.keys[left.keyCount] = parent.keys[index];
        if (left.isLeaf)
            left.values[left.keyCount] = right.values[0]; // Or keep it as designed
        left.keyCount++;

        // Copy the right child's keys
        for (int i = 0; i < right.keyCount; ++i) {
            left.keys[left.keyCount + i] = right.keys[i];
            if (left.isLeaf)
                left.values[left.keyCount + i] = right.values[i];
        }

        if (!left.isLeaf) {
            for (int i = 0; i <= right.keyCount; ++i)
                left.children[left.keyCount + i] = right.children[i];
        }
        else {
            // B+ Tree Support
            left.nextLeaf = right.nextLeaf;
        }

        left.keyCount += right.keyCount;

        // Transferring keys and children to the father
        for (int i = index + 1; i < parent.keyCount; ++i)
            parent.keys[i - 1] = parent.keys[i];
        for (int i = index + 2; i <= parent.keyCount; ++i)
            parent.children[i - 1] = parent.children[i];

        parent.keyCount--;

        SaveBTreeNode(leftIndex, left);
        SaveBTreeNode(parentIndex, parent);
        FreeBTreeNode(rightIndex);

        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "Merge failed: " << e.what() << "\n";
        return false;
    }
}

void MiniHSFS::BTreeFill(int nodeIndex, int index) {
    BTreeNode node = LoadBTreeNode(nodeIndex);
    if (index > 0 && LoadBTreeNode(node.children[index - 1]).keyCount >= btreeOrder / 2) {
        BTreeBorrowFromLeft(nodeIndex, index);
    }
    else if (index < node.keyCount && LoadBTreeNode(node.children[index + 1]).keyCount >= btreeOrder / 2) {
        BTreeBorrowFromRight(nodeIndex, index);
    }
    else {
        BTreeMergeChildren(nodeIndex, index == node.keyCount ? index - 1 : index);
    }
}

void MiniHSFS::BTreeBorrowFromLeft(int nodeIndex, int index) {
    BTreeNode parent = LoadBTreeNode(nodeIndex);
    BTreeNode child = LoadBTreeNode(parent.children[index]);
    BTreeNode left = LoadBTreeNode(parent.children[index - 1]);

    for (int i = child.keyCount - 1; i >= 0; i--) {
        child.keys[i + 1] = child.keys[i];
        if (child.isLeaf) child.values[i + 1] = child.values[i];
    }
    if (!child.isLeaf) {
        for (int i = child.keyCount; i >= 0; i--) child.children[i + 1] = child.children[i];
        child.children[0] = left.children[left.keyCount];
    }

    child.keys[0] = parent.keys[index - 1];
    if (child.isLeaf) child.values[0] = left.values[left.keyCount - 1];
    parent.keys[index - 1] = left.keys[left.keyCount - 1];

    child.keyCount++;
    left.keyCount--;

    SaveBTreeNode(nodeIndex, parent);
    SaveBTreeNode(parent.children[index], child);
    SaveBTreeNode(parent.children[index - 1], left);
}

void MiniHSFS::BTreeBorrowFromRight(int nodeIndex, int index) {
    BTreeNode parent = LoadBTreeNode(nodeIndex);
    BTreeNode child = LoadBTreeNode(parent.children[index]);
    BTreeNode right = LoadBTreeNode(parent.children[index + 1]);

    child.keys[child.keyCount] = parent.keys[index];
    if (child.isLeaf) child.values[child.keyCount] = right.values[0];
    if (!child.isLeaf) child.children[child.keyCount + 1] = right.children[0];

    parent.keys[index] = right.keys[0];

    for (int i = 1; i < right.keyCount; i++) {
        right.keys[i - 1] = right.keys[i];
        if (right.isLeaf) right.values[i - 1] = right.values[i];
    }
    if (!right.isLeaf) {
        for (int i = 1; i <= right.keyCount; i++) right.children[i - 1] = right.children[i];
    }

    child.keyCount++;
    right.keyCount--;

    SaveBTreeNode(nodeIndex, parent);
    SaveBTreeNode(parent.children[index], child);
    SaveBTreeNode(parent.children[index + 1], right);
}

bool MiniHSFS::BTreeDeleteFromLeaf(int nodeIndex, int index) {
    try {
        BTreeNode node = LoadBTreeNode(nodeIndex);

        if (index < 0 || index >= node.keyCount) {
            throw std::out_of_range("Invalid index in BTreeDeleteFromLeaf");
        }

        for (int i = index + 1; i < node.keyCount; ++i) {
            node.keys[i - 1] = node.keys[i];
            node.values[i - 1] = node.values[i];  // No need for isLeaf
        }

        node.keyCount--;
        node.isDirty = true;
        SaveBTreeNode(nodeIndex, node);

        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "Error in BTreeDeleteFromLeaf: " << e.what() << std::endl;
        return false;
    }
}

bool MiniHSFS::BTreeDeleteFromNonLeaf(int nodeIndex, int index) {
    try {
        BTreeNode node = LoadBTreeNode(nodeIndex);

        // Input validation
        if (index < 0 || index >= node.keyCount) {
            throw std::out_of_range("Invalid index in BTreeDeleteFromNonLeaf");
        }

        int key = node.keys[index];

        // Case 1: The left child has enough keys.
        BTreeNode leftChild = LoadBTreeNode(node.children[index]);
        if (leftChild.keyCount >= (btreeOrder + 1) / 2) {
            int predecessor = BTreeGetPredecessor(node.children[index]);
            node.keys[index] = predecessor;
            node.isDirty = true;
            SaveBTreeNode(nodeIndex, node);
            return BTreeDelete(node.children[index], predecessor);
        }

        // Case 2: The right child has enough keys.
        BTreeNode rightChild = LoadBTreeNode(node.children[index + 1]);
        if (rightChild.keyCount >= (btreeOrder + 1) / 2) {
            int successor = BTreeGetSuccessor(node.children[index + 1]);
            node.keys[index] = successor;
            node.isDirty = true;
            SaveBTreeNode(nodeIndex, node);
            return BTreeDelete(node.children[index + 1], successor);
        }

        // Case 3: Required Merger
        if (!BTreeMergeChildren(nodeIndex, index)) {
            throw std::runtime_error("Failed to merge children");
        }

        // Reload node after merge
        node = LoadBTreeNode(nodeIndex);
        return BTreeDelete(node.children[index], key);

    }
    catch (const std::exception& e) {
        std::cerr << "Error in BTreeDeleteFromNonLeaf: " << e.what() << std::endl;
        return false;
    }
}

int MiniHSFS::BTreeGetPredecessor(int nodeIndex) {
    BTreeNode node = LoadBTreeNode(nodeIndex);
    while (!node.isLeaf) node = LoadBTreeNode(node.children[node.keyCount]);
    return node.keys[node.keyCount - 1];
}

int MiniHSFS::BTreeGetSuccessor(int nodeIndex) {
    BTreeNode node = LoadBTreeNode(nodeIndex);
    while (!node.isLeaf) node = LoadBTreeNode(node.children[0]);
    return node.keys[0];
}

/////////////////////////////////Load and Save Tables

MiniHSFS::SuperblockInfo MiniHSFS::LoadSuperblock() {
    std::vector<char> data = disk.readData(
        VirtualDisk::Extent{ static_cast<uint32_t>(superBlockIndex), static_cast<uint32_t>(superBlockBlocks) });

    SuperblockInfo info;
    std::memcpy(&info, data.data(), sizeof(SuperblockInfo));

    return info;
}

void MiniHSFS::SaveSuperblock(const SuperblockInfo& info) {
    std::vector<char> data(superBlockBlocks * disk.blockSize, 0);

    std::memcpy(data.data(), &info, sizeof(SuperblockInfo));
    disk.writeData(data,
        VirtualDisk::Extent{ static_cast<uint32_t>(superBlockIndex), static_cast<uint32_t>(superBlockBlocks) }, "", false);

}

void MiniHSFS::UpdateSuperblockForDynamicInodes() {
    SuperblockInfo info = LoadSuperblock();
    info.inodeSize = inodeSize;
    info.totalInodes = static_cast<uint32_t>(inodeTable.size());
    info.freeInodes = static_cast<uint32_t>(CountFreeInodes());
    info.lastWriteTime = time(nullptr);

    // Update the system size to reflect the expansion of the inodes area
    info.systemSize = static_cast<uint32_t>(disk.getSystemBlocks() + superBlockBlocks + inodeBlocks + btreeBlocks);

    SaveSuperblock(info);
}

void MiniHSFS::LoadInodeTable() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    SuperblockInfo sb = LoadSuperblock();
    inodeSize = sb.inodeSize;

    inodeCount = sb.totalInodes;               // The only source of volume
    inodeBlocks = CalculateBlocksForNewInodes(inodeCount); // Calculate how many blocks we need to read
    inodeTable.assign(inodeCount, Inode{});

    // Read all blocks of the iode table
    size_t bytes = inodeBlocks * disk.blockSize;
    std::vector<char> buf(bytes, 0);
    for (size_t b = 0; b < inodeBlocks; ++b) {
        auto data = disk.readData(
            VirtualDisk::Extent(disk.getSystemBlocks() + superBlockBlocks + b, 1));
        std::copy(data.begin(), data.end(), buf.begin() + b * disk.blockSize);
    }

    // Decode each inode
    for (size_t i = 0; i < inodeCount; ++i) {
        DeserializeInode(inodeTable[i], buf.data() + i * inodeSize, inodeSize);
    }

    RebuildInodeBitmap(); // Build bitmap from isUsed after loading
}

void MiniHSFS::SaveInodeTable() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    size_t requiredBlocks = CalculateBlocksForNewInodes(inodeTable.size());
    if (requiredBlocks > inodeBlocks) {
        size_t add = requiredBlocks - inodeBlocks;
        VirtualDisk::Extent ext(disk.getSystemBlocks() + superBlockBlocks + inodeBlocks, add);
        disk.allocateBlocks(ext.blockCount);

        std::vector<char> zero(disk.blockSize, 0);
        for (size_t i = 0; i < add; ++i)
            disk.writeData(zero, VirtualDisk::Extent(ext.startBlock + i, 1), "", true);

        inodeBlocks = requiredBlocks;
        UpdateSuperblockForDynamicInodes();
    }

    std::vector<char> big(inodeBlocks * disk.blockSize, 0);
    size_t ok = 0;
    for (size_t i = 0; i < inodeTable.size(); ++i) {
        size_t off = i * inodeSize;
        if (off + inodeSize > big.size())
            throw std::runtime_error("SaveInodeTable: inode area too small");

        if (SerializeInode(inodeTable[i], big.data() + off, inodeSize) == 0)
            throw std::runtime_error("SaveInodeTable: serialize failed for inode " + std::to_string(i));

        inodeTable[i].isDirty = false;
        ok++;
    }

    for (size_t b = 0; b < inodeBlocks; ++b) {
        uint32_t phys = disk.getSystemBlocks() + superBlockBlocks + static_cast<uint32_t>(b);
        size_t start = b * disk.blockSize;
        size_t end = (std::min)(start + (size_t)disk.blockSize, big.size());
        std::vector<char> blk(big.begin() + start, big.begin() + end);
        disk.writeData(blk, VirtualDisk::Extent(phys, 1), "", true);
    }

    UpdateSuperblockForDynamicInodes();
}

void MiniHSFS::LoadBTree() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    try {
        // Load root data from disk
        auto rootData = disk.readData(VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + rootNodeIndex), 1 });

        // Use the correct btreeOrder in the configuration
        BTreeNode rootNode(btreeOrder);
        DeserializeBTreeNode(rootNode, rootData.data());

        // Store root in cache
        btreeCache[rootNodeIndex] = std::move(rootNode);
        TouchBTreeNode(rootNodeIndex);
    }
    catch (...) {
        // If the upload fails, rebuild the tree from scratch.
        InitializeBTree();
    }
}

void MiniHSFS::SaveBTree() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    for (auto& entry : btreeCache) {
        if (entry.second.isDirty) {
            SaveBTreeNode(entry.first, entry.second);
            entry.second.isDirty = false;
        }
    }
}

MiniHSFS::BTreeNode MiniHSFS::LoadBTreeNode(int nodeIndex) {
    try {
        if (nodeIndex < 0 || nodeIndex >= btreeBlocks) {
            throw std::out_of_range("Invalid B-tree node index");
        }

        auto it = btreeCache.find(nodeIndex);
        if (it != btreeCache.end()) {
            it->second.accessCount++;
            TouchBTreeNode(nodeIndex);
            return it->second;
        }

        // Load node data from disk
        auto nodeData = disk.readData(
            VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + nodeIndex), 1 });

        BTreeNode node(btreeOrder);
        DeserializeBTreeNode(node, nodeData.data());

        node.accessCount = 1;
        btreeCache[nodeIndex] = node;
        TouchBTreeNode(nodeIndex);

        btreeLoadCounter++;
        if (btreeLoadCounter >= 100) {
            for (auto& entry : btreeCache) {
                entry.second.accessCount /= 2;
            }
            btreeLoadCounter = 0;
        }

        return node;
    }
    catch (const std::bad_alloc&) {
        std::cerr << "!! Memory pressure detected during BTree node load. Clearing BTree cache.\n";
        btreeCache.clear();
        btreeLruMap.clear();
        btreeLruList.clear();
        throw;
    }
}

void MiniHSFS::SaveBTreeNode(int nodeIndex, const BTreeNode& node) {
    if (nodeIndex < 0 || nodeIndex >= btreeBlocks) {
        throw std::out_of_range("Invalid B-tree node index");
    }

    std::vector<char> buffer(disk.blockSize, 0);
    SerializeBTreeNode(node, buffer.data());

    disk.writeData(buffer,
        VirtualDisk::Extent{ static_cast<uint32_t>(btreeStartIndex + nodeIndex), 1 },
        "", true);

    // Update the cache without resetting the entire node
    auto it = btreeCache.find(nodeIndex);
    if (it != btreeCache.end()) {
        it->second.isDirty = false;
    }
    else {
        btreeCache[nodeIndex] = node;
        btreeCache[nodeIndex].isDirty = false;
    }

    TouchBTreeNode(nodeIndex);
}

/////////////////////////////File System Operations

VirtualDisk::Extent MiniHSFS::AllocateContiguousBlocks(int blocksNeeded) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    if (blocksNeeded <= 0) {
        throw std::invalid_argument("Block count must be positive");
    }

    // First: Try customizing directly
    try {

        VirtualDisk::Extent extent = disk.allocateBlocks(blocksNeeded);

        if (extent.blockCount > 100)
        {
            for (uint32_t i = 0; i < extent.blockCount; ++i) {
                MarkBlockUsed(extent.startBlock + i);
            }
        }
        else
            MarkBlocksUsed(extent);

        return extent;
    }
    catch (const VirtualDisk::DiskFullException&) {
        // If it fails, defragment and try again
        DefragmentDisk();

        // Try allocating again after defragmenting
        try {
            VirtualDisk::Extent extent = disk.allocateBlocks(blocksNeeded);
            for (uint32_t i = 0; i < extent.blockCount; ++i) {
                MarkBlockUsed(extent.startBlock + i);
            }
            return extent;
        }
        catch (const VirtualDisk::DiskFullException&) {
            VirtualDisk::Extent extent(-1, 0);
            return extent;
        }
    }
}

int MiniHSFS::AllocateInode(bool isDirectory) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    // First attempt: Use an existing free node
    if (!freeInodesList.empty()) {
        int idx = freeInodesList.front();
        freeInodesList.erase(freeInodesList.begin());
        return InitializeInode(idx, isDirectory);
    }

    // Second attempt: Find an unused node
    for (size_t i = 1; i < inodeTable.size(); ++i) {
        if (!inodeTable[i].isUsed) {
            return InitializeInode(static_cast<int>(i), isDirectory);
        }
    }

    // Third attempt: Expanding using Defragmentation

    if (!DefragmentAndExtendInodes(10)) { // Add 10 nodes at once
        throw std::runtime_error("Cannot allocate inode - no space even after defrag");
    }

    // Search again after expansion
    for (size_t i = 1; i < inodeTable.size(); ++i) {
        if (!inodeTable[i].isUsed) {
            return InitializeInode(static_cast<int>(i), isDirectory);
        }
    }

    throw std::runtime_error("Failed to allocate inode after expansion");
}

std::vector<std::string> MiniHSFS::SplitPath(const std::string& path) const {
    std::vector<std::string> components;
    if (path.empty() || path == "/") return components;

    const char* start = path.data() + 1; // Skip leading '/'
    const char* end = path.data() + path.size();

    while (start < end) {
        const char* slash = std::find(start, end, '/');
        components.emplace_back(start, slash);
        start = slash + (slash != end);
    }

    return components;
}

void MiniHSFS::ValidatePath(const std::string& path) {
    if (path.empty()) {
        throw std::invalid_argument("Path cannot be empty");
    }

    if (path.length() > maxPathLength) {
        throw std::invalid_argument("Path too long");
    }

    if (path[0] != '/') {
        throw std::invalid_argument("Path must be absolute");
    }
}

int MiniHSFS::PathToInode(const std::vector<std::string>& path) {
    int currentInode = 0; // Start at root

    for (const auto& component : path) {
        if (!inodeTable[currentInode].isDirectory) {
            return -1; // Not a directory
        }

        auto it = inodeTable[currentInode].entries.find(component);
        if (it == inodeTable[currentInode].entries.end()) {
            return -1; // Component not found
        }

        currentInode = it->second;
    }

    return currentInode;
}

void MiniHSFS::ValidateInode(int inodeIndex, bool checkDirectory) {
    // Check the validity of the inode number
    if (inodeIndex < 0 || inodeIndex >= inodeCount) {
        throw std::out_of_range("Invalid inode index");
    }

    // Check if inode is in use
    if (!inodeTable[inodeIndex].isUsed) {
        throw std::runtime_error("Inode not in use");
    }

    // If checkDirectory is enabled, we check if the inode represents a directory.
    if (checkDirectory && !inodeTable[inodeIndex].isDirectory) {
        throw std::runtime_error("Not a directory");
    }
}

/////////////////////////////Printing Operation

void MiniHSFS::PrintSuperblockInfo() {
    SuperblockInfo info = LoadSuperblock();

    auto printField = [](const std::string& label, const std::string& value) {
        std::cout << "\033[1m\033[34m" << label << ":\033[0m " << "\033[32m" << value << "\033[0m\n";
        };

    printField("Filesystem Magic", std::string(info.magic, strnlen(info.magic, sizeof(info.magic))));

    std::ostringstream version;
    version << (info.version >> 16) << "."
        << ((info.version >> 8) & 0xFF) << "."
        << (info.version & 0xFF);
    printField("Version", version.str());
    printField("System Blocks Total", std::to_string(info.systemSize));
    printField("Block Size", std::to_string(info.blockSize));
    printField("Inode Size", std::to_string(info.inodeSize));
    printField("Total Blocks", std::to_string(info.totalBlocks));
    printField("Free Blocks", std::to_string(info.freeBlocks));
    printField("Total Inodes", std::to_string(info.totalInodes));
    printField("Free Inodes", std::to_string(info.freeInodes));

    char buffer[26];
#ifdef _WIN32
    ctime_s(buffer, sizeof(buffer), &info.creationTime);
#else
    ctime_r(&info.creationTime, buffer);
#endif
    printField("Created", std::string(buffer));
#ifdef _WIN32
    ctime_s(buffer, sizeof(buffer), &info.lastMountTime);
#else
    ctime_r(&info.lastMountTime, buffer);
#endif
    printField("Last Mount", std::string(buffer));
#ifdef _WIN32
    ctime_s(buffer, sizeof(buffer), &info.lastWriteTime);
#else
    ctime_r(&info.lastWriteTime, buffer);
#endif
    printField("Last Write", std::string(buffer));

    printField("State", std::to_string(info.state));
}

void MiniHSFS::PrintBTreeStructure() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    if (!mounted) {
        std::cout << "\033[1m\033[31mFilesystem not mounted\033[0m\n";
        return;
    }

    std::cout << "\n\033[1m\033[34mB-Tree Structure (Root: " << rootNodeIndex << ")\033[0m\n";
    std::cout << "\033[34m----------------------------------------\033[0m\n";

    // Map to track visited nodes
    std::unordered_set<int> visitedNodes;

    //Defining the NodeInfo structure inside a function
    struct NodeInfo {
        int index;
        int level;
        bool from_next_leaf;
    };

    std::deque<NodeInfo> nodes;
    nodes.push_back({ rootNodeIndex, 0, false });

    while (!nodes.empty()) {
        NodeInfo current = nodes.front();
        nodes.pop_front();

        // Skip if this node has already been visited
        if (visitedNodes.count(current.index)) {
            continue;
        }
        visitedNodes.insert(current.index);

        try {
            BTreeNode node = LoadBTreeNode(current.index);

            // Indents by level
            for (int i = 0; i < current.level; i++) {
                std::cout << (i == current.level - 1 ? "\033[90m|-- " : "\033[90m|   ");
            }

            // Node information
            std::cout << "\033[1m\033[36m[" << current.index << "] "
                << (node.isLeaf ? "\033[32mLeaf\033[0m" : "\033[33mNode\033[0m")
                << " (" << node.keyCount << " keys)\033[0m: ";

            // Print keys and values
            for (int i = 0; i < node.keyCount; i++) {
                std::cout << "\033[35m" << node.keys[i] << "\033[0m";
                if (node.isLeaf) {
                    std::cout << (node.values[i] ? "\033[92m(U)\033[0m" : "\033[90m(F)\033[0m");
                }
                if (i < node.keyCount - 1) std::cout << ", ";
            }

            // Print children's indicators for internal nodes
            if (!node.isLeaf) {
                std::cout << " \033[34m[Children: ";
                for (int i = 0; i <= node.keyCount; i++) {
                    if (node.children[i] != -1) {
                        std::cout << node.children[i];
                        if (i < node.keyCount) std::cout << ", ";
                    }
                }
                std::cout << "]\033[0m";
            }

            // Print the next sheet index if present
            if (node.isLeaf && node.nextLeaf != -1) {
                std::cout << " \033[90m-> Next: " << node.nextLeaf << "\033[0m";
            }

            std::cout << std::endl;

            // Add contract to waiting list
            if (!node.isLeaf && !current.from_next_leaf) {
                // For internal nodes: Add children
                for (int i = node.keyCount; i >= 0; i--) {
                    if (node.children[i] != -1) {
                        nodes.push_front({ node.children[i], current.level + 1, false });
                    }
                }
            }
            else if (node.isLeaf && node.nextLeaf != -1) {
                // For paper knots: Follow the chain
                nodes.push_back({ node.nextLeaf, current.level, true });
            }
        }
        catch (const std::exception& e) {
            std::cout << "\033[1m\033[31mError loading node " << current.index
                << ": " << e.what() << "\033[0m\n";
        }
    }

    std::cout << "\033[34m----------------------------------------\033[0m\n";
    std::cout << "Total nodes visited: " << visitedNodes.size() << std::endl;
}

/////////////////////////////Helper Function

int MiniHSFS::FindFreeBlock() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    auto searchFreeBlock = [this]() -> int {
        int currentLeaf = rootNodeIndex;

        // Move to the first leaf node
        while (!btreeCache[currentLeaf].isLeaf) {
            currentLeaf = btreeCache[currentLeaf].children[0];
        }

        // Search paper nodes
        while (currentLeaf != -1) {
            BTreeNode& leaf = btreeCache[currentLeaf];

            for (int i = 0; i < leaf.keyCount; ++i) {
                if (leaf.values[i] == 0) {  //Free block
                    int block = leaf.keys[i];

                    // Check block scope and grouping preference
                    if (block >= dataStartIndex) {
                        // Prefer contiguous blocks (optimize for fragmentation)
                        if (i + 1 < leaf.keyCount && leaf.values[i + 1] == 0) {
                            return leaf.keys[i + 1];  // Return the next block to help with contiguous allocation
                        }
                        return block;
                    }
                }
            }
            currentLeaf = leaf.nextLeaf;  // Move to the next leaf node
        }
        return -1;  // No free blocks found
        };

    //First attempt
    int freeBlock = searchFreeBlock();
    if (freeBlock != -1) return freeBlock;

    // If there are no free blocks, perform defragmentation.
    DefragmentDisk();

    // Second attempt after defragmentation
    return searchFreeBlock();
}

std::vector<MiniHSFS::FileInfo> MiniHSFS::FindFilesInRange(uint32_t startBlock, uint32_t endBlock) {
    std::vector<FileInfo> files;

    for (size_t i = 1; i < inodeTable.size(); ++i) {
        if (inodeTable[i].isUsed && !inodeTable[i].isDirectory && inodeTable[i].blocksUsed > 0) {
            uint32_t fileStart = inodeTable[i].firstBlock;
            uint32_t fileEnd = fileStart + inodeTable[i].blocksUsed - 1;

            if (fileStart >= startBlock && fileStart < endBlock) {
                FileInfo info;
                info.inodeIndex = i;
                info.startBlock = fileStart;
                info.blockCount = inodeTable[i].blocksUsed;
                files.push_back(info);
            }
        }
    }

    // Sort by start block
    std::sort(files.begin(), files.end(),
        [](const FileInfo& a, const FileInfo& b) { return a.startBlock < b.startBlock; });

    return files;
}

uint32_t MiniHSFS::FindFreeSpaceAtEnd(size_t requiredBlocks) {
    uint32_t totalBlocks = disk.totalBlocks();
    uint32_t freeBlocksFound = 0;
    uint32_t startBlock = 0;

    // Search from end to start
    for (int32_t block = totalBlocks - 1; block >= 0 && freeBlocksFound < requiredBlocks; --block) {
        if (!IsBlockUsed(block)) {
            if (freeBlocksFound == 0) {
                startBlock = block;
            }
            freeBlocksFound++;
        }
        else {
            freeBlocksFound = 0;
        }
    }

    return (freeBlocksFound >= requiredBlocks) ? startBlock : 0;
}

int MiniHSFS::FindFile(const std::string& path) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    if (!mounted) throw std::runtime_error("Filesystem not mounted");

    // Fast path for root directory
    if (path == "/") return 0;

    ValidatePath(path);  // Check Right Path
    const auto& components = SplitPath(path);
    if (components.empty()) return 0;

    int currentInode = 0;
    for (const auto& component : components) {
        if (!inodeTable[currentInode].isDirectory)
            return -1;

        auto it = inodeTable[currentInode].entries.find(component);
        if (it == inodeTable[currentInode].entries.end())
            return -1;

        currentInode = it->second;
    }

    return currentInode;
}

void MiniHSFS::MarkBlockUsed(int blockIndex) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    // Quick check of cache first
    auto rootIt = btreeCache.find(rootNodeIndex);
    if (rootIt != btreeCache.end()) {
        BTreeNode& rootNode = rootIt->second;

        // Fast binary search in the root node
        auto it = std::lower_bound(rootNode.keys, rootNode.keys + rootNode.keyCount, blockIndex);
        int pos = it - rootNode.keys;

        if (pos < rootNode.keyCount && rootNode.keys[pos] == blockIndex) {
            if (rootNode.values[pos] != 1) {
                rootNode.values[pos] = 1;
                rootNode.isDirty = true;
            }
            return;  // Updated successfully
        }
    }
    // If not in root, use global insertion
    if (!BTreeInsert(rootNodeIndex, blockIndex, 1)) {
        throw std::runtime_error("Failed to mark block as used");
    }
}

void MiniHSFS::MarkBlocksUsed(const VirtualDisk::Extent& extent) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    // Helper functions
    auto logError = [](const std::string& msg) {
        std::cerr << "\n[ERROR] " << msg << std::endl;
        };

    auto showProgress = [](int processed, int total) {
        int percent = static_cast<int>((processed * 100.0) / total);
        std::cerr << "\rMarking blocks: " << percent << "% ("
            << processed << "/" << total << ")" << std::flush;
        };

    // Validate input
    if (extent.startBlock < dataStartIndex || extent.startBlock + extent.blockCount > disk.totalBlocks()) {
        std::ostringstream msg;
        msg << "Invalid block range [" << extent.startBlock << ", "
            << extent.startBlock + extent.blockCount << "]";
        logError(msg.str());
        throw std::invalid_argument(msg.str());
    }

    const int totalBlocks = extent.blockCount;
    int processed = 0;
    bool hasErrors = false;

    // Processing large batches
    constexpr int batchThreshold = 2;
    if (totalBlocks >= batchThreshold) {
        try {
            int currentBlock = extent.startBlock;
            int remaining = totalBlocks;
            int lastUsedNodeIndex = -1;
            BTreeNode lastUsedNode(btreeOrder);
            bool hasLastNode = false;

            while (remaining > 0) {
                // Find the appropriate node
                int nodeIndex = rootNodeIndex;
                BTreeNode node;

                if (hasLastNode && currentBlock > lastUsedNode.keys[0] &&
                    currentBlock < lastUsedNode.keys[lastUsedNode.keyCount - 1]) {
                    nodeIndex = lastUsedNodeIndex;
                    node = lastUsedNode;
                }
                else {
                    int cur = rootNodeIndex;
                    node = LoadBTreeNode(cur);

                    while (!node.isLeaf) {
                        int i = 0;
                        while (i < node.keyCount && currentBlock > node.keys[i]) i++;
                        cur = node.children[i];
                        node = LoadBTreeNode(cur);
                    }
                    nodeIndex = cur;
                }

                // Insert blocks into the node
                int available = (btreeOrder - 1) - node.keyCount;
                int blocksToInsert = (std::min)(remaining, available);

                for (int i = 0; i < blocksToInsert; ++i) {
                    int key = currentBlock;
                    int pos = 0;

                    // Find the right position
                    while (pos < node.keyCount && key > node.keys[pos]) pos++;

                    if (pos < node.keyCount&& node.keys[pos] == key) {
                        node.values[pos] = 1; // Update an existing block
                    }
                    else {
                        // Insert a new block
                        for (int j = node.keyCount; j > pos; --j) {
                            node.keys[j] = node.keys[j - 1];
                            node.values[j] = node.values[j - 1];
                        }
                        node.keys[pos] = key;
                        node.values[pos] = 1;
                        node.keyCount++;
                    }

                    currentBlock++;
                    remaining--;
                    processed++;
                    showProgress(processed, totalBlocks);
                }

                node.isDirty = true;
                SaveBTreeNode(nodeIndex, node);

                lastUsedNode = node;
                lastUsedNodeIndex = nodeIndex;
                hasLastNode = true;

                if (remaining > 0 && node.keyCount == btreeOrder - 1) {
                    if (node.nextLeaf == -1) break;
                }
            }
        }
        catch (const std::exception& e) {
            logError(std::string("Batch processing failed: ") + e.what());
            hasErrors = true;
        }
    }

    // Process the remaining blocks individually
    if (processed < totalBlocks) {
        for (uint32_t i = processed; i < totalBlocks; ++i) {
            try {
                BTreeInsert(rootNodeIndex, extent.startBlock + i, 1);
                processed++;
                showProgress(processed, totalBlocks);
            }
            catch (const std::exception& e) {
                logError("Failed to mark block " + std::to_string(extent.startBlock + i) +
                    ": " + e.what());
                hasErrors = true;
            }
        }
    }
    std::cout << "" << std::endl;
}

bool MiniHSFS::MoveFileBlocks(int inodeIndex, uint32_t oldStart, uint32_t newStart, uint32_t blockCount) {
    try {
        // Read data
        std::vector<char> fileData = disk.readData(VirtualDisk::Extent(oldStart, blockCount));

        // Writing data to the new location
        disk.writeData(fileData, VirtualDisk::Extent(newStart, blockCount), "", true);

        // Update the Inode
        inodeTable[inodeIndex].firstBlock = newStart;
        inodeTable[inodeIndex].isDirty = true;

        // Free up old space
        std::vector<char> zeroBlock(disk.blockSize, 0);
        for (uint32_t i = 0; i < blockCount; ++i) {
            disk.writeData(zeroBlock, VirtualDisk::Extent(oldStart + i, 1), "", true);
        }

        // Update the B-tree
        for (uint32_t i = 0; i < blockCount; ++i) {
            BTreeDelete(rootNodeIndex, oldStart + i);
            BTreeInsert(rootNodeIndex, newStart + i, 1);
        }

        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "Error moving file blocks: " << e.what() << std::endl;
        return false;
    }
}

void MiniHSFS::RollbackMoves(const std::vector<DataMoveOperation>& moves) {
    std::cout << "Rolling back " << moves.size() << " file moves..." << std::endl;

    for (const auto& op : moves) {
        if (op.success) {
            //Return the file to its original location
            MoveFileBlocks(op.inodeIndex, op.newStartBlock, op.oldStartBlock, op.blockCount);
        }
    }
}

int MiniHSFS::GetInodeIndex(const Inode& inode) const {
    for (int i = 0; i < inodeTable.size(); ++i) {
        if (&inodeTable[i] == &inode) {
            return i;
        }
    }
    throw std::runtime_error("Inode not found in inodeTable");
}

bool MiniHSFS::FreeFileBlocks(Inode& inode) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    if (!inode.isUsed || inode.firstBlock == -1 || inode.blocksUsed == 0)
        return true;  //No need to free

    try {
        for (int i = 0; i < inode.blocksUsed; ++i) {
            int block = inode.firstBlock + i;

            if (block >= 0 && block < Disk().totalBlocks()) {
                if (Disk().getBitmap()[block]) {
                    Disk().setBitmap(block, false);
                }

                BTreeDelete(rootNodeIndex, block);
            }
        }

        // Remove blocks from the disk
        disk.freeBlocks(VirtualDisk::Extent(inode.firstBlock, inode.blocksUsed));

        // Update the inode
        inode.firstBlock = -1;
        inode.blocksUsed = 0;
        inode.isDirty = true;
        UpdateInodeTimestamps(GetInodeIndex(inode), true);
        SaveInodeToDisk(GetInodeIndex(inode));

        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "Error freeing file blocks: " << e.what() << "\n";
        return false;
    }
}

void MiniHSFS::FreeInode(int index) {
    if (index <= 0 || static_cast<size_t>(index) >= inodeTable.size()) return;

    // Edit blocks first
    if (inodeTable[index].isUsed) {
        if (!inodeTable[index].isDirectory) {
            FreeFileBlocks(inodeTable[index]);
        }
        else {
            inodeTable[index].entries.clear();
        }
    }

    // Reset to safe default values
    inodeTable[index] = Inode();
    inodeTable[index].isUsed = false;

    if (inodeBitmap.size() > static_cast<size_t>(index)) {
        inodeBitmap[index] = false;
    }

    RebuildFreeInodesList();
    UpdateSuperblockForDynamicInodes();
    SaveInodeToDisk(index); // Save changes to disk
}

bool MiniHSFS::IsBlockUsed(int blockIndex) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    auto result = BTreeFind(rootNodeIndex, blockIndex);
    return result.first && result.second == 1;
}

void MiniHSFS::UpdateInodeTimestamps(int inodeIndex, bool modify) {
    if (inodeIndex < 0 || inodeIndex >= inodeCount) return;

    time_t now = time(nullptr);
    inodeTable[inodeIndex].lastAccessed = now;

    if (modify) {
        inodeTable[inodeIndex].modificationTime = now;
    }
    else if (inodeTable[inodeIndex].creationTime == 0) {
        inodeTable[inodeIndex].creationTime = now;
        inodeTable[inodeIndex].modificationTime = now;
    }

    inodeTable[inodeIndex].isDirty = true;
}

////////////////////////////Calculation Operation

void MiniHSFS::CalculatePercentage(double inodePercentage, double btreePercentage)
{
    this->inodePercentage = inodePercentage;
    this->btreePercentage = btreePercentage;
}

size_t MiniHSFS::CalculateInodeCount() {
    if (inodePercentage > 1)
        return inodePercentage;

    size_t diskSizeBytes = disk.totalBlocks() * disk.blockSize;

    double inodeAreaSize = static_cast<double>(diskSizeBytes) * inodePercentage;
    size_t inodeCount = static_cast<size_t>(inodeAreaSize / inodeSize);

    return std::max<size_t>(inodeCount, 32);//Minimum 32 blocks
}

size_t MiniHSFS::CalculateInodeBlocks() {
    return static_cast<size_t>(std::ceil(static_cast<double>(inodeCount * inodeSize) / disk.blockSize));
}

size_t MiniHSFS::CalculateBTreeBlocks() {
    if (btreePercentage > 1)
        return btreePercentage;

    size_t totalBlocks = disk.totalBlocks();
    size_t suggested = static_cast<size_t>(std::ceil(totalBlocks * btreePercentage));
    return std::max<size_t>(suggested, 16); //Minimum 16 blocks
}

size_t MiniHSFS::CalculateBTreeOrder() {
    return (disk.blockSize - (sizeof(bool) + sizeof(int) * 2)) / (sizeof(int) * 2);
}

size_t MiniHSFS::CountFreeInodes() {
    size_t count = 0;
    for (size_t i = 0; i < inodeTable.size(); ++i) {
        if (!inodeTable[i].isUsed) {
            count++;
        }
    }
    return count;
}

size_t MiniHSFS::getAvailableMemory() {
    return disk.getAvailableMemory();
}

uint32_t MiniHSFS::CalculateChecksum(const char* data, size_t length) {
    uint32_t checksum = 0;
    for (size_t i = 0; i < length; ++i) {
        checksum = (checksum << 3) ^ data[i] ^ (checksum >> 29);
    }
    return checksum;
}

size_t MiniHSFS::CalculateBlocksForNewInodes(size_t inodeCount) {
    if (inodeCount == 0) return 0;

    size_t totalBytes = inodeCount * inodeSize;
    size_t blocksNeeded = (totalBytes + disk.blockSize - 1) / disk.blockSize;

    return blocksNeeded;
}

//////////////////////////////Convertion Operation

size_t MiniHSFS::SerializeInode(const Inode& inode, char* buffer, size_t bufferSize) {
    if (bufferSize < inodeSize) {
        std::cerr << "Buffer too small for inode serialization. Needed: "
            << inodeSize << ", Got: " << bufferSize << std::endl;
        return 0;
    }

    std::memset(buffer, 0, bufferSize);
    size_t offset = 0;

    // Constantly basic fields
    std::memcpy(buffer + offset, &inode.size, sizeof(inode.size));                 offset += sizeof(inode.size);
    std::memcpy(buffer + offset, &inode.blocksUsed, sizeof(inode.blocksUsed));     offset += sizeof(inode.blocksUsed);
    std::memcpy(buffer + offset, &inode.firstBlock, sizeof(inode.firstBlock));     offset += sizeof(inode.firstBlock);

    // flags in one byte to avoid bool size problems
    uint8_t flags = 0;
    if (inode.isDirectory) flags |= 0x01;
    if (inode.isUsed)      flags |= 0x02;
    if (inode.isDirty)     flags |= 0x04;
    std::memcpy(buffer + offset, &flags, sizeof(flags));                           offset += sizeof(flags);

    // timestamps with zero correction
    time_t c = inode.creationTime > 0 ? inode.creationTime : time(nullptr);
    time_t m = inode.modificationTime > 0 ? inode.modificationTime : c;
    time_t a = inode.lastAccessed > 0 ? inode.lastAccessed : c;

    std::memcpy(buffer + offset, &c, sizeof(c));                                   offset += sizeof(c);
    std::memcpy(buffer + offset, &m, sizeof(m));                                   offset += sizeof(m);
    std::memcpy(buffer + offset, &a, sizeof(a));                                   offset += sizeof(a);

    // The contents of the directory within the same inode (if it is a Directory and used)
    if (inode.isDirectory && inode.isUsed) {
        uint32_t count = static_cast<uint32_t>(inode.entries.size());
        if (offset + sizeof(count) > bufferSize) count = 0; //No space
        if (count) {
            std::memcpy(buffer + offset, &count, sizeof(count));                   offset += sizeof(count);

            for (const auto& kv : inode.entries) {
                const std::string& name = kv.first;
                uint16_t nameLen = static_cast<uint16_t>(name.size());
                size_t need = sizeof(nameLen) + nameLen + sizeof(int);
                if (offset + need > bufferSize) break;

                std::memcpy(buffer + offset, &nameLen, sizeof(nameLen));           offset += sizeof(nameLen);
                if (nameLen) {
                    std::memcpy(buffer + offset, name.data(), nameLen);            offset += nameLen;
                }
                std::memcpy(buffer + offset, &kv.second, sizeof(kv.second));       offset += sizeof(kv.second);
            }
        }
    }

    // checksum of the above
    uint32_t checksum = CalculateChecksum(buffer, offset);
    if (offset + sizeof(checksum) <= bufferSize) {
        std::memcpy(buffer + offset, &checksum, sizeof(checksum));                 offset += sizeof(checksum);
    }

    return offset;
}

size_t MiniHSFS::DeserializeInode(Inode& inode, const char* buffer, size_t bufferSize) {
    if (bufferSize < inodeSize) {
        std::cerr << "Buffer too small for inode deserialization. Needed: "
            << inodeSize << ", Got: " << bufferSize << std::endl;
        return 0;
    }

    std::vector<char> copy(buffer, buffer + bufferSize);
    size_t offset = 0;

    try {
        // Basic fields
        std::memcpy(&inode.size, buffer + offset, sizeof(inode.size));        offset += sizeof(inode.size);
        std::memcpy(&inode.blocksUsed, buffer + offset, sizeof(inode.blocksUsed));  offset += sizeof(inode.blocksUsed);
        std::memcpy(&inode.firstBlock, buffer + offset, sizeof(inode.firstBlock));  offset += sizeof(inode.firstBlock);


        // flags
        uint8_t flags = 0;
        std::memcpy(&flags, buffer + offset, sizeof(flags));                         offset += sizeof(flags);
        inode.isDirectory = (flags & 0x01) != 0;
        inode.isUsed = (flags & 0x02) != 0;
        inode.isDirty = (flags & 0x04) != 0;

        // timestamps with correction for illogical values
        std::memcpy(&inode.creationTime, buffer + offset, sizeof(inode.creationTime));    offset += sizeof(inode.creationTime);
        std::memcpy(&inode.modificationTime, buffer + offset, sizeof(inode.modificationTime)); offset += sizeof(inode.modificationTime);
        std::memcpy(&inode.lastAccessed, buffer + offset, sizeof(inode.lastAccessed));    offset += sizeof(inode.lastAccessed);

        time_t now = time(nullptr);
        if (inode.creationTime <= 0 || inode.creationTime > now + 3600)        inode.creationTime = now;
        if (inode.modificationTime <= 0 || inode.modificationTime > now + 3600)inode.modificationTime = inode.creationTime;
        if (inode.lastAccessed <= 0 || inode.lastAccessed > now + 3600)        inode.lastAccessed = inode.creationTime;

        // Directory content if Directory + Used
        inode.entries.clear();
        if (inode.isDirectory && inode.isUsed && offset < bufferSize) {
            if (offset + sizeof(uint32_t) <= bufferSize) {
                uint32_t count = 0;
                std::memcpy(&count, buffer + offset, sizeof(count));                   offset += sizeof(count);
                for (uint32_t i = 0; i < count && offset < bufferSize; ++i) {
                    if (offset + sizeof(uint16_t) > bufferSize) break;
                    uint16_t nameLen = 0;
                    std::memcpy(&nameLen, buffer + offset, sizeof(nameLen));           offset += sizeof(nameLen);

                    if (offset + nameLen > bufferSize) break;
                    std::string name(nameLen, '\0');
                    if (nameLen) {
                        std::memcpy(&name[0], buffer + offset, nameLen);               offset += nameLen;
                    }

                    if (offset + sizeof(int) > bufferSize) break;
                    int child = -1;
                    std::memcpy(&child, buffer + offset, sizeof(child));               offset += sizeof(child);

                    if (child > 0) inode.entries.emplace(std::move(name), child);
                }
            }
        }

        // Check the checksum if it exists
        if (offset + sizeof(uint32_t) <= bufferSize) {
            uint32_t stored = 0;
            std::memcpy(&stored, buffer + offset, sizeof(stored));
            uint32_t calc = CalculateChecksum(copy.data(), offset);
            if (stored != calc) {
                std::cerr << "Checksum mismatch in inode  treating as invalid.\n";
                inode = Inode();
                return 0;
            }
            offset += sizeof(uint32_t);
        }

        return offset;
    }
    catch (...) {
        inode = Inode();
        return 0;
    }
}

void MiniHSFS::SerializeBTreeNode(const BTreeNode& node, char* buffer) {
    size_t offset = 0;
    int order = node.order;

    if (node.keyCount < 0 || node.keyCount > order - 1) {
        throw std::runtime_error("SerializeBTreeNode: Invalid key_count value");
    }

    auto write = [&](const void* data, size_t size) {
        if (offset + size > disk.blockSize) throw std::runtime_error("SerializeBTreeNode: buffer overflow");
        std::memcpy(buffer + offset, data, size);
        offset += size;
        };

    write(&node.isLeaf, sizeof(bool));
    write(&node.keyCount, sizeof(int));
    write(&node.order, sizeof(int));
    write(node.keys, sizeof(int) * (order - 1));

    if (node.isLeaf) {
        write(node.values, sizeof(int) * (order - 1));
        write(&node.nextLeaf, sizeof(int));
    }
    else {
        write(node.children, sizeof(int) * order);
    }
}

void MiniHSFS::DeserializeBTreeNode(BTreeNode& node, const char* buffer) {
    size_t offset = 0;
    bool isLeaf;
    int key_count, order;

    auto read = [&](void* dest, size_t size) {
        if (offset + size > disk.blockSize) throw std::runtime_error("DeserializeBTreeNode: buffer underflow");
        std::memcpy(dest, buffer + offset, size);
        offset += size;
        };

    read(&isLeaf, sizeof(bool));
    read(&key_count, sizeof(int));
    read(&order, sizeof(int));

    if (key_count < 0 || key_count > order - 1) {
        throw std::runtime_error("DeserializeBTreeNode: Invalid key count");
    }

    node = BTreeNode(order, isLeaf);
    node.keyCount = key_count;

    read(node.keys, sizeof(int) * (order - 1));
    if (isLeaf) {
        read(node.values, sizeof(int) * (order - 1));
        read(&node.nextLeaf, sizeof(int));
    }
    else {
        read(node.children, sizeof(int) * order);
    }
}

//////////////////////////////Defragment Blocks

bool MiniHSFS::DefragmentAndExtendInodes(size_t extraInodes) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    std::cout << "Defragmenting to add " << extraInodes << " inodes..." << std::endl;

    // Calculate requirements
    size_t currentInodes = inodeTable.size();
    size_t newTotalInodes = currentInodes + extraInodes;
    size_t currentBlocks = inodeBlocks;
    size_t neededBlocks = CalculateBlocksForNewInodes(newTotalInodes);

    std::cout << "Current: " << currentInodes << " inodes, " << currentBlocks << " blocks" << std::endl;
    std::cout << "Needed: " << newTotalInodes << " inodes, " << neededBlocks << " blocks" << std::endl;

    if (neededBlocks <= currentBlocks) {
        std::cout << "No additional blocks needed, just extending in-memory table" << std::endl;
        // Only expand the table in memory
        inodeTable.resize(newTotalInodes);
        inodeBitmap.resize(newTotalInodes, false);
        inodeCount = newTotalInodes;

        // Super Block Update
        UpdateSuperblockForDynamicInodes();

        SaveInodeTable();

        return true;
    }

    size_t additionalBlocks = neededBlocks - currentBlocks;
    std::cout << "Need " << additionalBlocks << " additional blocks for inodes" << std::endl;

    // Determine the expansion location
    uint32_t expansionStart = disk.getSystemBlocks() + superBlockBlocks + inodeBlocks;

    // Find the files that need to be transferred.
    auto filesToMove = FindFilesInRange(expansionStart, expansionStart + additionalBlocks);

    if (filesToMove.empty()) {
        std::cout << "No files need moving, can expand directly" << std::endl;
        return ExpandInodeAreaDirect(additionalBlocks, newTotalInodes);
    }

    std::cout << "Need to move " << filesToMove.size() << " files" << std::endl;

    // Search for free space at the end of the disk
    size_t totalMoveSize = 0;
    for (const auto& file : filesToMove) {
        totalMoveSize += file.blockCount;
    }

    uint32_t freeSpaceStart = FindFreeSpaceAtEnd(additionalBlocks + totalMoveSize);
    if (freeSpaceStart == 0) {
        std::cout << "Not enough free space for defragmentation" << std::endl;
        return false;
    }

    // Transfer files
    std::vector<DataMoveOperation> moveOperations;
    uint32_t currentFreePointer = freeSpaceStart;

    for (const auto& fileInfo : filesToMove) {
        DataMoveOperation op;
        op.inodeIndex = fileInfo.inodeIndex;
        op.oldStartBlock = fileInfo.startBlock;
        op.newStartBlock = currentFreePointer;
        op.blockCount = fileInfo.blockCount;
        op.success = MoveFileBlocks(fileInfo.inodeIndex, op.oldStartBlock, op.newStartBlock, op.blockCount);

        moveOperations.push_back(op);
        currentFreePointer += fileInfo.blockCount;

        if (!op.success) {
            std::cerr << "Failed to move file " << fileInfo.inodeIndex << std::endl;
            RollbackMoves(moveOperations);
            return false;
        }
    }

    // Expansion after freeing up space
    if (!ExpandInodeAreaDirect(additionalBlocks, newTotalInodes)) {
        std::cerr << "Failed to expand inode area after moving files" << std::endl;
        RollbackMoves(moveOperations);
        return false;
    }

    std::cout << "Successfully added " << extraInodes << " inodes after defragmentation" << std::endl;
    return true;
}

void MiniHSFS::DefragmentFileBlocks(int inodeIndex) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);
    ValidateInode(inodeIndex);

    MiniHSFS::Inode& inode = inodeTable[inodeIndex];

    if (inode.isDirectory || inode.blocksUsed <= 1)
        return;

    // 1. Read data with proper encryption handling
    VirtualDisk::Extent oldExtent(inode.firstBlock, inode.blocksUsed);
    std::vector<char> fileData;

    // Read normally
    fileData = disk.readData(oldExtent);

    // 2. Free old blocks
    for (int i = 0; i < (int)oldExtent.blockCount; ++i) {
        BTreeDelete(rootNodeIndex, oldExtent.startBlock + i);
    }
    disk.freeBlocks(oldExtent);

    // 3. Allocate new contiguous blocks
    VirtualDisk::Extent newExtent = AllocateContiguousBlocks(inode.blocksUsed);
    if (newExtent.startBlock == -1) {
        throw std::runtime_error("Failed to allocate blocks during defragmentation");
    }

    // 4. Write data with proper encryption handling
    if (!disk.writeData(fileData, newExtent, "", false)) {
        throw std::runtime_error("Failed to write data during defragmentation");
    }

    // 5. Update inode information
    inode.firstBlock = newExtent.startBlock;
    inode.blocksUsed = newExtent.blockCount;
    inode.isDirty = true;
    UpdateInodeTimestamps(inodeIndex, true);
}

void MiniHSFS::DefragmentDisk() {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    // Collect information about files that need to be defragmented
    std::vector<int> filesToDefrag;
    for (int i = 0; i < inodeCount; ++i) {
        if (inodeTable[i].isUsed &&
            !inodeTable[i].isDirectory &&
            inodeTable[i].blocksUsed > 1) {
            filesToDefrag.push_back(i);
        }
    }

    // Sort files by fragment size (largest first)
    std::sort(filesToDefrag.begin(), filesToDefrag.end(),
        [this](int a, int b) {
            return inodeTable[a].blocksUsed > inodeTable[b].blocksUsed;
        });

    // Defragment each file and print progress
    int totalFiles = filesToDefrag.size();
    for (int i = 0; i < totalFiles; ++i) {
        int inodeIndex = filesToDefrag[i];
        try {
            DefragmentFileBlocks(inodeIndex);
        }
        catch (const std::exception& e) {
            std::cerr << "Failed to defragment inode " << inodeIndex
                << ": " << e.what() << std::endl;
            continue;
        }

        // Print progress percentage
        int percent = static_cast<int>((i + 1) * 100.0 / totalFiles);
        std::cout << "\rDefragmenting... " << percent << "% completed" << std::flush;
    }

    std::cout << std::endl << "Defragmentation completed." << std::endl;

    // Rebuild the free block map
    RebuildFreeBlockList();
}

//void MiniHSFS::DefragmentDisk() {
//    std::lock_guard<std::recursive_mutex> lock(fsMutex);
//
//    // 1. Collect information about files that need to be defragmented
//    std::vector<int> filesToDefrag;
//    for (int i = 0; i < inodeCount; ++i) {
//        if (inodeTable[i].isUsed &&
//            !inodeTable[i].isDirectory &&
//            inodeTable[i].blocksUsed > 1) {
//            filesToDefrag.push_back(i);
//        }
//    }
//
//    // 2. Sort files by fragment size (largest first)
//    std::sort(filesToDefrag.begin(), filesToDefrag.end(),
//        [this](int a, int b) {
//            return inodeTable[a].blocksUsed > inodeTable[b].blocksUsed;
//        });
//
//    // 3. Defragment each file
//    for (int inodeIndex : filesToDefrag) {
//        try {
//            DefragmentFileBlocks(inodeIndex);
//        }
//        catch (const std::exception& e) {
//            std::cerr << "Failed to defragment inode " << inodeIndex
//                << ": " << e.what() << std::endl;
//            continue;
//        }
//    }
//
//    // 4. Rebuild the free block map
//    RebuildFreeBlockList();
//}

bool MiniHSFS::ExpandInodeAreaByInodes(size_t extraInodes) {
    if (extraInodes == 0) return true;

    size_t oldCount = inodeTable.size();
    size_t newCount = oldCount + extraInodes;

    size_t oldBlocks = CalculateBlocksForNewInodes(oldCount);
    size_t newBlocks = CalculateBlocksForNewInodes(newCount);

    if (newBlocks > inodeBlocks) {
        size_t addBlocks = newBlocks - inodeBlocks;
        VirtualDisk::Extent ext(disk.getSystemBlocks() + superBlockBlocks + inodeBlocks, addBlocks);
        disk.allocateBlocks(ext.blockCount);

        std::vector<char> zero(disk.blockSize, 0);
        for (size_t i = 0; i < addBlocks; ++i)
            disk.writeData(zero, VirtualDisk::Extent(ext.startBlock + i, 1), "", true);

        inodeBlocks = newBlocks;
    }

    // Enlarge structures in memory
    inodeTable.resize(newCount);
    inodeBitmap.resize(newCount, false);
    inodeCount = newCount;

    UpdateSuperblockForDynamicInodes();
    return true;
}

bool MiniHSFS::ExpandInodeAreaDirect(size_t additionalBlocks, size_t newTotalInodes) {
    try {
        // Reserve additional blocks
        VirtualDisk::Extent extent(disk.getSystemBlocks() + superBlockBlocks + inodeBlocks, additionalBlocks);
        disk.allocateBlocks(extent.blockCount);

        // Initialize new blocks
        std::vector<char> zeroBlock(disk.blockSize, 0);
        for (size_t i = 0; i < additionalBlocks; ++i) {
            disk.writeData(zeroBlock,
                VirtualDisk::Extent(extent.startBlock + i, 1), "", true);
        }

        // Update internal variables
        inodeBlocks += additionalBlocks;
        dataStartIndex += additionalBlocks;

        // Expand the table in memory
        inodeTable.resize(newTotalInodes);
        inodeBitmap.resize(newTotalInodes, false);
        inodeCount = newTotalInodes;

        // Super Block Update
        UpdateSuperblockForDynamicInodes();

        return true;

    }
    catch (const std::exception& e) {
        std::cerr << "Error expanding inode area: " << e.what() << std::endl;
        return false;
    }
}

void MiniHSFS::RebuildFreeBlockList() {
    std::vector<int> freeBlocks;

    // Clear all blocks in the data range
    for (int block = dataStartIndex; block < disk.totalBlocks(); ++block) {
        if (!IsBlockUsed(block)) {
            freeBlocks.push_back(block);
        }
    }

    // Reconstruct the B-tree with free blocks
    InitializeBTree();
}

void MiniHSFS::RebuildFreeInodesList() {
    freeInodesList.clear();

    for (size_t i = 1; i < inodeTable.size(); ++i) {
        if (!inodeTable[i].isUsed) {
            freeInodesList.push_back(i);
        }
    }

    // Update the pointer to the next free node
    nextFreeInode = freeInodesList.empty() ? inodeTable.size() : freeInodesList.front();
}

void MiniHSFS::RebuildInodeBitmap() {
    inodeBitmap.clear();
    inodeBitmap.resize(inodeTable.size());
    for (size_t i = 0; i < inodeTable.size(); ++i) {
        inodeBitmap[i] = inodeTable[i].isUsed;
    }
    nextFreeInode = 0;
}

void MiniHSFS::SaveInodeToDisk(int inodeIndex) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    if (inodeIndex < 0 || static_cast<size_t>(inodeIndex) >= inodeTable.size())
        throw std::out_of_range("SaveInodeToDisk: invalid inode index " + std::to_string(inodeIndex));

    // Prepare a fixed inode buffer of inodeSize
    std::vector<char> buf(inodeSize, 0);
    if (SerializeInode(inodeTable[inodeIndex], buf.data(), inodeSize) == 0)
        throw std::runtime_error("SaveInodeToDisk: serialize failed for inode " + std::to_string(inodeIndex));

    // Calculate its position within the inodes area (distance from the beginning of the inodes area)
    const size_t absByte = static_cast<size_t>(inodeIndex) * inodeSize;
    size_t       startBlockRel = absByte / disk.blockSize;
    size_t       offsetInBlock = absByte % disk.blockSize;

    const size_t bytesToWrite = inodeSize;
    size_t       blocksNeeded = (offsetInBlock + bytesToWrite + disk.blockSize - 1) / disk.blockSize;

    // If outside the current space -> expand
    if (startBlockRel + blocksNeeded > static_cast<size_t>(inodeBlocks)) {
        size_t needInodes = ((startBlockRel + blocksNeeded) * disk.blockSize + inodeSize - 1) / inodeSize;
        size_t extra = (needInodes > inodeTable.size()) ? (needInodes - inodeTable.size()) : 0;
        if (extra < 1) extra = 1;
        ExpandInodeAreaByInodes(extra);
    }

    size_t remaining = inodeSize, src = 0;
    for (size_t k = 0; k < blocksNeeded; ++k) {
        uint32_t relBlock = static_cast<uint32_t>(startBlockRel + k);
        uint32_t absBlock = disk.getSystemBlocks() + static_cast<uint32_t>(superBlockBlocks) + relBlock;
        if (absBlock >= disk.totalBlocks())
            throw std::runtime_error("SaveInodeToDisk: absBlock out of range: " + std::to_string(absBlock));

        // Read the block, modify the part for this inode, and then write
        auto diskData = disk.readData(VirtualDisk::Extent(absBlock, 1));
        std::vector<char> blockBuf(disk.blockSize, 0);
        if (!diskData.empty()) {
            std::memcpy(blockBuf.data(), diskData.data(), (std::min)(blockBuf.size(), diskData.size()));
        }

        size_t dest = (k == 0) ? offsetInBlock : 0;
        size_t can = (std::min)(disk.blockSize - dest, remaining);
        std::memcpy(blockBuf.data() + dest, buf.data() + src, can);

        disk.writeData(blockBuf, VirtualDisk::Extent(absBlock, 1), "", true);

        remaining -= can;
        src += can;
    }

    if (remaining != 0)
        throw std::runtime_error("SaveInodeToDisk: incomplete write, remaining bytes = " + std::to_string(remaining));

    inodeTable[inodeIndex].isDirty = false;
}

void MiniHSFS::TouchBTreeNode(int index) {
    std::lock_guard<std::recursive_mutex> lock(fsMutex);

    auto it = btreeCache.find(index);
    if (it != btreeCache.end()) {
        it->second.accessCount++; // Update usage
    }

    if (btreeLruMap.find(index) != btreeLruMap.end()) {
        btreeLruList.erase(btreeLruMap[index]);
    }
    btreeLruList.push_front(index);
    btreeLruMap[index] = btreeLruList.begin();

    if (btreeLruList.size() > std::max<size_t>(1000, static_cast<size_t>((getAvailableMemory() * 0.05) / sizeof(BTreeNode)))) {
        FreeLRUBTreeNode(); // Throw out the least used
    }
}

void MiniHSFS::FreeLRUBTreeNode() {
    if (btreeLruList.empty()) return;

    // Get the oldest node (last in LRU)
    int victimIndex = btreeLruList.back();
    btreeLruList.pop_back();
    btreeLruMap.erase(victimIndex);

    auto it = btreeCache.find(victimIndex);
    if (it != btreeCache.end()) {
        if (it->second.isDirty) {
            SaveBTreeNode(victimIndex, it->second);
        }
        btreeCache.erase(it);
    }
}

//Nowww
------------------------------
Tokenizer.h
------------------------------
#include <string>
#include <ostream>
#include <vector>
#include <memory>
#include <sstream>
#include <iostream>
#include <limits>
#include "MiniHSFS.h"
#include "Parser.h"
#include "run.h"

enum class ProcessState { Ready, Running, Pause, Terminated };

class Tokenizer {

public:

	//Constracter
	Tokenizer();

	//Run Commands
	void processCommand(const std::string& command, MiniHSFS& mini);

	// Process management functions
	int createProcess(const std::string& name, const std::vector<std::string>& args);
	void runAll(MiniHSFS& mini);

	//Search PID Process
	bool isRunning(int pid) const;
	bool isTerminated(int pid) const;
	bool isReady(int pid) const;

	// Process PID Process
	void stopProcess(int pid);
	void monitorProcesses() const;

private:
	//Parser Object
	Parser parse;
	
	//Splits Commands
	std::vector<std::string> ParseArguments(const std::string& input);

	//Send Commant to Parser
	void handleCommand(const std::vector<std::string>& args, MiniHSFS& mini);

	// Process related members
	struct Process {
		int pid;
		std::string name;
		std::vector<std::string> args;
		ProcessState state;
	};

	// Process PID Process
	const Process* findProcess(int pid) const;
	Process* findProcess(int pid);

	//Counter Processing
	int nextPid = 1;
	//Processing Table
	std::vector<Process> processTable;
};

#pragma once

------------------------------
Tokenizer.cpp
------------------------------
#include "Tokenizer.h"

//Constracter
Tokenizer::Tokenizer() {}

//Split '," Commands
std::vector<std::string> Tokenizer::ParseArguments(const std::string& input) {
    std::vector<std::string> args;
    std::string current;
    bool in_quotes = false;

    for (size_t i = 0; i < input.size(); ++i) {
        char c = input[i];

        if (c == '"') {
            in_quotes = !in_quotes;
        }
        else if (c == ' ' && !in_quotes) {
            if (!current.empty()) {
                args.push_back(current);
                current.clear();
            }
        }
        else {
            current += c;
        }
    }

    if (!current.empty()) {
        args.push_back(current);
    }

    return args;
}

//Command Line
void Tokenizer::handleCommand(const std::vector<std::string>& args, MiniHSFS& mini) {

    if (args.empty() || !isReady(nextPid - 1)) return;
   
    findProcess(nextPid - 1)->state = ProcessState::Running;

    if (args[0] == "cd")
        parse.cd(args.size() == 1 ? "/" : args[1], mini);

    else if (args[0] == "ls") {
        std::string options;
        std::string path;

        for (size_t i = 1; i < args.size(); ++i) {
            if (args[i][0] == '-') {
                options += args[i].substr(1);
            }
            else if (path.empty()) {
                path = args[i];
            }
        }

        // Constructing the unified argument
        std::string argument;
        if (!options.empty()) {
            argument += "-" + options;
        }
        if (!path.empty()) {
            if (!argument.empty()) argument += " ";
            argument += path;
        }

        parse.ls(argument, mini);
    }

    else if (args[0] == "info")
        parse.printFileSystemInfo(mini);

    else if (args[0] == "tree")
        parse.PrintBTreeStructure(mini);

    else if ((args[0] == "mkdir" && args.size() > 1) || (args[0] == "md" && args.size() > 1))
        for (int x = 1; x < args.size(); x++)
            parse.createDirectory((args[x][0] != '/' ? run::currentPath + (run::currentPath != "/" ? "/" : "") : args[x]), (args[x][0] != '/' ? args[x] : ""), mini);

    else if ((args[0] == "mkfile" && args.size() > 1) || ((args[0] == "mf" && args.size() > 1)))
        for (int x = 1; x < args.size(); x++)
            parse.createFile((args[1][0] == '/' ? "" : run::currentPath + (run::currentPath != "/" ? "/" : "")), args[x], mini);

    else if ((args[0] == "redir" && args.size() == 3) || (args[0] == "refile" && args.size() == 3) || (args[0] == "rename" && args.size() == 3))
        parse.rename(args[1][0] == '/' ? args[1] : run::currentPath + (run::currentPath != "/" ? "/" : "") + args[1], args[2], mini);

    else if (args[0] == "rd" && args.size() > 1)
        for (int x = 1; x < args.size(); x++)
            parse.deleteDirectory(args[x][0] != '/' ? run::currentPath + (run::currentPath != "/" ? "/" : "") + args[x] : args[x], mini);

    else if (args[0] == "del" && args.size() > 1)
        for (int x = 1; x < args.size(); x++)
            parse.deleteFile(args[x][0] != '/' ? run::currentPath + (run::currentPath != "/" ? "/" : "") + args[x] : args[x], mini);

    else if (args[0] == "open" && args.size() > 1) {
        for (size_t i = 1; i < args.size(); i++) {
            std::string full_path = (args[i][0] != '/')
                ? run::currentPath + (run::currentPath != "/" ? "/" : "") + args[i]
                : args[i];

            try {
                std::vector<char> data = parse.readFile(full_path, mini, 0, true, run::Password);
                std::string str(data.begin(), data.end());
                std::cout << "File content:\n" << str << std::endl;
            }
            catch (const std::exception& e) {
                std::cerr << "Error reading file " << args[i] << ": " << e.what() << std::endl;
            }
        }
    }

    //else if (args[0] == "open" && args.size() > 1) {
    //    //  
    //    const size_t MAX_MEMORY_CHUNK = 10 * 1024 * 1024; // 10MB  
    //    const size_t PRINT_CHUNK_SIZE = 10 * 1024 * 1024; //      (1KB)
    //    bool read_full = false;
    //    bool show_content = true;
    //    bool chunked_mode = false;
//
    //    //  
    //    std::vector<std::string> files;
    //    for (size_t i = 1; i < args.size(); i++) {
    //        if (args[i] == "--full") {
    //            read_full = true;
    //        }
    //        else if (args[i] == "--chunked") {
    //            chunked_mode = true;
    //        }
    //        else if (args[i] == "--no-display") {
    //            show_content = false;
    //        }
    //        else {
    //            files.push_back(args[i]);
    //        }
    //    }
//
    //    if (files.empty()) {
    //        std::cerr << "Error: No files specified" << std::endl;
    //        return;
    //    }
    //
    //    for (const auto& file : files) {
    //        std::string full_path = (file[0] != '/') ?
    //            run::currentPath + '/' + file :
    //            file;
    //
    //        try {
    //            //    
    //            size_t file_size = parse.getFileSize(full_path, mini);
    //            std::cout << "\nProcessing: " << file << " ("
    //                << file_size << " bytes / "
    //                << file_size / (1024 * 1024) << " MB)" << std::endl;
    //
    //            //      
    //            if (read_full && file_size > 100 * 1024 * 1024) {
    //                std::cout << "Warning: Large file size (>100MB).\n"
    //                    << "Use chunked mode? (y/n): ";
    //                char choice;
    //                std::cin >> choice;
    //                if (choice == 'y') {
    //                    read_full = false;
    //                    chunked_mode = true;
    //                }
    //            }
    //
    //            //  
    //            if (read_full || (!chunked_mode && file_size <= MAX_MEMORY_CHUNK)) {
    //                //    
    //                std::vector<char> data = parse.readFile(full_path, mini, true, "123");
    //                std::cout << "Successfully read " << data.size() << " bytes" << std::endl;
    //
    //                //      
    //                if (show_content) {
    //                    std::string content(data.begin(), data.end());
    //                    std::cout << "\nFile content (in chunks):\n";
    //
    //                    for (size_t i = 0; i < content.size(); i += PRINT_CHUNK_SIZE) {
    //                        size_t chunk_length = (std::min)(PRINT_CHUNK_SIZE, content.size() - i);
    //                        std::string chunk = content.substr(i, chunk_length);
    //
    //                        //   
    //                        std::cout << "Chunk " << (i / PRINT_CHUNK_SIZE + 1)
    //                            << " (" << chunk_length << " bytes):\n"
    //                            << chunk << "\n---\n";
    //                    }
    //                }
    //            }
    //            else {
    //                //    
    //                std::cout << "\nReading and printing file in chunks:\n";
    //                size_t total_processed = 0;
    //                size_t chunk_count = 0;
    //                size_t print_chunk_count = 0;
    //
    //                while (total_processed < file_size) {
    //                    chunk_count++;
    //                    size_t remaining = file_size - total_processed;
    //                    size_t chunk_size = (std::min)(MAX_MEMORY_CHUNK, remaining);
    //
    //                    std::cout << "\rReading data chunk " << chunk_count
    //                        << " (" << total_processed / (1024 * 1024) << "MB/"
    //                        << file_size / (1024 * 1024) << "MB)" << std::flush;
    //
    //                    std::vector<char> chunk = parse.readFile(full_path, mini, chunk_size, true, "123");
    //                    total_processed += chunk.size();
    //
    //                    //      
    //                    if (show_content) {
    //                        std::string chunk_str(chunk.begin(), chunk.end());
    //
    //                        for (size_t i = 0; i < chunk_str.size(); i += PRINT_CHUNK_SIZE) {
    //                            size_t print_chunk_size = (std::min)(PRINT_CHUNK_SIZE, chunk_str.size() - i);
    //                            std::string print_chunk = chunk_str.substr(i, print_chunk_size);
//
    //                            print_chunk_count++;
    //                            std::cout << "\nPrint Chunk " << print_chunk_count
    //                                << " (" << print_chunk_size << " bytes):\n"
    //                                << print_chunk << "\n---";
    //                        }
    //                    }
    //                }
//
    //                std::cout << "\nFinished processing " << total_processed
    //                    << " bytes in " << chunk_count << " data chunks" << std::endl;
    //                std::cout << "Printed in " << print_chunk_count << " display chunks" << std::endl;
    //            }
    //        }
    //        catch (const std::exception& e) {
    //            std::cerr << "\nError processing " << file << ": "
    //                << e.what() << std::endl;
    //        }
    //    }
    //}


    else if (args[0] == "write" && args.size() == 2) {
        std::string str;
        std::cout << "Input Data >> ";
        std::getline(std::cin, str);
        std::vector<char> data(27 * 1024 * 1024, 't');
        //std::vector<char> data(str.begin(), str.end());

        std::string full_path = (args[1][0] != '/')
            ? run::currentPath + (run::currentPath != "/" ? "/" : "") + args[1]
            : args[1];

        try {
            if (parse.writeFile(full_path, data, mini, false, run::Password)) {
                std::cout << "File written successfully" << std::endl;
            }
            else {
                std::cerr << "Failed to write file" << std::endl;
            }
        }
        catch (const std::exception& e) {
            std::cerr << "Error writing file: " << e.what() << std::endl;
        }
    }

    //else if (args[0] == "write" && args.size() == 2) {
    //    const uint64_t totalSize =  3; // 2 
    //    const size_t chunkSize = 100 * 1024 * 1024; // 100   
    //
    //    std::vector<char> chunk(chunkSize, 'W'); //  
    //
    //    uint64_t remaining = totalSize;
    //    uint64_t written = 0;
    //
    //    while (remaining > 0) {
    //        size_t currentChunkSize = static_cast<size_t>(std::min<uint64_t>(chunkSize, remaining));
    //
    //        // true     
    //        bool append = (written > 0);
    //
    //        const std::string fullPath = (args[1][0] != '/')
    //            ? run::currentPath + '/' + args[1]
    //            : args[1];
    //
    //        parse.writeFile(fullPath,
    //            std::vector<char>(chunk.begin(), chunk.begin() + currentChunkSize),
    //            mini, append);
    //
    //        written += currentChunkSize;
    //        remaining -= currentChunkSize;
    //
    //        //  
    //        double progress = 100.0 * written / totalSize;
    //        std::cout << "\rProgress: " << std::fixed << std::setprecision(2)
    //            << progress << "% ("
    //            << written / (1024 * 1024) << " MB of "
    //            << totalSize / (1024 * 1024) << " MB)" << std::flush;
    //
    //        // std::this_thread::sleep_for(std::chrono::milliseconds(200)); //  
    //    }
    //
    //    std::cout << "\nFile written successfully! Size: "
    //        << (totalSize / (1024 * 1024)) << " MB" << std::endl;
    //}


    else if (args[0] == "move" && args.size() == 3)
    {
        if (args[1][0] != '/' && args[2][0] != '/')
            parse.move(run::currentPath + (run::currentPath != "/" ? "/" : "") + args[1], run::currentPath + (run::currentPath != "/" ? "/" : "") + args[2], mini);
        else if (args[1][0] == '/' && args[2][0] != '/')
            parse.move(args[1], run::currentPath + (run::currentPath != "/" ? "/" : "") + args[2], mini);
        else if (args[1][0] != '/' && args[2][0] == '/')
            parse.move(run::currentPath + (run::currentPath != "/" ? "/" : "") + args[1], args[2], mini);
        else
            parse.move(args[1], args[2], mini);
    }


    else if ((args[0] == "copy" || args[0] == "cp") && args.size() == 3) {
        std::string src = args[1][0] == '/' ? args[1] : run::currentPath + (run::currentPath != "/" ? "/" : "") + args[1];
        std::string dest = args[2][0] == '/' ? args[2] : run::currentPath + (run::currentPath != "/" ? "/" : "") + args[2];
        parse.copy(src, dest, mini);
    }

    //AI
    else if (args[0] == "AI")
    {
        std::string paths = args[1][0] == '/' ? args[1] : run::currentPath + '/' + args[1];

        std::cout << "Analysis Storage : " << std::endl;
        parse.analyzeStorage(mini);

        std::cout << "Analysis Next Access : " << std::endl;
        parse.predictNextAccess(mini);

        std::cout << "Analysis Optimize File Placement : " << std::endl;
        parse.optimizeFilePlacement(paths,mini);

        std::cout << "Analysis Check Security : " << std::endl;
        parse.checkSecurity(args[0], paths, mini, run::Password);

        std::cout << "Analysis Check Security : " << std::endl;
        parse.checkSecurity(args[0], paths, mini, run::Password);

    }

    else if (args[0] == "cls")
        parse.cls();

    else if (args[0] == "map" && args.size() == 1)
        parse.printBitmap(mini);

    else if (args[0] == "exit")
        parse.exit(mini);
    
    else
        std::cout << "Error: unknown command\n";
}

//Generate Command Line after parse argument
void Tokenizer::processCommand(const std::string& command, MiniHSFS& mini) {
    auto args = ParseArguments(command);

    if (args.empty())return;

    int PID = createProcess(args[0], args);

    try {
        // Execute the actual command
        handleCommand(args, mini);
        processTable.back().state = ProcessState::Terminated;
    }
    catch (const std::exception& e) {
        mini.Disk().SetConsoleColor(mini.Disk().Red);
        std::cerr << "Error executing command: " << e.what() << std::endl;
        mini.Disk().SetConsoleColor(mini.Disk().Default);
        processTable.back().state = ProcessState::Pause;
    }
}

int Tokenizer::createProcess(const std::string& name, const std::vector<std::string>& args) {
    processTable.push_back({ nextPid++, name, args, ProcessState::Ready });
    return nextPid - 1;
}

void Tokenizer::runAll(MiniHSFS& mini) {
    for (auto& p : processTable) {
        if (p.state == ProcessState::Ready || p.state == ProcessState::Pause) {
            p.state = ProcessState::Running;
            std::cout << "\n[Running PID " << p.pid << "]: " << p.name << "\n";
            processCommand(p.name, mini);
            p.state = ProcessState::Terminated;
        }
    }
    processTable.clear();
}

//------------------------------------------//Search PID Process

bool Tokenizer::isRunning(int pid) const {
    const auto* p = findProcess(pid);
    return p && p->state == ProcessState::Running;
}

bool Tokenizer::isTerminated(int pid) const {
    const auto* p = findProcess(pid);
    return p && p->state == ProcessState::Terminated;
}

bool Tokenizer::isReady(int pid) const {
    const auto* p = findProcess(pid);
    return p && p->state == ProcessState::Ready;
}
//------------------------------------------//Process PID Process

Tokenizer::Process* Tokenizer::findProcess(int pid) {
    for (auto& p : processTable) {
        if (p.pid == pid) return &p;
    }
    return nullptr;
}

const Tokenizer::Process* Tokenizer::findProcess(int pid) const {
    for (const auto& p : processTable) {
        if (p.pid == pid) return &p;
    }
    return nullptr;
}

void Tokenizer::stopProcess(int pid) {
    auto* p = findProcess(pid);
    if (p && p->state == ProcessState::Running) {
        p->state = ProcessState::Pause;
    }
}

void Tokenizer::monitorProcesses() const {
    std::cout << "\nActive Processes:\n";
    std::cout << "----------------\n";
    for (const auto& p : processTable) {
        std::cout << "PID: " << p.pid << " | ";
        std::cout << "Command: " << p.name << " | ";
        std::cout << "State: ";

        switch (p.state) {
        case ProcessState::Ready: std::cout << "Ready"; break;
        case ProcessState::Running: std::cout << "Running"; break;
        case ProcessState::Terminated: std::cout << "Terminated"; break;
        }

        std::cout << "\n";
    }
}
------------------------------
SimpleAutoComplete.h
------------------------------
#pragma once
#include <vector>
#include <string>
#include <functional>
#include <memory>
#include <iostream>
#include <algorithm>
#include <chrono>
#include <iomanip>
#include "MiniHSFS.h"
#include "run.h"


#ifdef _WIN32
#include <conio.h>
#include <windows.h>
#else
#include <termios.h>
#include <unistd.h>
#include <sys/ioctl.h>
#endif

class SimpleAutoComplete {
public:

    //Command System
    const std::vector<std::string> builtInCommands = {
    "exit", "quit", "ls", "move", "mv", "write", "open", "read", "copy", "cp",
    "mkfile", "mf", "mkdir", "md", "tree", "info", "cd",
    "redir", "refile", "rename", "rd", "del", "cls", "map", "AI"
    };

    using SuggestionsCallback = std::function<std::vector<std::string>(const std::string&)>;

    SimpleAutoComplete(MiniHSFS& mini);

    ~SimpleAutoComplete();


    std::string getInput() const;
    std::string readInput(const std::string& prompt);
   

private:
    class Impl {
    public:
        std::string inputValue;
        SuggestionsCallback getSuggestions;
        std::vector<std::string> currentMatches;
        size_t currentMatchIndex = 0;
        std::string prompt;
        int terminalWidth = 80;
        bool showSuggestionsFlag = false;
        int tabPressCount = 0;
        std::chrono::steady_clock::time_point lastTabTime;
        std::vector<std::string> commandHistory;
        size_t historyIndex = 0;
        bool inHistoryNavigation = false;

#ifdef _WIN32
        HANDLE hStdin = nullptr;
        DWORD fdwSaveOldMode = 0;
#else
        struct termios origTermios {};
#endif

        void setupConsole();
        void restoreConsole();
        int getch();
        void updateTerminalWidth();
        void showSuggestions(const std::string& input);
        void clearSuggestions();
    };
    
    
    std::unique_ptr<Impl> pimpl;

    void init(SuggestionsCallback callback);

    std::vector<std::string> getCommandSuggestions(const std::string& fullInput);
    std::vector<std::string> getUnifiedSuggestions(const std::string& fullInput, MiniHSFS& mini);
    std::vector<std::string> getFileSystemSuggestions(const std::string& fullInput, MiniHSFS& mini);

};
------------------------------
SimpleAutoComplete.cpp
------------------------------
#include "SimpleAutoComplete.h"

void SimpleAutoComplete::Impl::setupConsole() {
#ifdef _WIN32
    hStdin = GetStdHandle(STD_INPUT_HANDLE);
    GetConsoleMode(hStdin, &fdwSaveOldMode);
    SetConsoleMode(hStdin, ENABLE_PROCESSED_INPUT);
#else
    tcgetattr(STDIN_FILENO, &origTermios);
    struct termios newTermios = origTermios;
    newTermios.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newTermios);
#endif
    updateTerminalWidth();
}

void SimpleAutoComplete::Impl::restoreConsole() {
#ifdef _WIN32
    SetConsoleMode(hStdin, fdwSaveOldMode);
#else
    tcsetattr(STDIN_FILENO, TCSANOW, &origTermios);
#endif
}

void SimpleAutoComplete::Impl::updateTerminalWidth() {
#ifdef _WIN32
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi)) {
        terminalWidth = csbi.dwSize.X;
    }
#else
    struct winsize w;
    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &w) == 0) {
        terminalWidth = w.ws_col;
    }
#endif
}

int SimpleAutoComplete::Impl::getch() {
#ifdef _WIN32
    return _getch();
#else
    char ch;
    if (read(STDIN_FILENO, &ch, 1) == 1) {
        return ch;
    }
    return EOF;
#endif
}

void SimpleAutoComplete::Impl::showSuggestions(const std::string& input) {
    if (!showSuggestionsFlag) return;

    if (currentMatches.empty()) {
        currentMatches = getSuggestions(input);
        currentMatchIndex = 0;
        if (currentMatches.empty()) {
            showSuggestionsFlag = false;
            return;
        }
    }

    std::cout << "\n";

    size_t maxLength = 0;
    for (const auto& word : currentMatches) {
        if (word.length() > maxLength) maxLength = word.length();
    }
    maxLength += 2;

    int columns = (std::max)(1, terminalWidth / static_cast<int>(maxLength));

    for (size_t i = 0; i < currentMatches.size(); ++i) {
        if (i % columns == 0 && i != 0)
            std::cout << "\n";
        std::cout << std::left << std::setw(static_cast<int>(maxLength)) << currentMatches[i];
    }

    std::cout << "\n" << prompt << input;
    std::cout.flush();
}

void SimpleAutoComplete::Impl::clearSuggestions() {
    if (!currentMatches.empty()) {
        std::cout << "\033[J";
        currentMatches.clear();
        currentMatchIndex = 0;
    }
}

SimpleAutoComplete::SimpleAutoComplete(MiniHSFS& mini)
    : pimpl(std::make_unique<Impl>()) {
    pimpl->getSuggestions = [this, &mini](const std::string& input) {
        return this->getUnifiedSuggestions(input, mini);
        };
}

SimpleAutoComplete::~SimpleAutoComplete() = default;

void SimpleAutoComplete::init(SuggestionsCallback callback) {
    pimpl->getSuggestions = callback;
}

std::string SimpleAutoComplete::readInput(const std::string& prompt) {
    pimpl->setupConsole();
    pimpl->prompt = prompt;
    std::string input;
    std::cout << prompt;
    std::cout.flush();

    auto lastTabTime = std::chrono::steady_clock::now();
    const auto doubleTabInterval = std::chrono::milliseconds(300);

    while (true) {
        int ch = pimpl->getch();

        if (ch == '\n' || ch == '\r') { // Enter
            pimpl->clearSuggestions();
            pimpl->showSuggestionsFlag = false;
            break;
        }

        if (ch == '\t') { // Tab
            pimpl->showSuggestionsFlag = true;

            if (pimpl->showSuggestionsFlag) {
                pimpl->currentMatches = pimpl->getSuggestions(input);
                pimpl->currentMatchIndex = 0;

                if (pimpl->currentMatches.size() == 1) {
                    std::string match = pimpl->currentMatches[0];

                    size_t lastSpace = input.find_last_of(' ');
                    std::string prefix = (lastSpace == std::string::npos) ? input : input.substr(lastSpace + 1);

                    if (prefix == match) {
                        input += " ";
                        std::cout << " ";
                    }
                    else {
                        std::string toAppend = match.substr(prefix.length());
                        input += toAppend;
                        std::cout << toAppend;
                    }

                    pimpl->showSuggestionsFlag = false;
                }
                else if (pimpl->currentMatches.size() > 1) {
                    pimpl->showSuggestions(input);
                }
            }
            continue;
        }

        if (pimpl->showSuggestionsFlag) {
            pimpl->clearSuggestions();
            pimpl->showSuggestionsFlag = false;
        }

        if (ch == 27 || ch == 0 || ch == 224) { // Arrow keys
            int ext = pimpl->getch();
#ifdef _WIN32
            if (ch == 224) {
                if (ext == 72 && !pimpl->currentMatches.empty()) { // Up
                    pimpl->currentMatchIndex = (pimpl->currentMatchIndex + pimpl->currentMatches.size() - 1) % pimpl->currentMatches.size();
                    pimpl->showSuggestions(input);
                }
                else if (ext == 80 && !pimpl->currentMatches.empty()) { // Down
                    pimpl->currentMatchIndex = (pimpl->currentMatchIndex + 1) % pimpl->currentMatches.size();
                    pimpl->showSuggestions(input);
                }
            }
#else
            if (ch == 27 && ext == 91) {
                int ext2 = pimpl->getch();
                if (ext2 == 65 && !pimpl->currentMatches.empty()) { // Up
                    pimpl->currentMatchIndex = (pimpl->currentMatchIndex + pimpl->currentMatches.size() - 1) % pimpl->currentMatches.size();
                    pimpl->showSuggestions(input);
                }
                else if (ext2 == 66 && !pimpl->currentMatches.empty()) { // Down
                    pimpl->currentMatchIndex = (pimpl->currentMatchIndex + 1) % pimpl->currentMatches.size();
                    pimpl->showSuggestions(input);
                }
            }
#endif
            continue;
        }

        if (ch == 127 || ch == 8) { // Backspace
            if (!input.empty()) {
                input.pop_back();
                std::cout << "\b \b";
            }
        }
        else if (ch >= 32 && ch <= 126) { // Printable characters
            std::cout << static_cast<char>(ch);
            input += static_cast<char>(ch);
        }
    }

    pimpl->restoreConsole();
    pimpl->inputValue = input;
    pimpl->restoreConsole();
    std::cout << "\n";
    return input;
}

std::string SimpleAutoComplete::getInput() const {
    return pimpl->inputValue;
}

std::vector<std::string> SimpleAutoComplete::getFileSystemSuggestions(const std::string& fullInput, MiniHSFS& mini) {
    std::vector<std::string> suggestions;

    size_t lastSpace = fullInput.find_last_of(' ');
    std::string input = (lastSpace == std::string::npos) ? fullInput : fullInput.substr(lastSpace + 1);

    try {
        int currentDir = mini.FindFile(run::currentPath);
        if (currentDir != -1 && mini.inodeTable[currentDir].isDirectory) {
            for (const auto& entry : mini.inodeTable[currentDir].entries) {
                if (entry.first.find(input) == 0) {
                    suggestions.push_back(entry.first);
                }
            }
            std::sort(suggestions.begin(), suggestions.end());
        }
    }
    catch (...) {}

    return suggestions;
}

std::vector<std::string> SimpleAutoComplete::getCommandSuggestions(const std::string& fullInput) {
    std::vector<std::string> suggestions;

    size_t lastSpace = fullInput.find_last_of(' ');
    std::string input = (lastSpace == std::string::npos) ? fullInput : fullInput.substr(lastSpace + 1);

    for (const std::string& cmd : builtInCommands) {
        if (cmd.find(input) == 0) {
            suggestions.push_back(cmd);
        }
    }

    std::sort(suggestions.begin(), suggestions.end());
    return suggestions;
}

std::vector<std::string> SimpleAutoComplete::getUnifiedSuggestions(const std::string& fullInput, MiniHSFS& mini) {
    std::vector<std::string> suggestions;

    bool suggestCommand = fullInput.empty() || fullInput.find(' ') == std::string::npos;

    if (suggestCommand) {
        suggestions = getCommandSuggestions(fullInput);
    }
    else {
        suggestions = getFileSystemSuggestions(fullInput, mini);
    }

    return suggestions;
}
------------------------------
Parser.h
------------------------------
#include <string>
#include <vector>
#include <iostream>
#include <sstream>
#include <algorithm>
#include "run.h"
#include "MiniHSFS.h"

class Parser {
public:
	void ls(const std::string& path, MiniHSFS& mini);
	std::vector<MiniHSFS::Inode> getDirectoryItems(const std::string& path, MiniHSFS& mini);
	void cd(const std::string& path, MiniHSFS& mini);
	void cls();
	void printBitmap(MiniHSFS& mini);

	void exit(MiniHSFS& mini);

	void printFileInfo(int file_inode, const std::string& path, bool long_format, MiniHSFS& mini);
	void printInodeInfo(int inode_num, const std::string& path, bool long_format, MiniHSFS& mini);
	void printDirectoryContents(int dir_inode, const std::string& path,
		bool long_format, bool show_hidden, bool recursive,
		const std::string& indent, bool is_last, MiniHSFS& mini);
	void printFileSystemInfo(MiniHSFS& mini);

	void PrintBTreeStructure(MiniHSFS& mini);


	void createDirectory(const std::string path, const std::string name, MiniHSFS& mini);

	bool deleteDirectory(const std::string& path, MiniHSFS& mini);

	int createFile(const std::string& path, const std::string name, MiniHSFS& mini);

	bool deleteFile(const std::string& path, MiniHSFS& mini);

	bool rename(const std::string& old_path, const std::string& new_name, MiniHSFS& mini);

	bool move(const std::string& srcPath, const std::string& destPath, MiniHSFS& mini);

	bool copy(const std::string& srcPath, const std::string& destPath, MiniHSFS& mini);

	std::vector<char> readFile(const std::string& path, MiniHSFS& mini, size_t max_chunk_size = 0, bool show_progress = true, const std::string& password = "");

	bool writeFile(const std::string& path, const std::vector<char>& data, MiniHSFS& mini, bool append = false, const std::string& password = "");
	
	size_t getFileSize(const std::string& path, MiniHSFS& mini);

};
#pragma once

#pragma once

------------------------------
Parser.cpp
------------------------------
#include "Parser.h"

//------------------------------------------------------------------//
void Parser::cd(const std::string& path, MiniHSFS& mini) {
    if (path.empty()) {
        return;
    }

    std::string combinedPath;
    if (path[0] == '/') {
        combinedPath = path;
    }
    else {
        combinedPath = run::currentPath;
        if (combinedPath.back() != '/') {
            combinedPath += "/";
        }
        combinedPath += path;
    }

    std::vector<std::string> parts = mini.SplitPath(combinedPath);
    std::vector<std::string> normalized;

    for (const std::string& part : parts) {
        if (part == "." || part.empty()) {
            continue;
        }
        else if (part == "..") {
            if (!normalized.empty()) {
                normalized.pop_back();
            }
        }
        else {
            normalized.push_back(part);
        }
    }

    std::string newPath = "/";
    for (const auto& part : normalized) {
        newPath += part + "/";
    }

    if (newPath.length() > 1 && newPath.back() == '/') {
        newPath.pop_back();
    }

    if (newPath.empty()) {
        newPath = "/";
    }

    //   :     "/"   
    if (newPath == "/" && run::currentPath == "/") {
        std::cout << ">> You are already in the root directory\n";
        return;
    }

    try {
        mini.ValidatePath(newPath);
        std::vector<std::string> checkParts = mini.SplitPath(newPath);
        int inode = mini.PathToInode(checkParts);

        if (inode == -1 || !mini.inodeTable[inode].isDirectory) {
            throw std::runtime_error("Directory not found: " + newPath);
        }

        run::currentPath = newPath;
    }
    catch (const std::exception& ex) {
        throw std::runtime_error(ex.what());
    }
}

void Parser::ls(const std::string& input, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("\033[31mFilesystem not mounted\033[0m");

    // Parse command options
    bool show_inode_info = false;
    bool long_format = false;
    bool show_hidden = false;
    bool tree = false;
    std::string path;

    // CORRECT way to split input into tokens
    std::vector<std::string> tokens;
    std::istringstream iss(input);  // Initialize with input string
    std::string token;
    while (iss >> token) {         // Extract tokens
        tokens.push_back(token);
    }

    // Process options and path
    for (size_t i = 0; i < tokens.size(); ++i) {  // Skip command name (tokens[0] == "ls")
        const auto& token = tokens[i];

        if (tokens[0][0] == '-') {
            // It's an option flag
            if (tokens[0][1] == 'i') show_inode_info = true;
            if (tokens[0][1] == 'l') long_format = true;
            if (tokens[0][1] == 'a') show_hidden = true;
            if (tokens[0][1] == 'R') tree = true;
        }
        else {
            // It's a path (take the first one only)
            if (path.empty()) {
                path = token;
            }
        }
    }
    std::string target;
    // Determine target path
    if (tokens.size() == 2)
        target = tokens[1];
    else
        target = path.empty() ?
        (run::currentPath.empty() ? "/" : run::currentPath) :
        path;

    // Validate and get inode
    mini.ValidatePath(target);
    int target_inode = mini.PathToInode(mini.SplitPath(target));

    if (target_inode == -1) {
        throw std::runtime_error("\033[31mPath not found: " + target + "\033[0m");
    }

    const MiniHSFS::Inode& inode = mini.inodeTable[target_inode];

    if (show_inode_info) {
        printInodeInfo(target_inode, target, long_format, mini);
    }
    else if (inode.isDirectory) {
        printDirectoryContents(target_inode, target, long_format, show_hidden, tree, "", false, mini);
    }
    else {
        printFileInfo(target_inode, target, long_format, mini);
    }
}

std::vector<MiniHSFS::Inode> Parser::getDirectoryItems(const std::string& path, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);
    std::vector<MiniHSFS::Inode> result;

    if (!mini.mounted) {
        throw std::runtime_error("Filesystem not mounted");
    }

    mini.ValidatePath(path);
    int inodeIndex = mini.PathToInode(mini.SplitPath(path));
    if (inodeIndex == -1)
        throw std::runtime_error("Directory not found: " + path);

    const auto& dirInode = mini.inodeTable[inodeIndex];
    if (!dirInode.isDirectory)
        throw std::runtime_error("Path is not a directory: " + path);

    for (const auto& entry : dirInode.entries) {
        const auto& name = entry.first;
        int childIndex = entry.second;
        const auto& child = mini.inodeTable[childIndex];

        MiniHSFS::Inode info;
        info.entries = std::map<std::string, int>{ {entry.first, entry.second} };
        info.isDirectory = child.isDirectory;
        info.size = child.blocksUsed * mini.Disk().blockSize;
        info.modificationTime = child.modificationTime;

        result.push_back(info);
    }

    return result;
}

void Parser::printDirectoryContents(int dir_inode, const std::string& path,
    bool long_format, bool show_hidden, bool recursive,
    const std::string& indent, bool is_last, MiniHSFS& mini) {

    const MiniHSFS::Inode& dir = mini.inodeTable[dir_inode];

    // Print current directory header (only for top-level call)
    if (indent.empty()) {
        std::cout << "\n";
        std::cout << "\033[1m" << (long_format ? "Detailed contents of " : "Contents of ")
            << path << " (inode " << dir_inode << "):\n" << "\033[0m";
        std::cout << "\033[1m" << "Total entries: " << dir.entries.size() << "\n";
        std::cout << "----------------------------------------\n" << "\033[0m";
    }

    // List entries
    size_t entry_count = 0;
    size_t visible_entries = 0;
    for (const auto& entry : dir.entries) {
        if (!show_hidden && entry.first[0] == '.') continue;
        visible_entries++;
    }


    const char* units[] = { "B", "KB", "MB", "GB", "TB" };
    auto formatSize = [&](uint64_t bytes) -> std::string {
        size_t unit = 0;
        double size = static_cast<double>(bytes);

        while (size >= 1024 && unit < 4) {
            size /= 1024;
            ++unit;
        }

        std::ostringstream out;
        out << std::fixed << std::setprecision(2) << size << " " << units[unit];
        return out.str();
        };

    size_t current_entry = 0;
    for (const auto& entry : dir.entries) {
        const std::string& name = entry.first;

        // Skip hidden if not requested
        if (!show_hidden && name[0] == '.') continue;

        current_entry++;
        bool last_entry = (current_entry == visible_entries);
        const MiniHSFS::Inode& inode = mini.inodeTable[entry.second];

        // Print indentation and tree structure
        std::cout << indent;
        if (recursive && !indent.empty()) {
            std::cout << (is_last ? "    " : "| ");//"   ");
        }
        if (recursive) {
            std::cout << (last_entry ? "|__ " : "|-- ");
        }

        if (long_format) {
            std::cout << (inode.isDirectory ? "\033[32m" : "\033[34m")
                << std::left << std::setw(20) << name << "\033[0m";

            std::cout << std::setw(10) << (inode.isDirectory ? "DIR" : "FILE");
            std::cout << std::setw(10) << (inode.isDirectory ? "-" : std::to_string(inode.size));
            std::cout << std::setw(10) << entry.second;

            char time_buf[26];
#if _WIN32
            ctime_s(time_buf, sizeof(time_buf), &inode.modificationTime);
#else
            ctime_r(&inode.modificationTime, time_buf);
#endif
            time_buf[24] = '\0';
            std::cout << "\033[33m" << time_buf << "\033[0m" << "\n";
        }
        else {
            std::cout << (inode.isDirectory ? "\033[32m" : "\033[34m") << name << "\033[0m";
            if (inode.isDirectory) {
                std::cout << " <DIR>";
            }
            else {
                std::cout << " (" << formatSize(inode.size) << ")";
            }
            std::cout << "\n";
        }

        // Recursive listing for directories
        if (recursive && inode.isDirectory && name != "." && name != "..") {
            std::string new_indent = indent + (is_last ? "    " : "|   ");
            std::string child_path = (path == "/" ? "/" : path + "/") + name;
            printDirectoryContents(entry.second, child_path, long_format,
                show_hidden, recursive, new_indent, last_entry, mini);
        }
    }

    // Print footer for the root directory only
    if (indent.empty()) {
        std::cout << "\033[1m" << "----------------------------------------\n" << "\033[0m";


        std::cout << "\033[32mFree space: "
            << formatSize(mini.Disk().freeBlocksCount() * mini.Disk().blockSize)
            << " | Inode: " << dir_inode
            << "\n\033[0m";
    }
}

void Parser::printFileInfo(int file_inode, const std::string& path, bool long_format, MiniHSFS& mini) {
    // Validate inode number
    if (file_inode < 0 || file_inode >= mini.inodeTable.size()) {
        std::cerr << "\033[31m" << "Error: Invalid inode number " << file_inode
            << "\033[0m" << std::endl;
        return;
    }

    const MiniHSFS::Inode& file = mini.inodeTable[file_inode];

    // Header with better visual separation
    std::cout << "\033[1m" << "\033[32m" << "File Information\n";
    std::cout << "-----------------------------------------\n" << "\033[0m";

    // Format size in human-readable way
    auto formatSize = [](size_t bytes) -> std::string {
        const char* units[] = { "B", "KB", "MB", "GB", "TB" };
        size_t unit = 0;
        double size = static_cast<double>(bytes);

        while (size >= 1024 && unit < 4) {
            size /= 1024;
            unit++;
        }

        std::ostringstream oss;
        oss << std::fixed << std::setprecision(2) << size << " " << units[unit];
        return oss.str();
        };

    // Main information with consistent formatting
    std::cout << std::left << std::setw(15) << "Name:"
        << "\033[34m" << path << "\033[0m" << "\n";
    std::cout << std::setw(15) << "Inode:" << file_inode << "\n";
    std::cout << std::setw(15) << "Size:"
        << formatSize(file.size) << " (" << file.size << " bytes)\n";
    std::cout << std::setw(15) << "Blocks used:" << file.blocksUsed << "\n";
    std::cout << std::setw(15) << "First block:" << file.firstBlock << "\n";

    // Time formatting with error handling
    auto printTime = [](const char* label, time_t time) {
        std::cout << std::setw(15) << label;
        if (time == 0) {
            std::cout << "\033[33m" << "Unknown" << "\033[0m" << "\n";
        }
        else {
            char time_buf[26];
#if _WIN32
            if (ctime_s(time_buf, sizeof(time_buf), &time) == 0) {
                time_buf[24] = '\0'; // Remove newline
                std::cout << "\033[33m" << time_buf << "\033[0m";
            }
            else {
                std::cout << "\033[31m" << "Invalid timestamp" << "\033[0m";
            }
#else
            if (ctime_r(&time, time_buf) == 0) {
                time_buf[24] = '\0'; // Remove newline
                std::cout << "\033[33m" << time_buf << "\033[0m";
            }
            else {
                std::cout << "\033[31m" << "Invalid timestamp" << "\033[0m";
            }
#endif
            std::cout << "\n";
        }
        };

    printTime("Created:", file.creationTime);
    printTime("Modified:", file.modificationTime);

    // Footer
    std::cout << "\033[1m" << "\033[32m"
        << "-----------------------------------------\n"
        << "\033[0m";
}

void Parser::printInodeInfo(int inode_num, const std::string& path, bool long_format, MiniHSFS& mini) {
    // Validate inode number
    if (inode_num < 0 || inode_num >= mini.inodeTable.size()) {
        std::cerr << "\033[31m" << "Error: Invalid inode number " << inode_num
            << "\033[0m" << std::endl;
        return;
    }

    const MiniHSFS::Inode& inode = mini.inodeTable[inode_num];

    // Header with better visual separation
    std::cout << "\033[1m" << "\033[36m" << "Inode Information\n";
    std::cout << "-----------------------------------------\n" << "\033[0m";

    // Main information with consistent formatting
    std::cout << std::left << std::setw(15) << "Path:"
        << "\033[36m" << path << "\033[0m" << "\n";
    std::cout << std::setw(15) << "Inode:" << inode_num << "\n";

    // Type information with better visual distinction
    std::cout << std::setw(15) << "Type:";
    if (inode.isDirectory) {
        std::cout << "\033[36m" << "Directory" << "\033[0m"
            << " (" << inode.entries.size() << " entries)\n";
    }
    else {
        std::cout << "\033[34m" << "File" << "\033[0m" << "\n";

        // File-specific information with human-readable size
        auto formatSize = [](size_t bytes) {
            const char* units[] = { "B", "KB", "MB", "GB", "TB" };
            size_t unit = 0;
            double size = static_cast<double>(bytes);
            while (size >= 1024 && unit < 4) {
                size /= 1024;
                unit++;
            }
            std::ostringstream oss;
            oss << std::fixed << std::setprecision(2) << size << " " << units[unit];
            return oss.str();
            };

        std::cout << std::setw(15) << "Size:"
            << formatSize(inode.size) << " (" << inode.size << " bytes)\n";
        std::cout << std::setw(15) << "Blocks used:" << inode.blocksUsed << "\n";
        std::cout << std::setw(15) << "First block:" << inode.firstBlock << "\n";
    }

    // Time formatting with error handling
    auto printTime = [](const char* label, time_t time) {
        std::cout << std::setw(15) << label;
        if (time == 0) {
            std::cout << "\033[33m" << "Unknown" << "\033[0m" << "\n";
        }
        else {
            char time_buf[26];
#if _WIN32
            if (ctime_s(time_buf, sizeof(time_buf), &time) == 0) {
                time_buf[24] = '\0';
                std::cout << "\033[33m" << time_buf << "\033[0m";
            }
            else {
                std::cout << "\033[31m" << "Invalid timestamp" << "\033[0m";
            }
#else
            if (ctime_r(&time, time_buf) == 0) {
                time_buf[24] = '\0';
                std::cout << "\033[33m" << time_buf << "\033[0m";
            }
            else {
                std::cout << "\033[31m" << "Invalid timestamp" << "\033[0m";
            }
#endif
            std::cout << "\n";
        }
        };

    printTime("Created:", inode.creationTime);
    printTime("Modified:", inode.modificationTime);

    // Enhanced directory listing for long format
    if (long_format && inode.isDirectory && !inode.entries.empty()) {
        std::cout << "\033[1m" << "\nDirectory Contents:\n" << "\033[0m";
        std::cout << "-----------------------------------------\n";

        for (const auto& entry : inode.entries) {
            const auto& child_inode = mini.inodeTable[entry.second];
            std::cout << "  " << (child_inode.isDirectory ? "\033[32m" : "\033[34m")
                << std::left << std::setw(30) << entry.first
                << "\033[0m" << " (inode: " << entry.second << ")";

            if (!child_inode.isDirectory) {
                std::cout << " - " << child_inode.size << " bytes";
            }
            std::cout << "\n";
        }
    }

    // Footer
    std::cout << "\033[1m" << "\033[36m"
        << "-----------------------------------------\n"
        << "\033[0m";
}

//---------------------------------------------------------------------//
void Parser::printFileSystemInfo(MiniHSFS& mini)
{
    mini.PrintSuperblockInfo();
}

void Parser::PrintBTreeStructure(MiniHSFS& mini)
{
    mini.PrintBTreeStructure();
}
//-----------------------------------------------------------------//
void Parser::createDirectory(const std::string path, const std::string name, MiniHSFS& mini)
{
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);
    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
    mini.ValidatePath(path + name);

    auto path_components = mini.SplitPath(path + name);
    if (path_components.empty()) throw std::invalid_argument("Invalid path");

    std::string dirname = path_components.back();
    path_components.pop_back();

    if (dirname.length() > mini.maxFileNameLength) {
        throw std::invalid_argument("Directory name too long");
    }

    int parent_inode = mini.PathToInode(path_components);
    if (parent_inode == -1 || !mini.inodeTable[parent_inode].isDirectory) {
        throw std::runtime_error("Parent directory does not exist");
    }

    // Check if directory already exists
    if (mini.inodeTable[parent_inode].entries.count(dirname) > 0) {
        throw std::runtime_error("Directory already exists");
    }

    // Find free inode
    int new_inode = -1;
    for (int i = 1; i < mini.inodeCount; i++) {
        if (!mini.inodeTable[i].isUsed) {
            new_inode = i;
            break;
        }
    }

    if (new_inode == -1) throw std::runtime_error("No free inodes available");

    // Initialize new inode as directory
    mini.inodeTable[new_inode].isUsed = true;
    mini.inodeTable[new_inode].isDirectory = true;
    mini.inodeTable[new_inode].creationTime = time(nullptr);
    mini.inodeTable[new_inode].modificationTime = mini.inodeTable[new_inode].creationTime;

    // No blocks needed for empty directories in this model

    // Add to parent directory
    mini.inodeTable[parent_inode].entries[dirname] = new_inode;
    mini.UpdateInodeTimestamps(parent_inode, true);

    mini.lastTimeWrite = time(nullptr);
    //return new_inode;
}

bool Parser::deleteDirectory(const std::string& path, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
    mini.ValidatePath(path);

    int inode_index = mini.FindFile(path);
    if (inode_index == -1) throw std::runtime_error("Directory not found");

    if (!mini.inodeTable[inode_index].isDirectory) {
        throw std::runtime_error("Path is not a directory");
    }

    if (!mini.inodeTable[inode_index].entries.empty()) {
        std::cout << "\033[1;31mDirectory is not empty. Do you want to delete all contents? [Y/N]: \033[0m";
        std::string answer;
        std::getline(std::cin, answer);
        if (answer != "Y" && answer != "y") {
            std::cout << "Operation cancelled.\n";
            return false;
        }

        //       recursive
        auto entriesCopy = mini.inodeTable[inode_index].entries; //   
        for (const auto& entry : entriesCopy) {
            std::string childPath = path + "/" + entry.first;
            int childInode = entry.second;
            if (mini.inodeTable[childInode].isDirectory) {
                deleteDirectory(childPath, mini);
            }
            else {
                deleteFile(childPath, mini);
            }
        }
    }

    //    
    auto path_components = mini.SplitPath(path);
    std::string dirname = path_components.back();
    path_components.pop_back();

    int parent_inode = mini.PathToInode(path_components);
    if (parent_inode != -1) {
        mini.inodeTable[parent_inode].entries.erase(dirname);
        mini.UpdateInodeTimestamps(parent_inode, true);
    }

    //   inode
    mini.inodeTable[inode_index].isUsed = false;
    mini.inodeTable[inode_index].isDirectory = false;
    mini.inodeTable[inode_index].entries.clear();
    mini.inodeTable[inode_index].firstBlock = -1;
    mini.inodeTable[inode_index].blocksUsed = 0;
    mini.inodeTable[inode_index].modificationTime = 0;
    mini.inodeTable[inode_index].creationTime = 0;

    return true;
}

int Parser::createFile(const std::string& path, const std::string name, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
    mini.ValidatePath(path + name);

    auto path_components = mini.SplitPath(path + name);
    if (path_components.empty()) throw std::invalid_argument("Invalid path");

    std::string filename = path_components.back();
    path_components.pop_back();

    if (filename.length() > mini.maxFileNameLength) {
        throw std::invalid_argument("Filename too long");
    }

    int parent_inode = mini.PathToInode(path_components);
    if (parent_inode == -1 || !mini.inodeTable[parent_inode].isDirectory) {
        throw std::runtime_error("Parent directory does not exist");
    }

    // Check if file already exists
    if (mini.inodeTable[parent_inode].entries.count(filename) > 0) {
        throw std::runtime_error("File already exists");
    }

    // Find free inode
    int new_inode = -1;
    for (int i = 1; i < mini.inodeCount; i++) {
        if (!mini.inodeTable[i].isUsed) {
            new_inode = i;
            break;
        }
    }
    if (new_inode == -1) throw std::runtime_error("No free inodes available");

    // Initialize new file inode
    mini.inodeTable[new_inode].isUsed = true;
    mini.inodeTable[new_inode].isDirectory = false;
    mini.inodeTable[new_inode].creationTime = time(nullptr);
    mini.inodeTable[new_inode].modificationTime = mini.inodeTable[new_inode].creationTime;

    // Allocate one block
    int first_block = mini.FindFreeBlock();
    if (first_block == -1) {
        mini.inodeTable[new_inode].isUsed = false;
        throw std::runtime_error("No free blocks available");
    }

    mini.MarkBlockUsed(first_block);
    mini.inodeTable[new_inode].firstBlock = first_block;
    mini.inodeTable[new_inode].blocksUsed = 1;

    // Add to parent directory
    mini.inodeTable[parent_inode].entries[filename] = new_inode;
    mini.UpdateInodeTimestamps(parent_inode, true);

    mini.lastTimeWrite = time(nullptr);
    return new_inode;
}

bool Parser::deleteFile(const std::string& path, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) {
        throw std::runtime_error("Filesystem not mounted");
    }

    mini.ValidatePath(path);

    int inode_index = mini.FindFile(path);
    if (inode_index == -1) {
        throw std::runtime_error("File not found");
    }

    //     
    if (mini.inodeTable[inode_index].isDirectory) {
        throw std::runtime_error("Cannot delete directory using del, use rd instead");
    }

    //     
    int first_block = mini.inodeTable[inode_index].firstBlock;
    int blocks_used = mini.inodeTable[inode_index].blocksUsed;

    // 1.     
    auto path_components = mini.SplitPath(path);
    std::string filename = path_components.back();
    path_components.pop_back();

    int parent_inode = mini.PathToInode(path_components);
    if (parent_inode == -1) {
        throw std::runtime_error("Parent directory not found");
    }

    //       
    auto old_entry = mini.inodeTable[parent_inode].entries[filename];

    //     
    mini.inodeTable[parent_inode].entries.erase(filename);
    mini.UpdateInodeTimestamps(parent_inode, true);

    try {
        // 2.      bitmap
        if (first_block != -1 && blocks_used > 0) {
            VirtualDisk::Extent extent(first_block, blocks_used);

            // 3.  B-tree 
            for (int i = 0; i < blocks_used; ++i) {
                mini.BTreeDelete(mini.rootNodeIndex, first_block + i);

                //  
                double progress = 100.0 * (i + 1) / blocks_used;
                std::cout << "\rDeleting blocks... " << std::fixed << std::setprecision(2)
                    << progress << "%" << std::flush;
            }
            std::cout << std::endl; //    

            // 4.   
            if (!mini.FreeFileBlocks(mini.inodeTable[inode_index])) {
                throw std::runtime_error("Failed to free blocks in bitmap");
            }
        }

        // 5.   inode
        mini.inodeTable[inode_index] = MiniHSFS::Inode();

        return true;
    }
    catch (const std::exception& e) {
        //      
        if (parent_inode != -1) {
            mini.inodeTable[parent_inode].entries[filename] = old_entry;
        }

        std::cerr << "Error deleting file: " << e.what() << std::endl;
        throw;
    }
}

//std::vector<char> Parser::readFile(const std::string& path, MiniHSFS& mini) {
//    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);
//
//    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
//    mini.ValidatePath(path);
//
//    int inode_index = mini.FindFile(path);
//    if (inode_index == -1) throw std::runtime_error("File not found");
//
//    MiniHSFS::Inode& inode = mini.inodeTable[inode_index];
//    if (inode.isDirectory) {
//        throw std::runtime_error("Cannot read a directory");
//    }
//
//    std::vector<char> data;
//    data.reserve(inode.size);
//
//    int current_block = inode.firstBlock;
//    int blocks_remaining = inode.blocksUsed;
//    size_t total_read = 0;
//
//    while (current_block != -1 && blocks_remaining > 0) {
//        auto block_data = mini.Disk().readData(VirtualDisk::Extent(current_block, 1));
//        size_t bytes_to_read = std::min<>(
//            static_cast<size_t>(inode.size - total_read),
//            block_data.size()
//        );
//
//        data.insert(data.end(), block_data.begin(), block_data.begin() + bytes_to_read);
//        total_read += bytes_to_read;
//        current_block++;
//        blocks_remaining--;
//    }
//
//    return data;
//}
//
//std::vector<char> Parser::readFile(const std::string& path, MiniHSFS& mini,
//    size_t max_size, bool show_progress) {
//
//    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);
//
//    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
//    mini.ValidatePath(path);
//
//    int inode_index = mini.FindFile(path);
//    if (inode_index == -1) throw std::runtime_error("File not found");
//
//    MiniHSFS::Inode& inode = mini.inodeTable[inode_index];
//    if (inode.isDirectory) throw std::runtime_error("Cannot read a directory");
//
//    const size_t file_size = inode.size;
//    const size_t chunk_size = (max_size == 0 ? file_size : (std::min)(max_size, file_size));
//
//    std::vector<char> data;
//    data.reserve(chunk_size);
//
//    const uint32_t block_size = mini.Disk().blockSize; //       
//    const uint32_t blocks_needed = static_cast<uint32_t>(std::ceil((double)chunk_size / block_size));
//
//    int current_block = inode.firstBlock;
//    size_t total_read = 0;
//
//    for (uint32_t i = 0; i < blocks_needed; ++i) {
//        if (current_block == -1) break; //      
//
//        auto future_block = mini.Disk().readDataAsync(VirtualDisk::Extent(current_block, 1));
//        std::vector<char> block_data = future_block.get();
//
//        size_t bytes_to_read = (std::min)(block_data.size(), chunk_size - total_read);
//        data.insert(data.end(), block_data.begin(), block_data.begin() + bytes_to_read);
//        total_read += bytes_to_read;
//        current_block++; //    
//
//        if (show_progress) {
//            double progress = 100.0 * total_read / file_size;
//            std::cout << "\rReading... " << std::fixed << std::setprecision(2)
//                << progress << "% (" << total_read / (1024 * 1024)
//                << " MB of " << file_size / (1024 * 1024) << " MB)" << std::flush;
//        }
//    }
//
//    if (show_progress) {
//        std::cout << std::endl;
//        if (max_size > 0 && total_read < file_size) {
//            std::cout << "Note: Read " << total_read / (1024 * 1024)
//                << "MB (chunked mode). Use 'readfull' for complete file." << std::endl;
//        }
//    }
//
//    return data;
//}

std::vector<char> Parser::readFile(const std::string& path, MiniHSFS& mini,
    size_t max_size, bool show_progress, const std::string& password) {

    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
    mini.ValidatePath(path);

    int inode_index = mini.FindFile(path);
    if (inode_index == -1) throw std::runtime_error("File not found");

    MiniHSFS::Inode& inode = mini.inodeTable[inode_index];
    if (inode.isDirectory) throw std::runtime_error("Cannot read a directory");

    if (inode.blocksUsed == 0 || inode.firstBlock == -1) {
        return {}; //  
    }

    VirtualDisk::Extent extent(inode.firstBlock, inode.blocksUsed);
    std::vector<char> result = mini.Disk().readData(extent, password);

    if (max_size > 0 && result.size() > max_size) {
        result.resize(max_size);
    }

    return result;
}

bool Parser::writeFile(const std::string& path, const std::vector<char>& data, MiniHSFS& mini,
    bool append, const std::string& password) {

    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
    mini.ValidatePath(path);

    int inode_index = mini.FindFile(path);
    
    if (inode_index == -1) throw std::runtime_error("Failed to create file");

    MiniHSFS::Inode& inode = mini.inodeTable[inode_index];
    if (inode.isDirectory) throw std::runtime_error("Cannot write to a directory");

    const size_t blockSize = mini.Disk().blockSize;

    //    
    size_t dataSize = data.size();

    size_t encryptedOverhead = password.empty() ? 0 :
        (CryptoUtils::ExtraSize());// + sizeof(uint32_t) * 2); //   +  

    size_t blocks_needed = (dataSize + encryptedOverhead + blockSize - 1) / blockSize;
//    size_t blockFileSize = static_cast<size_t>(std::ceil(static_cast<double>(inode.size) / static_cast<double>(blockSize)));

    if (blocks_needed > static_cast<size_t>(mini.Disk().freeBlocksCount())) { //+ blockFileSize) {
        throw std::runtime_error("Not enough space to write this file");
    }

    //  
    VirtualDisk::Extent extent = mini.AllocateContiguousBlocks(static_cast<int>(blocks_needed));

    if (extent.startBlock == -1) {
        throw std::runtime_error("Failed to allocate blocks even after defragmentation");
    }

    //  
    if (!mini.Disk().writeData(data, extent, password, true)) {
        mini.Disk().freeBlocks(extent);
        throw std::runtime_error("Failed to write data to disk");
    }

    //   
    if (!append) {
        if (inode.firstBlock != -1) {
            mini.FreeFileBlocks(inode);
        }
        inode.firstBlock = extent.startBlock;
        inode.blocksUsed = extent.blockCount;
        inode.size = dataSize;
    }
    else {
        if (inode.firstBlock == -1) {
            inode.firstBlock = extent.startBlock;
            inode.blocksUsed = extent.blockCount;
        }
        else {
            //         
            //         
            throw std::runtime_error("Appending to encrypted files not fully supported yet");
        }
        inode.size += dataSize;
    }

    inode.modificationTime = time(nullptr);
    inode.isDirty = true;

    return true;
}

//bool Parser::writeFile(const std::string& path, const std::vector<char>& data, MiniHSFS& mini) {
//    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);
//
//    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
//    mini.ValidatePath(path);
//
//    int inode_index = mini.FindFile(path);
//    if (inode_index == -1) throw std::runtime_error("File not found");
//
//    MiniHSFS::Inode& inode = mini.inodeTable[inode_index];
//    if (inode.isDirectory) throw std::runtime_error("Cannot write to a directory");
//
//    if (inode.firstBlock != -1) {
//        if (!mini.FreeFileBlocks(inode)) {
//            throw std::runtime_error("Failed to free old file blocks");
//        }
//        inode.firstBlock = -1;
//        inode.blocksUsed = 0;
//    }
//
//    int blocks_needed = static_cast<int>(std::ceil(static_cast<double>(data.size()) / mini.Disk().blockSize));
//    if (blocks_needed == 0 && !data.empty()) blocks_needed = 1;
//
//    if (blocks_needed > static_cast<int>(mini.Disk().freeBlocksCount()))
//        throw std::runtime_error("Not enough space to write this file");
//
//    VirtualDisk::Extent extent = mini.AllocateContiguousBlocks(blocks_needed);
//    if (extent.startBlock == -1)
//        extent = mini.AllocateContiguousBlocks(blocks_needed);
//    if(extent.startBlock == -1)
//        throw std::runtime_error("Failed to allocate contiguous blocks even after defragmentation");
//
//    if (extent.blockCount == 0) throw std::runtime_error("Failed to allocate blocks");
//
//    uint64_t written = 0;
//    for (int i = 0; i < blocks_needed; ++i) {
//        uint64_t bytes_to_write = min(mini.Disk().blockSize, data.size() - written);
//        std::vector<char> block_data(data.begin() + written, data.begin() + written + bytes_to_write);
//        auto X = mini.Disk().writeDataAsync(block_data, VirtualDisk::Extent(extent.startBlock + i, 1), true);
//        X.get();
//        written += bytes_to_write;
//    }
//
//    inode.firstBlock = extent.startBlock;
//    inode.blocksUsed = extent.blockCount;
//    inode.size = data.size();
//    auto formatSize = [](size_t bytes) -> std::string {
//        const char* units[] = { "B", "KB", "MB", "GB", "TB" };
//        size_t unit = 0;
//        double size = static_cast<double>(bytes);
//
//        while (size >= 1024 && unit < 4) {
//            size /= 1024;
//            unit++;
//        }
//
//        std::ostringstream oss;
//        oss << std::fixed << std::setprecision(2) << size << " " << units[unit];
//        return oss.str();
//        };
//    std::cout << formatSize(data.size()) << std::endl;
//    inode.modificationTime = time(nullptr);
//    inode.isDirty = true;
//
//    return true;
//}
//

//bool Parser::writeFile(const std::string& path, const std::vector<char>& data, MiniHSFS& mini, bool append) {
//    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);
//
//    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
//    mini.ValidatePath(path);
//
//    int inode_index = mini.FindFile(path);
//    if (inode_index == -1) {
//        inode_index = createFile("", path, mini);
//        if (inode_index == -1) throw std::runtime_error("Failed to create file");
//    }
//
//    MiniHSFS::Inode& inode = mini.inodeTable[inode_index];
//    if (inode.isDirectory) throw std::runtime_error("Cannot write to a directory");
//
//    const size_t blockSize = mini.Disk().blockSize;
//    const size_t blocks_needed = (data.size() + blockSize - 1) / blockSize;
//
//    if (blocks_needed > mini.Disk().freeBlocksCount()) {
//        throw std::runtime_error("Not enough space to write this file");
//    }
//
//    if (!append) {
//        //    ( )
//        if (inode.firstBlock != -1 && !mini.FreeFileBlocks(inode)) {
//            throw std::runtime_error("Failed to free old file blocks");
//        }
//
//        VirtualDisk::Extent extent = mini.AllocateContiguousBlocks(blocks_needed);
//        if (extent.startBlock == -1) {
//            throw std::runtime_error("Failed to allocate blocks");
//        }
//
//        //  
//        size_t written = 0;
//        for (size_t i = 0; i < blocks_needed; ++i) {
//            size_t bytes_to_write = (std::min)(blockSize, data.size() - written);
//            std::vector<char> block_data(data.begin() + written, data.begin() + written + bytes_to_write);
//
//            mini.Disk().writeData(block_data, VirtualDisk::Extent(extent.startBlock + i, 1),"123", true);
//            written += bytes_to_write;
//        }
//
//        inode.firstBlock = extent.startBlock;
//        inode.blocksUsed = extent.blockCount;
//        inode.size = data.size();
//    }
//    else {
//        //  
//        std::vector<VirtualDisk::Extent> new_extents;
//
//        //   
//        VirtualDisk::Extent extent = mini.AllocateContiguousBlocks(blocks_needed);
//        if (extent.startBlock == -1) {
//            throw std::runtime_error("Failed to allocate blocks for append");
//        }
//        new_extents.push_back(extent);
//
//        //  
//        size_t written = 0;
//        for (size_t i = 0; i < blocks_needed; ++i) {
//            size_t bytes_to_write = (std::min)(blockSize, data.size() - written);
//            std::vector<char> block_data(data.begin() + written, data.begin() + written + bytes_to_write);
//
//            mini.Disk().writeData(block_data, VirtualDisk::Extent(extent.startBlock + i, 1), "123", true);
//            written += bytes_to_write;
//        }
//
//        //   inode
//        if (inode.firstBlock == -1) {
//            //    
//            inode.firstBlock = extent.startBlock;
//            inode.blocksUsed = extent.blockCount;
//        }
//        else {
//            //      
//            inode.blocksUsed += extent.blockCount;
//
//            //           
//            // : mini.AddBlocksToFile(inode_index, new_extents);
//        }
//
//        inode.size += data.size();
//    }
//
//    inode.modificationTime = time(nullptr);
//    inode.isDirty = true;
//
//    return true;
//}

size_t Parser::getFileSize(const std::string& path, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");
    mini.ValidatePath(path);

    int inode_index = mini.FindFile(path);
    if (inode_index == -1) throw std::runtime_error("File not found");

    return mini.inodeTable[inode_index].size;
}

bool Parser::rename(const std::string& old_path, const std::string& new_name, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted)
        throw std::runtime_error("Filesystem not mounted");

    mini.ValidatePath(old_path);

    auto path_components = mini.SplitPath(old_path);
    if (path_components.empty())
        throw std::invalid_argument("Invalid path");

    std::string old_entry_name = path_components.back();
    path_components.pop_back();

    int parent_inode = mini.PathToInode(path_components);
    if (parent_inode == -1 || !mini.inodeTable[parent_inode].isDirectory)
        throw std::runtime_error("Parent directory not found");

    auto& entries = mini.inodeTable[parent_inode].entries;

    //     
    if (entries.count(old_entry_name) == 0)
        throw std::runtime_error("This name" + old_entry_name + "not found");

    int target_inode = entries[old_entry_name];

    //       
    if (entries.count(new_name) > 0)
        throw std::runtime_error("An entry with the new name" + new_name + "already exists");

    //             Log   is_directory
    // bool is_dir = MiniHSFS::inode_table[target_inode].is_directory;

    //  
    entries.erase(old_entry_name);
    entries[new_name] = target_inode;

    mini.UpdateInodeTimestamps(parent_inode, true);
    return true;
}

bool Parser::move(const std::string& srcPath, const std::string& destPath, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");

    mini.ValidatePath(srcPath);
    mini.ValidatePath(destPath);

    int srcInode = mini.FindFile(srcPath);
    if (srcInode == -1) throw std::runtime_error("Source not found");

    int destInode = mini.FindFile(destPath);
    if (destInode == -1 || !mini.inodeTable[destInode].isDirectory)
        throw std::runtime_error("Destination must be a valid directory");

    const std::string name = mini.SplitPath(srcPath).back();

    if (mini.inodeTable[srcInode].isDirectory) {
        //       
        std::string newFolderPath = destPath + "/" + name;
        createDirectory(destPath + "/", name, mini);

        for (const auto& entry : mini.inodeTable[srcInode].entries) {
            const std::string childSrcPath = srcPath + "/" + entry.first;
            move(childSrcPath, newFolderPath, mini); //     recursive
        }

        deleteDirectory(srcPath, mini);
    }
    else {
        //    (   )

        //    
        auto srcParts = mini.SplitPath(srcPath);
        std::string entryName = srcParts.back();
        srcParts.pop_back();
        int parentInode = mini.PathToInode(srcParts);

        if (parentInode != -1) {
            mini.inodeTable[parentInode].entries.erase(entryName);
            mini.UpdateInodeTimestamps(parentInode, true);
        }

        //    
        mini.inodeTable[destInode].entries[entryName] = srcInode;
        mini.UpdateInodeTimestamps(destInode, true);
    }

    return true;
}

bool Parser::copy(const std::string& srcPath, const std::string& destPath, MiniHSFS& mini) {
    std::lock_guard<std::recursive_mutex> lock(mini.fsMutex);

    if (!mini.mounted) throw std::runtime_error("Filesystem not mounted");

    mini.ValidatePath(srcPath);
    mini.ValidatePath(destPath);

    int srcInode = mini.FindFile(srcPath);
    if (srcInode == -1) throw std::runtime_error("Source not found");

    int destInode = mini.FindFile(destPath);
    if (destInode == -1 || !mini.inodeTable[destInode].isDirectory)
        throw std::runtime_error("Destination must be a directory");

    std::string name = mini.SplitPath(srcPath).back();

    if (mini.inodeTable[srcInode].isDirectory) {
        //    
        std::string newFolderPath = destPath + "/" + name;
        createDirectory(destPath + "/", name, mini);

        for (const auto& entry : mini.inodeTable[srcInode].entries) {
            std::string childSrcPath = srcPath + "/" + entry.first;
            copy(childSrcPath, newFolderPath, mini);
        }
    }
    else {
        // ---   
        std::vector<char> content = readFile(srcPath, mini);
        size_t fileSize = content.size();
        int blockSize = mini.Disk().blockSize;
        int neededBlocks = static_cast<int>(std::ceil(static_cast<double>(fileSize) / blockSize));

        // ---     
        if (neededBlocks > static_cast<int>(mini.Disk().freeBlocksCount())) {
            throw std::runtime_error("Not enough disk space to copy file: " + srcPath);
        }

        // ---   
        createFile(destPath + "/", name, mini);
        writeFile(destPath + "/" + name, content, mini);
    }

    return true;
}

//-----------------------------------------------------------------//
void Parser::cls() {
#ifdef _WIN32
    system("cls");   // Windows
#else
    system("clear"); // Linux/macOS
#endif
}

void Parser::printBitmap(MiniHSFS& mini) {
    mini.Disk().printBitmap();
}

void Parser::exit(MiniHSFS& mini) {
    std::cout << "\033[32mBye :)\033[0m" << std::endl;
}

------------------------------
run.h
------------------------------
#include <string>
#include "VirtualDisk.h"

class run {
public:
	static std::string currentPath;
	static std::string Password;
	static std::size_t extraSize;

};
#pragma once

------------------------------
run.cpp
------------------------------
#ifdef _WIN32
#define _WINSOCKAPI_     //   winsock
#define WIN32_LEAN_AND_MEAN
#define NOCRYPT          //   crypto macros
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#endif

#include <ntstatus.h>
#define WIN32_NO_STATUS


#define NOMINMAX
#include <iostream>
#include <limits>
#include <string>
#include "Parser.h"
#include "VirtualDisk.h"
#include "MiniHSFS.h"
#include "Tokenizer.h"

#include <iostream>
#include <limits>
#include <string>
#include <vector>
#include "run.h"
#include "httplib.h"
#include "IMG.cpp"


#include "CryptoUtils.h"
#include <dokan/dokan.h>



using namespace std;

std::string getIPfromIpconfig() {
    std::string result;
    std::array<char, 256> buffer;

#ifdef _WIN32
    const char* command = "ipconfig";
    std::unique_ptr<FILE, decltype(&_pclose)> pipe(_popen(command, "r"), _pclose);
#else
    const char* command = "ifconfig | grep -Eo 'inet (addr:)?([0-9]*\\.){3}[0-9]*' | grep -Eo '([0-9]*\\.){3}[0-9]*' | grep -v '127.0.0.1'";
    std::unique_ptr<FILE, decltype(&pclose)> pipe(popen(command, "r"), pclose);
#endif

    if (!pipe) {
        throw std::runtime_error("Failed to run ipconfig/ifconfig");
    }

    while (fgets(buffer.data(), static_cast<int>(buffer.size()), pipe.get()) != nullptr) {
        std::string line(buffer.data());

#ifdef _WIN32
        if (line.find("IPv4 Address") != std::string::npos || line.find("IPv4") != std::string::npos) {
#else
        if (!line.empty()) {
#endif
            std::smatch match;
            std::regex ipRegex("(\\d+\\.\\d+\\.\\d+\\.\\d+)");
            if (std::regex_search(line, match, ipRegex)) {
                return match.str(1);
            }
        }
        }

    return "127.0.0.1"; // Default to localhost if not found
    }

std::string run::currentPath = "/";

std::string run::Password = "12345";

std::size_t run::extraSize = CryptoUtils::ExtraSize();

//  
string escapeHtml(const string & input) {
    string output;
    output.reserve(input.size());
    for (char c : input) {
        switch (c) {
        case '&': output += "&amp;"; break;
        case '<': output += "&lt;"; break;
        case '>': output += "&gt;"; break;
        case '"': output += "&quot;"; break;
        case '\'': output += "&#39;"; break;
        default: output += c; break;
        }
    }
    return output;
}

string formatTime(time_t timestamp) {
    char buffer[80];
    tm timeInfo;

#ifdef _WIN32
    localtime_s(&timeInfo, &timestamp);
#else
    localtime_r(&timestamp, &timeInfo);
#endif

    strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", &timeInfo);
    return string(buffer);
}

string formatSize(size_t bytes) {
    const char* sizes[] = { "B", "KB", "MB", "GB" };
    int i = 0;
    double size = static_cast<double>(bytes);
    while (size >= 1024 && i < 3) {
        size /= 1024;
        i++;
    }
    char result[20];
    snprintf(result, sizeof(result), "%.2f %s", size, sizes[i]);
    return result;
}

void setupRoutes(httplib::Server & svr, Parser & parse, MiniHSFS & mini) {
    //   
    svr.Get("/", [](const httplib::Request&, httplib::Response& res) {
        ifstream file("index.html");
        if (!file) {
            res.set_content("Could not open index.html", "text/plain");
            return;
        }

        string content((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
        res.set_content(content, "text/html");
        });

    // API  
    svr.Get("/list", [&parse, &mini](const httplib::Request& req, httplib::Response& res) {
        try {
            string path = req.has_param("path") ? req.get_param_value("path") : "/";

            //    
            auto items = parse.getDirectoryItems(path, mini);
            stringstream ss;

            for (const auto& item : items) {
                bool isDir = item.isDirectory;
                string icon = isDir ? "bi-folder-fill" : "bi-file-earmark";
                string size = isDir ? "" : formatSize(item.size);
                string name = item.entries.begin()->first;

                ss << R"(<div class="file-item" data-type=")" << (isDir ? "dir" : "file") << R"(" 
                    data-path=")" << escapeHtml(path + (path == "/" ? "" : "/") + name) << R"(" 
                    data-name=")" << escapeHtml(name) << R"(" 
                    data-size=")" << size << R"(" 
                    data-modified=")" << formatTime(item.modificationTime) << R"(">)"
                    << R"(<div class="file-icon"><i class="bi )" << icon << R"("></i></div>)"
                    << R"(<div class="file-info"><div class="fw-bold file-name-text">)" << escapeHtml(name)
                    << R"(</div><div class="text-muted small">)"
                    << formatTime(item.modificationTime) << R"(</div></div>)"
                    << R"(<div class="file-actions">)"
                    << "</div></div>";
            }

            res.set_header("Content-Type", "text/html");
            res.set_content(ss.str(), "text/html");
        }
        catch (const exception& e) {
            res.status = 500;
            res.set_content("Error: " + string(e.what()), "text/plain");
        }
        });

    //   
    svr.Post("/mkdir", [&parse, &mini](const httplib::Request& req, httplib::Response& res) {
        string path = req.get_param_value("path");
        try {
            //     
            size_t lastSlash = path.find_last_of('/');
            string dirPath = path.substr(0, lastSlash);
            string dirName = path.substr(lastSlash + 1);

            if (dirPath.empty()) dirPath = "/";

            parse.createDirectory(path, "", mini);
            res.set_content("Directory created", "text/plain");
        }
        catch (const exception& e) {
            res.status = 500;
            res.set_content("Error: " + string(e.what()), "text/plain");
        }
        });

    //   
    svr.Post("/createfile", [&parse, &mini](const httplib::Request& req, httplib::Response& res) {
        string path = req.get_param_value("path");
        string name = req.get_param_value("name");
        try {
            int result = parse.createFile(path, name, mini);
            if (result >= 0) {
                res.set_content("File created successfully", "text/plain");
            }
            else {
                res.status = 400;
                res.set_content("Failed to create file", "text/plain");
            }
        }
        catch (const exception& e) {
            res.status = 500;
            res.set_content("Error: " + string(e.what()), "text/plain");
        }
        });

    //    
    svr.Post("/copy", [&parse, &mini](const httplib::Request& req, httplib::Response& res) {
        string srcPath = req.get_param_value("src");
        string destPath = req.get_param_value("dest");
        try {
            bool success = parse.copy(srcPath, destPath, mini);
            if (success) {
                res.set_content("Copied successfully", "text/plain");
            }
            else {
                res.status = 400;
                res.set_content("Failed to copy", "text/plain");
            }
        }
        catch (const exception& e) {
            res.status = 500;
            res.set_content("Error: " + string(e.what()), "text/plain");
        }
        });

    // /   
    svr.Post("/move", [&parse, &mini](const httplib::Request& req, httplib::Response& res) {
        string srcPath = req.get_param_value("src");
        string destPath = req.get_param_value("dest");
        try {
            bool success = parse.move(srcPath, destPath, mini);
            if (success) {
                res.set_content("Moved successfully", "text/plain");
            }
            else {
                res.status = 400;
                res.set_content("Failed to move", "text/plain");
            }
        }
        catch (const exception& e) {
            res.status = 500;
            res.set_content("Error: " + string(e.what()), "text/plain");
        }
        });

    //    
    svr.Post("/delete", [&parse, &mini](const httplib::Request& req, httplib::Response& res) {
        string path = req.get_param_value("path");
        bool isDir = req.get_param_value("is_dir") == "true";
        try {
            if (isDir) {
                parse.deleteDirectory(path, mini);
            }
            else {
                parse.deleteFile(path, mini);
            }
            res.set_content("Deleted", "text/plain");
        }
        catch (const exception& e) {
            res.status = 500;
            res.set_content("Error: " + string(e.what()), "text/plain");
        }
        });

    //    
    svr.Get("/properties", [&parse, &mini](const httplib::Request& req, httplib::Response& res) {
        try {
            string path = req.get_param_value("path");

            //    
            vector<string> parts = mini.SplitPath(path);
            int inodeIndex = mini.PathToInode(parts);

            if (inodeIndex == -1) {
                throw runtime_error("Directory not found");
            }

            const MiniHSFS::Inode& inode = mini.inodeTable[inodeIndex];


            //  JSON  
            stringstream json;
            json << "{";
            json << "\"name\":\"" << parts.back() << "\",";
            json << "\"path\":\"" << path << "\",";
            json << "\"created\":\"" << formatTime(inode.creationTime) << "\",";
            json << "\"modified\":\"" << formatTime(inode.modificationTime) << "\",";

            if (inode.isDirectory) {
                json << "\"item_count\":" << inode.entries.size() << ",";
                json << "\"type\":\"directory\"";
            }
            else {
                json << "\"size\":" << inode.size << ",";
                json << "\"type\":\"file\"";
            }
            json << "}";

            res.set_header("Content-Type", "application/json");
            res.set_content(json.str(), "application/json");
        }
        catch (const exception& e) {
            res.status = 500;
            res.set_content("Error: " + string(e.what()), "text/plain");
        }
        });

    //     
    svr.Post("/rename", [&parse, &mini](const httplib::Request& req, httplib::Response& res) {
        string oldPath = req.get_param_value("old_path");
        string newName = req.get_param_value("new_name");
        bool isDir = req.get_param_value("is_dir") == "true";

        try {
            //   
            parse.rename(oldPath, newName, mini);


            res.set_content("Renamed", "text/plain");
        }
        catch (const exception& e) {
            res.status = 500;
            res.set_content("Error: " + string(e.what()), "text/plain");
        }
        });

    //   
    svr.Get("/readfile", [&parse, &mini](const httplib::Request& req, httplib::Response& res) {
        try {
            std::string encoded_path = req.get_param_value("path");
            std::string path = httplib::detail::decode_url(encoded_path, false);

            if (!mini.mounted) {
                throw std::runtime_error("Filesystem not mounted");
            }

            mini.ValidatePath(path);

            int inode_index = mini.FindFile(path);
            if (inode_index == -1) {
                throw std::runtime_error("File not found");
            }

            MiniHSFS::Inode& inode = mini.inodeTable[inode_index];
            if (inode.isDirectory) {
                throw std::runtime_error("Cannot read directory as file");
            }

            //   
            size_t start = 0;
            size_t end = inode.size - 1;

            if (req.has_header("Range")) {
                std::string range = req.get_header_value("Range");
                if (range.find("bytes=") == 0) {
                    range = range.substr(6);
                    size_t dash_pos = range.find('-');
                    if (dash_pos != std::string::npos) {
                        start = std::stoull(range.substr(0, dash_pos));
                        if (dash_pos < range.length() - 1) {
                            end = std::stoull(range.substr(dash_pos + 1));
                        }
                    }
                }
            }

            //     
            start = (std::min)(start, inode.size - 1);
            end = (std::min)(end, inode.size - 1);
            size_t length = end - start + 1;

            //     
            std::vector<char> data = parse.readFile(path, mini, start, length, "123");

            if (req.has_header("Range")) {
                res.status = 206;
                std::ostringstream oss;
                oss << "bytes " << start << "-" << end << "/" << inode.size;
                res.set_header("Content-Range", oss.str());
            }

            res.set_header("Content-Type", "application/octet-stream");
            res.set_header("Content-Length", std::to_string(data.size()));
            res.set_header("Accept-Ranges", "bytes");
            res.set_content(data.data(), data.size(), "application/octet-stream");
        }
        catch (const std::exception& e) {
            std::cerr << "File read error: " << e.what() << std::endl;
            res.status = 500;
            res.set_content("Error: " + std::string(e.what()), "text/plain");
        }
        });

    //   
    svr.Post("/writefile", [&parse, &mini](const httplib::Request& req, httplib::Response& res) {
        try {
            //    FormData
            auto path = req.get_file_value("path").content;
            auto content = req.get_file_value("content").content;

            vector<char> data(content.begin(), content.end());
            bool success = parse.writeFile(path, data, mini);

            if (success) {
                res.set_content("File saved successfully", "text/plain");
            }
            else {
                res.status = 400;
                res.set_content("Failed to save file", "text/plain");
            }
        }
        catch (const exception& e) {
            res.status = 500;
            res.set_content(string("Error: ") + e.what(), "text/plain");
        }
        });

    //  
    svr.Post("/shutdown", [&svr, &parse, &mini](const httplib::Request&, httplib::Response& res) {
        try {
            parse.exit(mini);  //    

            res.set_content("System is shutting down", "text/plain");

            //     Thread      HTTP
            std::thread shutdown_thread([&svr]() {
                std::this_thread::sleep_for(std::chrono::milliseconds(100));
                svr.stop();  //     
                });
            shutdown_thread.detach();  //    main thread
        }
        catch (const std::exception& e) {
            res.status = 500;
            res.set_content("Error: " + std::string(e.what()), "text/plain");
        }
        });
}


int main() {

    printColoredText();
    const std::string diskPath = "test_disk.vd";
    const uint64_t diskSizeMB = 50; // 10MB virtual disk
    const uint32_t blockSize = 4 * 1024; //4KB

    //Initialize virtual disk
    std::cout << "\033[1;33mInitializing virtual disk...\033[0m\n";

    MiniHSFS mini(diskPath, diskSizeMB, blockSize);

    if (mini.Disk().IsNew())
        std::cout << "\033[1;32mDisk initialized successfully! Total blocks: "
        << mini.Disk().totalBlocks() << "\n\033[0m";
    else
        std::cout << "\033[1;32mDisk Open successfully! Total blocks: "
        << mini.Disk().totalBlocks() << "\n\033[0m";
    mini.Mount();

    //////////////////////////////////////////////////////////////
    //// Initialize and mount the file system
    std::cout << "\033[1;32mFile system mounted successfully.\033[0m\n";
    
    //std::string ip = getIPfromIpconfig();
    //std::cout << "Local IP: " <<"http://"<< ip<<":8081" << std::endl;
    //
    //httplib::Server svr;
    //Parser parse;
    //setupRoutes(svr, parse, mini);
    //std::cout << " Server is running at http://localhost:8081" << std::endl;
    //
    //svr.listen("0.0.0.0", 8081);

  std::string input;

    auto parser = std::make_shared<Parser>();
    Tokenizer tokenizer(parser, mini);

    while (true)
    {
        try {
            std::cout << run::currentPath << " >> ";
            std::getline(std::cin, input);
            tokenizer.processCommand(input, mini);
            if (input == "exit") break;
        }
        catch (const std::exception& ex) {
            std::cerr << "\n\033[1;31mFatal Error: " << ex.what() << "\n\033[0m";
        }
    }


 /*   auto data = std::vector<uint8_t>( 5,'T' );
    std::string password = "MyStrongPass123!";
    auto encrypted = CryptoUtils::EncryptWithSalt(data, password);
    auto encrypted2 = CryptoUtils::EncryptWithSalt(data, password);
    
    auto decrypted = CryptoUtils::DecryptWithSalt(encrypted, password);
    auto decrypted2 = CryptoUtils::DecryptWithSalt(encrypted2, password);
    
    std::cout << data.size() << std::endl;
    std::cout << encrypted2.size() << std::endl;
    std::cout << encrypted.size() << std::endl;*/

//------------------------------------------------------------------------//

    return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////
------------------------------
VirtualDisk.h
------------------------------
------------------------------
VirtualDisk.h
------------------------------

